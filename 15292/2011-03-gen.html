

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Generalized Types &mdash; Go Design Proposal  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> Go Design Proposal
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../11502-securitypolicy.html">Proposal: Security Policy for Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11970-decentralized-gc.html">Proposal: Decentralized GC coordination</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12166-subtests.html">Proposal: testing: programmatic sub-test and sub-benchmark support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12302-release-proposal.html">Proposal: A minimal release process for Go repositories</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12416-cgo-pointers.html">Proposal: Rules for passing pointers between Go and C</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12750-localization.html">Proposal: Localization support in Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12800-sweep-free-alloc.html">Proposal: Dense mark bits and sweep-free allocation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12914-monotonic.html">Proposal: Monotonic Elapsed Time Measurements in Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12914-monotonic.html#appendix-time-now-usage">Appendix: time.Now usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../13073-code-of-conduct.html">Proposal: A Code of Conduct for the Go community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../13432-mobile-audio.html">Proposal: Audio for Mobile</a></li>
<li class="toctree-l1"><a class="reference internal" href="../13504-natural-xml.html">Proposal: Natural XML</a></li>
<li class="toctree-l1"><a class="reference internal" href="../14313-benchmark-format.html">Proposal: Go Benchmark Data Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../14386-zip-package-archives.html">Proposal: Zip-based Go package archives</a></li>
<li class="toctree-l1"><a class="reference internal" href="../14951-soft-heap-limit.html">Proposal: Separate soft and hard heap size goal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../15292-generics.html">Proposal: Go should have generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../16085-conversions-ignore-tags.html">Proposal: Ignore tags in struct type conversions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../16339-alias-decls.html">Proposal: Alias declarations for Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="../16339-alias-decls.html#appendix">Appendix</a></li>
<li class="toctree-l1"><a class="reference internal" href="../16410-heap-viewer.html">Proposal: Go Heap Dump Viewer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../16704-cidr-notation-no-proxy.html">Proposal: Add support for CIDR notation in no_proxy variable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../17280-profile-labels.html">Proposal: Support for pprof profiler labels</a></li>
<li class="toctree-l1"><a class="reference internal" href="../17503-eliminate-rescan.html">Proposal: Eliminate STW stack re-scanning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../17505-concurrent-rescan.html">Proposal: Concurrent stack re-scanning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../18130-type-alias.html">Proposal: Type Aliases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../18802-percpu-sharded.html">Proposal: percpu.Sharded, an API for reducing cache contention</a></li>
<li class="toctree-l1"><a class="reference internal" href="../18802-percpu-sharded.html#discussion">Discussion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../18802-percpu-sharded.html#backwards-compatibility">Backwards compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19113-signed-shift-counts.html">Proposal: Permit Signed Integers as Shift Counts for Go 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19308-number-literals.html">Proposal: Go 2 Number Literal Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19348-midstack-inlining.html">Proposal: Mid-stack inlining in the Go compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19348-midstack-inlining.html#abstract">Abstract</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19348-midstack-inlining.html#background">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19348-midstack-inlining.html#proposal">Proposal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19348-midstack-inlining.html#rationale">Rationale</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19348-midstack-inlining.html#compatibility">Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19348-midstack-inlining.html#implementation">Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19348-midstack-inlining.html#prerequisite-changes">Prerequisite Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19348-midstack-inlining.html#preliminary-results">Preliminary Results</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19348-midstack-inlining.html#open-issues">Open issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19480-xml-stream.html">Proposal: XML Stream</a></li>
<li class="toctree-l1"><a class="reference internal" href="../22080-dwarf-inlining.html">Proposal: emit DWARF inlining info in the Go compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../22080-dwarf-inlining.html#abstract">Abstract</a></li>
<li class="toctree-l1"><a class="reference internal" href="../22080-dwarf-inlining.html#background">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="../22080-dwarf-inlining.html#example">Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../22080-dwarf-inlining.html#how-the-generated-dwarf-should-look">How the generated DWARF should look</a></li>
<li class="toctree-l1"><a class="reference internal" href="../22080-dwarf-inlining.html#outline-of-proposed-changes">Outline of proposed changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../22080-dwarf-inlining.html#compatibility">Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../22080-dwarf-inlining.html#implementation">Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../22080-dwarf-inlining.html#prerequisite-changes">Prerequisite Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../22080-dwarf-inlining.html#preliminary-results">Preliminary Results</a></li>
<li class="toctree-l1"><a class="reference internal" href="../22080-dwarf-inlining.html#open-issues">Open issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../24301-versioned-go.html">Proposal: Versioned Go Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../24543-non-cooperative-preemption.html">Proposal: Non-cooperative goroutine preemption</a></li>
<li class="toctree-l1"><a class="reference internal" href="../25530-sumdb.html">Proposal: Secure the Public Go Module Ecosystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../25719-go15vendor.html">Go 1.5 Vendor Experiment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../26160-dns-based-vanity-imports.html">Proposal: DNS Based Vanity Imports</a></li>
<li class="toctree-l1"><a class="reference internal" href="../26756-rawxml-token.html">Proposal: Raw XML Token</a></li>
<li class="toctree-l1"><a class="reference internal" href="../26903-simplify-mark-termination.html">Proposal: Simplify mark termination and eliminate mark 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../27539-internal-abi.html">Proposal: Create an undefined internal calling convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="../2775-binary-only-packages.html">Proposal: Binary-Only Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../27935-unbounded-queue-package.html">Proposal: Built in support for high performance unbounded queue</a></li>
<li class="toctree-l1"><a class="reference internal" href="../28221-go2-transitions.html">Proposal: Go 2 transition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../2981-go-test-json.html">Proposal: <code class="docutils literal notranslate"><span class="pre">-json</span></code> flag in <code class="docutils literal notranslate"><span class="pre">go</span> <span class="pre">test</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../29934-error-values.html">Proposal: Go 2 Error Inspection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../30333-smarter-scavenging.html">Proposal: Smarter Scavenging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../30411-env.html">Proposal: <code class="docutils literal notranslate"><span class="pre">go</span></code> command configuration file</a></li>
<li class="toctree-l1"><a class="reference internal" href="../32437-try-builtin.html">Proposal: A built-in Go error check function, <code class="docutils literal notranslate"><span class="pre">try</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../33974-add-public-lockedfile-pkg.html">Proposal: make the internal lockedfile package public</a></li>
<li class="toctree-l1"><a class="reference internal" href="../34481-opencoded-defers.html">Proposal: Low-cost defers through inline code, and extra funcdata to manage the panic case</a></li>
<li class="toctree-l1"><a class="reference internal" href="../35112-scaling-the-page-allocator.html">Proposal: Scaling the Go page allocator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../36460-lazy-module-loading.html">Proposal: Lazy Module Loading</a></li>
<li class="toctree-l1"><a class="reference internal" href="../36606-64-bit-field-alignment.html">Proposal: Make 64-bit fields be 64-bit aligned on 32-bit systems, add //go:packed, //go:align directives</a></li>
<li class="toctree-l1"><a class="reference internal" href="../37112-unstable-runtime-metrics.html">Proposal: API for unstable runtime metrics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../37720-gopls-workspaces.html">Proposal: Multi-project gopls workspaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../4899-testing-helper.html">Proposal: testing: better support test helper functions with TB.Helper</a></li>
<li class="toctree-l1"><a class="reference internal" href="../6282-table-data.html">Proposal: Multi-dimensional slices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../6977-overlapping-interfaces.html">Proposal: Permit embedding of interfaces with overlapping method sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../TEMPLATE.html">Proposal: [Title]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cryptography-principles.html">Cryptography Principles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../go2draft.html">Go 2 Draft Designs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../go2draft-contracts.html">Contracts — Draft Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../go2draft-error-handling.html">Error Handling — Draft Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../go2draft-error-handling-overview.html">Error Handling — Problem Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../go2draft-error-inspection.html">Error Inspection — Draft Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../go2draft-error-printing.html">Error Printing — Draft Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../go2draft-error-values-overview.html">Error Values — Problem Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../go2draft-generics-overview.html">Generics — Problem Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../go2draft-type-parameters.html">Type Parameters - Draft Design</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Go Design Proposal</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Generalized Types</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/15292/2011-03-gen.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="generalized-types">
<h1>Generalized Types<a class="headerlink" href="#generalized-types" title="Permalink to this headline">¶</a></h1>
<p>This is a proposal for adding generics to Go, written by Ian Lance
Taylor in March, 2011.
This proposal will not be adopted.
It is being presented as an example for what a complete generics
proposal must cover.</p>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This document describes a possible implementation of generalized types
in Go.
We introduce a new keyword, <code class="docutils literal notranslate"><span class="pre">gen</span></code>, which declares one or more type
parameters: types that are not known at compile time.
These type parameters may then be used in other declarations,
producing generalized types and functions.</p>
<p>Some goals, borrowed from <a class="reference external" href="https://web.archive.org/web/20170812055356/http://www.crest.iu.edu/publications/prints/2003/comparing_generic_programming03.pdf">Garcia et al</a>:</p>
<ul class="simple">
<li><p>Do not require an explicit relationship between a definition of a generalized function and its use. The function should be callable with any type that fits the required form.</p></li>
<li><p>Permit interfaces to express relationships between types of methods, as in a comparison function that takes two parameters of the same unknown type.</p></li>
<li><p>Given a generalized type, make it possible to use related types, such as a slice of that type.</p></li>
<li><p>Do not require explicit instantiation of generalized functions.</p></li>
<li><p>Permit type aliasing of generalized types.</p></li>
</ul>
<p>The type parameter introduced by a <code class="docutils literal notranslate"><span class="pre">gen</span></code> declaration is a concept that
exists at compile time.
Any actual value that exists at runtime has a specific concrete type:
an ordinary non-generalized type, or a generalized type that has been
instantiated as a concrete type.
Generalized functions will be compiled to handle values whose types
are supplied at runtime.</p>
<p>This is what changes in the language:</p>
<ul class="simple">
<li><p>There is a new syntax for declaring a type parameter (or parameters) for the scope of one or more declarations.</p></li>
<li><p>There is a new syntax for specifying the concrete type(s) to use when using something declared with a type parameter.</p></li>
<li><p>There is a new syntax for converting values of concrete type, and untyped constants, to generalized types.  Also values of generalized type are permitted in type assertions.</p></li>
<li><p>Within a function, we define the operations permitted on values with a generalized type.</p></li>
</ul>
</div>
<div class="section" id="syntax">
<h2>Syntax<a class="headerlink" href="#syntax" title="Permalink to this headline">¶</a></h2>
<p>Any package-scope type or function declaration may be preceded with
the new keyword <code class="docutils literal notranslate"><span class="pre">gen</span></code> followed by a list of type parameter names in
square brackets:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gen</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="nb">type</span> <span class="n">Vector</span> <span class="p">[]</span><span class="n">T</span>
</pre></div>
</div>
<p>This defines <code class="docutils literal notranslate"><span class="pre">T</span></code> as a type parameter for the generalized type <code class="docutils literal notranslate"><span class="pre">Vector</span></code>.
The scope of <code class="docutils literal notranslate"><span class="pre">Vector</span></code> is the same as it would be if <code class="docutils literal notranslate"><span class="pre">gen</span></code> did not appear.</p>
<p>A use of a generalized type will normally provide specific types to
use for the type parameters.
This is done using square brackets following the generalized type.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">VectorInt</span> <span class="n">Vector</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
<span class="n">var</span> <span class="n">v1</span> <span class="n">Vector</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
<span class="n">var</span> <span class="n">v2</span> <span class="n">Vector</span><span class="p">[</span><span class="n">float32</span><span class="p">]</span>
<span class="n">gen</span> <span class="p">[</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">]</span> <span class="nb">type</span> <span class="n">Pair</span> <span class="n">struct</span> <span class="p">{</span> <span class="n">first</span> <span class="n">T1</span><span class="p">;</span> <span class="n">second</span> <span class="n">T2</span> <span class="p">}</span>
<span class="n">var</span> <span class="n">v3</span> <span class="n">Pair</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">string</span><span class="p">]</span>
</pre></div>
</div>
<p>Type parameters may also be used with functions.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gen</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="n">func</span> <span class="n">SetHead</span><span class="p">(</span><span class="n">v</span> <span class="n">Vector</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">e</span> <span class="n">T</span><span class="p">)</span> <span class="n">T</span> <span class="p">{</span>
	<span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span>
	<span class="k">return</span> <span class="n">e</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For convenience, we permit a modified version of the factoring syntax
used with <code class="docutils literal notranslate"><span class="pre">var</span></code>, <code class="docutils literal notranslate"><span class="pre">type</span></code>, and <code class="docutils literal notranslate"><span class="pre">const</span></code> to permit a series of
declarations to share the same type parameters.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gen</span> <span class="p">[</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">]</span> <span class="p">(</span>
<span class="nb">type</span> <span class="n">Pair</span> <span class="n">struct</span> <span class="p">{</span> <span class="n">first</span> <span class="n">T1</span><span class="p">;</span> <span class="n">second</span> <span class="n">T2</span> <span class="p">}</span>

<span class="n">func</span> <span class="n">MakePair</span><span class="p">(</span><span class="n">first</span> <span class="n">T1</span><span class="p">,</span> <span class="n">second</span> <span class="n">T2</span><span class="p">)</span> <span class="n">Pair</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">Pair</span><span class="p">{</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">}</span>
<span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
<p>References to other names declared within the same gen block do not
have to specify the type parameters.
When the type parameters are omitted, they are assumed to simply be
the parameters declared for the block.
In the above example, <code class="docutils literal notranslate"><span class="pre">Pair</span></code> when used as the result type of
<code class="docutils literal notranslate"><span class="pre">MakePair</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">Pair[T1,</span> <span class="pre">T2]</span></code>.</p>
<p>As with generalized types, we must specify the types when we refer to
a generalized function (but see the section on type deduction, below).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">MakeIntPair</span> <span class="o">=</span> <span class="n">MakePair</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
<span class="n">var</span> <span class="n">IntPairZero</span> <span class="o">=</span> <span class="n">MakeIntPair</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>A generalized type can have methods.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gen</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="n">func</span> <span class="p">(</span><span class="n">v</span> <span class="o">*</span><span class="n">Vector</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="n">SetHeadMethod</span><span class="p">(</span><span class="n">e</span> <span class="n">T</span><span class="p">)</span> <span class="n">T</span> <span class="p">{</span>
	<span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span>
	<span class="k">return</span> <span class="n">e</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Of course a method of a generalized type may itself be a generalized function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gen</span> <span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T2</span><span class="p">]</span> <span class="n">func</span> <span class="p">(</span><span class="n">v</span> <span class="o">*</span><span class="n">Vector</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="n">Transform</span><span class="p">(</span><span class="n">f</span> <span class="n">func</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">T2</span><span class="p">)</span> <span class="n">Vector</span><span class="p">[</span><span class="n">T2</span><span class="p">]</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">gen</span></code> keyword may only be used with a type or function.
It may only appear in package scope, not within a function.
One <code class="docutils literal notranslate"><span class="pre">gen</span></code> keyword may appear within the scope of another.
In that case, any use of the generalized type or function must specify
all the type parameters, starting with the outermost ones.
A different way of writing the last example would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gen</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="p">(</span>
<span class="nb">type</span> <span class="n">Vector</span> <span class="p">[]</span><span class="n">T</span>
<span class="n">gen</span> <span class="p">[</span><span class="n">T2</span><span class="p">]</span> <span class="n">func</span> <span class="p">(</span><span class="n">v</span> <span class="o">*</span><span class="n">Vector</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="n">Transform</span><span class="p">(</span><span class="n">f</span> <span class="n">func</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">T2</span><span class="p">)</span> <span class="n">Vector</span><span class="p">[</span><span class="n">T2</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">var</span> <span class="n">v</span> <span class="n">Vector</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
<span class="n">var</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">Transform</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">string</span><span class="p">](</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>Type deduction, described below, would permit omitting the
<code class="docutils literal notranslate"><span class="pre">[int,</span> <span class="pre">string]</span></code> in the last line, based on the types of <code class="docutils literal notranslate"><span class="pre">v</span></code> and <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p>
<div class="section" id="a-note-on-syntax">
<h3>A note on syntax<a class="headerlink" href="#a-note-on-syntax" title="Permalink to this headline">¶</a></h3>
<p>While the use of the <code class="docutils literal notranslate"><span class="pre">gen</span></code> keyword fits reasonably well into the
existing Go language, the use of square brackets to denote the
specific types is new to Go.
We have considered a number of different approaches:</p>
<ul class="simple">
<li><p>Use angle brackets, as in <code class="docutils literal notranslate"><span class="pre">Pair&lt;int,</span> <span class="pre">string&gt;</span></code>. This has the advantage of being familiar to C++ and Java programmers. Unfortunately, it means that <code class="docutils literal notranslate"><span class="pre">f&lt;T&gt;(true)</span></code> can be parsed as either a call to function <code class="docutils literal notranslate"><span class="pre">f&lt;T&gt;</span></code> or a comparison of <code class="docutils literal notranslate"><span class="pre">f&lt;T</span></code> (an expression that tests whether <code class="docutils literal notranslate"><span class="pre">f</span></code> is less than <code class="docutils literal notranslate"><span class="pre">T</span></code>) with <code class="docutils literal notranslate"><span class="pre">(true)</span></code>. While it may be possible to construct complex resolution rules, the Go syntax avoids that sort of ambiguity for good reason.</p></li>
<li><p>Overload the dot operator again, as in <code class="docutils literal notranslate"><span class="pre">Vector.int</span></code> or <code class="docutils literal notranslate"><span class="pre">Pair.(int,</span> <span class="pre">string)</span></code>. This becomes confusing when we see <code class="docutils literal notranslate"><span class="pre">Vector.(int)</span></code>, which could be a type assertion.</p></li>
<li><p>We considered using dot but putting the type first, as in <code class="docutils literal notranslate"><span class="pre">int.Vector</span></code> or <code class="docutils literal notranslate"><span class="pre">(int,</span> <span class="pre">string).Pair</span></code>. It might be possible to make that work without ambiguity, but putting the types first seems to make the code harder to read.</p></li>
<li><p>An earlier version of this proposal used parentheses for names after types, as in <code class="docutils literal notranslate"><span class="pre">Vector(int)</span></code>. However, that proposal was flawed because there was no way to specify types for generalized functions, and extending the parentheses syntax led to <code class="docutils literal notranslate"><span class="pre">MakePair(int,</span> <span class="pre">string)(1,</span> <span class="pre">&quot;&quot;)</span></code> which seems less than ideal.</p></li>
<li><p>We considered various different characters, such as backslash, dollar sign, at-sign or sharp. The square brackets grouped the parameters nicely and provide an acceptable visual appearance.</p></li>
</ul>
</div>
</div>
<div class="section" id="type-deduction">
<h2>Type Deduction<a class="headerlink" href="#type-deduction" title="Permalink to this headline">¶</a></h2>
<p>When calling a function, as opposed to referring to it without calling
it, the type parameters may be omitted in some cases.
A function call may omit the type parameters when every type parameter
is used for a regular parameter, or, in other words, there are no type
parameters that are used only for results.
In that case the compiler will compare the actual type of the
argument (<code class="docutils literal notranslate"><span class="pre">A</span></code>) with the type of the generalized parameter (<code class="docutils literal notranslate"><span class="pre">P</span></code>), examining
the arguments from left to right.
<code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">P</span></code> must be identical.
The first time we see a type parameter in <code class="docutils literal notranslate"><span class="pre">P</span></code>, it will be set to the
appropriate portion of <code class="docutils literal notranslate"><span class="pre">A</span></code>.
If the type parameter appears again, it must be identical to the
actual type at that point.</p>
<p>Note that at compile time the argument type may itself be a
generalized type.
The type deduction algorithm is the same.
A type parameter of <code class="docutils literal notranslate"><span class="pre">P</span></code> may match a type parameter of <code class="docutils literal notranslate"><span class="pre">A</span></code>.
Once this match is made, then every subsequent instance of the <code class="docutils literal notranslate"><span class="pre">P</span></code> type
parameter must match the same <code class="docutils literal notranslate"><span class="pre">A</span></code> type parameter.</p>
<p>When doing type deduction with an untyped numeric constant, the
constant is given the type <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">float64</span></code>, or <code class="docutils literal notranslate"><span class="pre">complex128</span></code> as usual.
Type deduction does not support passing an untyped <code class="docutils literal notranslate"><span class="pre">nil</span></code> constant;
<code class="docutils literal notranslate"><span class="pre">nil</span></code> may only be used with an explicit type conversion (or, of course,
the type parameters may be written explicitly).</p>
<p>For example, these two variables will have the same type and value.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">MakePair</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">](</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">var</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">MakePair</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>			<span class="o">//</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="n">deduced</span><span class="o">.</span>
</pre></div>
</div>
</div>
<div class="section" id="constraints">
<h2>Constraints<a class="headerlink" href="#constraints" title="Permalink to this headline">¶</a></h2>
<p>The only things that a generalized function can do with a value of
generalized type are the operations inherent to the type—e.g., the
<code class="docutils literal notranslate"><span class="pre">Vector</span></code> type can be indexed or sliced.
But sometimes we want to be able to say something about the types that
are used as part of a larger type.
Specifically, we want to say that they must implement a particular
interface.
So when listing the identifiers following <code class="docutils literal notranslate"><span class="pre">gen</span></code> we permit an optional
interface type following the name.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gen</span> <span class="p">[</span><span class="n">T</span> <span class="n">Stringer</span><span class="p">]</span> <span class="nb">type</span> <span class="n">PrintableVector</span> <span class="p">[]</span><span class="n">T</span>
</pre></div>
</div>
<p>Now <code class="docutils literal notranslate"><span class="pre">PrintableVector</span></code> may only be used with types that implement the
<code class="docutils literal notranslate"><span class="pre">Stringer</span></code> interface.</p>
<p>The interface may itself be a generalized type.
The scope of each type parameter starts at the <code class="docutils literal notranslate"><span class="pre">[</span></code>, and so we permit
using the type identifier just named with the generalized interface
type.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Types</span> <span class="n">that</span> <span class="n">may</span> <span class="n">be</span> <span class="n">compared</span> <span class="k">with</span> <span class="n">some</span> <span class="n">other</span> <span class="nb">type</span><span class="o">.</span>
<span class="n">gen</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="nb">type</span> <span class="n">Comparer</span> <span class="n">interface</span> <span class="p">{</span>
	<span class="n">Compare</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="nb">int</span>	<span class="o">//</span> <span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="o">==</span><span class="mi">0</span><span class="p">,</span> <span class="o">&gt;</span><span class="mi">0</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">Vector</span> <span class="n">of</span> <span class="n">elements</span> <span class="n">that</span> <span class="n">may</span> <span class="n">be</span> <span class="n">compared</span> <span class="k">with</span> <span class="n">themselves</span><span class="o">.</span>
<span class="n">gen</span> <span class="p">[</span><span class="n">T</span> <span class="n">Comparer</span><span class="p">[</span><span class="n">T</span><span class="p">]]</span> <span class="nb">type</span> <span class="n">SortableVector</span> <span class="p">[]</span><span class="n">T</span>
</pre></div>
</div>
</div>
<div class="section" id="example">
<h2>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>package hashmap

gen [Keytype, Valtype] (

type bucket struct {
	next *bucket
	key Keytype
	val Valtype
}

type Hashfn func(Keytype) uint
type Eqfn func(Keytype, Keytype) bool

type Hashmap struct {
	hashfn Hashfn
	eqfn Eqfn
	buckets []bucket
	entries int
}

// This function must be called with explicit type parameters, as
// there is no way to deduce the value type. For example,
// h := hashmap.New[int, string](hashfn, eqfn)
func New(hashfn Hashfn, eqfn Eqfn) *Hashmap {
	return &amp;Hashmap{hashfn, eqfn, make([]buckets, 16), 0}
}

func (p *Hashmap) Lookup(key Keytype) (val Valtype, found bool) {
	h := p.hashfn(key) % len(p.buckets)
	for b := p.buckets[h]; b != nil; b = b.next {
		if p.eqfn(key, b.key) {
			return b.val, true
		}
	}
	return
}

func (p *Hashmap) Insert(key Keytype, val Valtype) (inserted bool) {
	// Implementation omitted.
}

) // Ends gen.

package sample

import (
“fmt”
“hashmap”
“os”
)

func hashint(i int) uint {
	return uint(i)
}

func eqint(i, j int) bool {
	return i == j
}

var v = hashmap.New[int, string](hashint, eqint)

func Add(id int, name string) {
	if !v.Insert(id, name) {
		fmt.Println(“duplicate id”, id)
		os.Exit(1)
	}
}

func Find(id int) string {
	val, found = v.Lookup(id)
	if !found {
		fmt.Println(“missing id”, id)
		os.Exit(1)
	}
}
</pre></div>
</div>
</div>
<div class="section" id="language-spec-changes">
<h2>Language spec changes<a class="headerlink" href="#language-spec-changes" title="Permalink to this headline">¶</a></h2>
<p>This is an outline of the changes required to the language spec.</p>
<div class="section" id="types">
<h3>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h3>
<p>A few paragraphs will be added to discuss generalized types.</p>
</div>
<div class="section" id="struct-types">
<h3>Struct types<a class="headerlink" href="#struct-types" title="Permalink to this headline">¶</a></h3>
<p>While a struct may use a type parameter as an anonymous field, within
generalized code only the generalized definition is considered when
resolving field references.
That is, given</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gen</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="nb">type</span> <span class="n">MyGenStruct</span> <span class="n">struct</span> <span class="p">{</span> <span class="n">T</span> <span class="p">}</span>
<span class="nb">type</span> <span class="n">MyRealStruct</span> <span class="p">{</span> <span class="n">i</span> <span class="nb">int</span> <span class="p">}</span>
<span class="nb">type</span> <span class="n">MyInstStruct</span> <span class="n">MyGenStruct</span><span class="p">[</span><span class="n">MyRealStruct</span><span class="p">]</span>
<span class="n">gen</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="n">func</span> <span class="n">GetI</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">MyGenStruct</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="nb">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">i</span>	<span class="o">//</span> <span class="n">INVALID</span>
<span class="p">}</span>
<span class="n">func</span> <span class="n">MyGetI</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">MyInstStruct</span><span class="p">)</span> <span class="nb">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">GetI</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>the function <code class="docutils literal notranslate"><span class="pre">GetI</span></code> may not refer to the field <code class="docutils literal notranslate"><span class="pre">i</span></code> even though the
field exists when called from <code class="docutils literal notranslate"><span class="pre">MyGetI</span></code>.
(This restriction is fairly obvious if you think about it, but is
explicitly stated for clarity.)</p>
</div>
<div class="section" id="type-identity">
<h3>Type Identity<a class="headerlink" href="#type-identity" title="Permalink to this headline">¶</a></h3>
<p>We define type identity for generalized types.
Two generalized types are identical if they have the same name and the
type parameters are identical.</p>
</div>
<div class="section" id="assignability">
<h3>Assignability<a class="headerlink" href="#assignability" title="Permalink to this headline">¶</a></h3>
<p>We define assignability for generalized types.
A value <code class="docutils literal notranslate"><span class="pre">x</span></code> of generalized type <code class="docutils literal notranslate"><span class="pre">T1</span></code> is assignable to a variable of
type <code class="docutils literal notranslate"><span class="pre">T2</span></code> if <code class="docutils literal notranslate"><span class="pre">T1</span></code> and <code class="docutils literal notranslate"><span class="pre">T2</span></code> are identical.
A value <code class="docutils literal notranslate"><span class="pre">x</span></code> of concrete type is never assignable to a variable of
generalized type: a generalized type coercion is required (see below).
Similarly, a value <code class="docutils literal notranslate"><span class="pre">x</span></code> of generalized type is never assignable to a
variable of concrete type: a type assertion is required.
For example (more details given below):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>gen [T] func Zero() (z T) {
	z = 0			 // INVALID: concrete to generalized.
	z = int(0)		 // INVALID: concrete to generalized.
	z = 0.[T]		 // Valid: generalized type coercion.
}
gen [T] func ToInt(v T) (r int) {
	r = v			 // INVALID: generalized to concrete
	r = int(v)		 // INVALID: no conversions for gen types
	r, ok := v.(int) // Valid: generalized type assertion.
	if !ok {
		panic(“not int”)
	}
}
</pre></div>
</div>
</div>
<div class="section" id="declarations-and-scope">
<h3>Declarations and scope<a class="headerlink" href="#declarations-and-scope" title="Permalink to this headline">¶</a></h3>
<p>A new section Generalized declarations is added, consisting of a few
paragraphs that describe generalized declarations and the gen syntax.</p>
</div>
<div class="section" id="indexes">
<h3>Indexes<a class="headerlink" href="#indexes" title="Permalink to this headline">¶</a></h3>
<p>The new syntax <code class="docutils literal notranslate"><span class="pre">x[T]</span></code> for a generalized type or function is defined,
where <code class="docutils literal notranslate"><span class="pre">T</span></code> is a type and <code class="docutils literal notranslate"><span class="pre">x</span></code> is the name of some type or function
declared within a <code class="docutils literal notranslate"><span class="pre">gen</span></code> scope.</p>
</div>
<div class="section" id="type-assertions">
<h3>Type assertions<a class="headerlink" href="#type-assertions" title="Permalink to this headline">¶</a></h3>
<p>We define type assertions using generalized types.</p>
<p>Given <code class="docutils literal notranslate"><span class="pre">x.(T)</span></code> where <code class="docutils literal notranslate"><span class="pre">x</span></code> is a value with generalized type and <code class="docutils literal notranslate"><span class="pre">T</span></code> is a
concrete type, the type assertion succeeds if the concrete type of <code class="docutils literal notranslate"><span class="pre">x</span></code>
is identical to <code class="docutils literal notranslate"><span class="pre">T</span></code>, or, if <code class="docutils literal notranslate"><span class="pre">T</span></code> is an interface type, the concrete
type implements the interface <code class="docutils literal notranslate"><span class="pre">T</span></code>.
In other words, pretty much the same as doing a type assertion of a
value of interface type.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">T</span></code> are both generalized types, we do the same test using
the concrete types of <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<p>In general these assertions must be checked at runtime.</p>
</div>
<div class="section" id="generalized-type-coercions">
<h3>Generalized type coercions<a class="headerlink" href="#generalized-type-coercions" title="Permalink to this headline">¶</a></h3>
<p>We introduce a new syntax for coercing a value of concrete type to a
generalized type.
Where <code class="docutils literal notranslate"><span class="pre">x</span></code> is a value with concrete type and <code class="docutils literal notranslate"><span class="pre">T</span></code> is a generalized type,
the expression <code class="docutils literal notranslate"><span class="pre">x.[T]</span></code> coerces <code class="docutils literal notranslate"><span class="pre">x</span></code> to the generalized type <code class="docutils literal notranslate"><span class="pre">T</span></code>.
The generalized type coercion may succeed or fail, just as with a type
assertion.
However, it is not a pure type assertion, as we permit <code class="docutils literal notranslate"><span class="pre">x</span></code> to be an
untyped constant.
The generalized type coercion succeeds if the concrete type matches
the generalized type, where any parameters of the generalized type
match the appropriate portion of the concrete type.
If the same parameter appears more than once in the generalized type,
it must match identical types in the concrete type.
If the value is an untyped constant, the coercion succeeds if an
assignment of that constant to the concrete type would succeed at
compile time.</p>
</div>
<div class="section" id="calls">
<h3>Calls<a class="headerlink" href="#calls" title="Permalink to this headline">¶</a></h3>
<p>This section is extended to describe the type deduction algorithm used
to avoid explicit type parameters when possible.</p>
<p>An implicit generalized type conversion is applied to convert the
arguments to the expected generalized type, even though normally
values of concrete type are not assignable to variables of generalized
type.
Type checking ensures that the arguments must be assignable to the
concrete type which is either specified or deduced, and so this
implicit generalized type conversion will always succeed.</p>
<p>When a result parameter has a generalized type, an implicit type
assertion is applied to convert back to the type that the caller
expects, which may be a concrete type.
The type expected by the caller is determined by the type parameters
passed to the function, whether determined via type deduction or not.
This implicit type assertion will always succeed.
For example, in</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gen</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="n">func</span> <span class="n">Identity</span><span class="p">(</span><span class="n">v</span> <span class="n">T</span><span class="p">)</span> <span class="n">T</span> <span class="p">{</span> <span class="k">return</span> <span class="n">v</span> <span class="p">}</span>
<span class="n">func</span> <span class="n">Call</span><span class="p">(</span><span class="n">i</span> <span class="nb">int</span><span class="p">)</span> <span class="p">{</span> <span class="n">j</span> <span class="o">:=</span> <span class="n">Identity</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>the variable <code class="docutils literal notranslate"><span class="pre">j</span></code> gets the type <code class="docutils literal notranslate"><span class="pre">int</span></code>, and an implicit type assertion
converts the return value of <code class="docutils literal notranslate"><span class="pre">Identity[int]</span></code> to <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p>
</div>
<div class="section" id="conversions">
<h3>Conversions<a class="headerlink" href="#conversions" title="Permalink to this headline">¶</a></h3>
<p>Nothing needs to change in this section.
I just want to note explicitly that there are no type conversions for
generalized types other than the standard conversions that apply to
all types.</p>
</div>
<div class="section" id="type-switches">
<h3>Type switches<a class="headerlink" href="#type-switches" title="Permalink to this headline">¶</a></h3>
<p>A type switch may be used on a value of generalized type.
Type switch cases may include generalized types.
The rules are the same as for type assertions.</p>
</div>
<div class="section" id="for-statements">
<h3>For statements<a class="headerlink" href="#for-statements" title="Permalink to this headline">¶</a></h3>
<p>A range clause may be used with a value of generalized type, if the
generalized type is known to be a slice, array, map or channel.</p>
</div>
</div>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>Any actual value in Go will have a concrete type.
The implementation issue that arises is how to compile a function that
has parameters with generalized type.</p>
<div class="section" id="representation">
<h3>Representation<a class="headerlink" href="#representation" title="Permalink to this headline">¶</a></h3>
<p>When calling a function that uses type parameters, the type parameters
are passed first, as pointers to a runtime type descriptor.
The type parameters are thus literally additional parameters to the
functions.</p>
</div>
<div class="section" id="id1">
<h3>Types<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>In some cases it will be necessary to create a new type at runtime,
which means creating a new runtime type descriptor.
It will be necessary to ensure that type descriptor comparisons
continue to work correctly.
For example, the hashmap example above will require creating a new
type for each call to <code class="docutils literal notranslate"><span class="pre">hashmap.New</span></code> for the concrete types that are used
in the call.
The reflect package already creates new runtime type descriptors in
the functions <code class="docutils literal notranslate"><span class="pre">PtrTo</span></code>, <code class="docutils literal notranslate"><span class="pre">ChanOf</span></code>, <code class="docutils literal notranslate"><span class="pre">FuncOf</span></code>, etc.</p>
<p>Type reflection on a generalized type will return the appropriate
runtime type descriptor, which may have been newly created.
Calling <code class="docutils literal notranslate"><span class="pre">Name()</span></code> on such a type descriptor will return a name with the
appropriate type parameters: e.g, <code class="docutils literal notranslate"><span class="pre">“Vector[int]”</span></code>.</p>
</div>
<div class="section" id="variable-declarations">
<h3>Variable declarations<a class="headerlink" href="#variable-declarations" title="Permalink to this headline">¶</a></h3>
<p>A local variable in a function may be declared with a generalized
type.
In the general case, the size of the variable is unknown, and must be
retrieved from the type descriptor.
Declaring a local variable of unknown size will dynamically allocate
zeroed memory of the appropriate size.
As an optimization the memory may be allocated on the stack when there
is sufficient room.</p>
</div>
<div class="section" id="composite-literals">
<h3>Composite literals<a class="headerlink" href="#composite-literals" title="Permalink to this headline">¶</a></h3>
<p>A generalized type that is defined to be a struct, array, slice, or
map type may be used to create a composite literal.
The expression has the same generalized type.
The elements of the composite literal must follow the assignability
rules.</p>
</div>
<div class="section" id="selectors">
<h3>Selectors<a class="headerlink" href="#selectors" title="Permalink to this headline">¶</a></h3>
<p>When <code class="docutils literal notranslate"><span class="pre">x</span></code> is a value of generalized type that is a struct, <code class="docutils literal notranslate"><span class="pre">x.f</span></code> can
refer to a field of that struct.
Whether <code class="docutils literal notranslate"><span class="pre">f</span></code> is a field of <code class="docutils literal notranslate"><span class="pre">x</span></code> is known at compile time.
The exact offset of the field in the struct value may not be known.
When it is not known, the field offset is retrieved from the type
descriptor at runtime.</p>
<p>Similarly, <code class="docutils literal notranslate"><span class="pre">x.f</span></code> may refer to a method of the type.
In this case the method is always known at compile time.</p>
<p>As noted above under struct types, if a generalized struct type uses a
type parameter as an anonymous field, the compiler does not attempt to
look up a field name in the concrete type of the field at runtime.</p>
</div>
<div class="section" id="id2">
<h3>Indexes<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>A value of a generalized type that is an array, slice or map may be indexed.
Note that when indexing into a map type, the type of the value must be
assignable to the map’s key type;
in practice this means that if the map’s key type is generalized, the
value must itself have the same generalized type.
Indexing into a generalized array or slice may require multiplying by
the element size found in the type descriptor.
Indexing into a generalized map may require a new runtime function.</p>
</div>
<div class="section" id="slices">
<h3>Slices<a class="headerlink" href="#slices" title="Permalink to this headline">¶</a></h3>
<p>A value of a generalized type that is an array or slice may itself be
sliced.
This operation is essentially the same as a slice of a value of
concrete type.</p>
</div>
<div class="section" id="id3">
<h3>Type Assertions<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>A type assertion generally requires a runtime check, and in the
general case requires comparing two concrete types at runtime, where
one of the types is known to instantiate some generalized type.
The complexity of the runtime check is linear in the number of tokens
in the generalized type, and requires storage space to store type
parameters during the check.
This check could be inlined into the code, or it could use a general
purpose runtime check that compares the concrete type descriptor to a
similar representation of the generalized type.</p>
</div>
<div class="section" id="id4">
<h3>Calls<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>Function calls can require converting normal values to generalized
values.
This operation depends on the representation chosen for the
generalized value.
In the worst case it will be similar to passing a normal value to a
function that takes an interface type.
When calling a function with type parameters, the type parameters will
be passed first, as a pointer to a runtime type descriptor.</p>
<p>Function calls can also require converting generalized return values
to normal values.
This is done via an implicitly inserted type assertion.
Depending on the representation, this may not require any actual code
to be generated.</p>
</div>
<div class="section" id="communication-operators">
<h3>Communication operators<a class="headerlink" href="#communication-operators" title="Permalink to this headline">¶</a></h3>
<p>We have to implement sending and receiving generalized values for
channels of generalized type.</p>
</div>
<div class="section" id="assignments">
<h3>Assignments<a class="headerlink" href="#assignments" title="Permalink to this headline">¶</a></h3>
<p>We have to implement assignment of generalized values.
This will be based on the runtime type descriptor.</p>
</div>
<div class="section" id="id5">
<h3>Type switches<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>We have to implement type switches using generalized types.
This will mostly likely devolve into a series of if statements using
type assertions.</p>
</div>
<div class="section" id="id6">
<h3>For statements<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>We have to implement for statements with range clauses over
generalized types.
This is similar to the indexing and communication operators.</p>
</div>
<div class="section" id="select-statements">
<h3>Select statements<a class="headerlink" href="#select-statements" title="Permalink to this headline">¶</a></h3>
<p>We have to implement select on channels of generalized type.</p>
</div>
<div class="section" id="return-statements">
<h3>Return statements<a class="headerlink" href="#return-statements" title="Permalink to this headline">¶</a></h3>
<p>We have to implement returning a value of generalized type.</p>
</div>
<div class="section" id="specialization-of-functions">
<h3>Specialization of functions<a class="headerlink" href="#specialization-of-functions" title="Permalink to this headline">¶</a></h3>
<p>This proposal is intended to support compiling a generalized function
into code that operates on generalized values.
In fact, it requires that this work.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">package</span> <span class="n">p1</span>
<span class="n">gen</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="n">func</span> <span class="n">Call</span><span class="p">(</span><span class="n">f</span> <span class="n">func</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span> <span class="n">T</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">package</span> <span class="n">p2</span>
<span class="n">func</span> <span class="n">SliceIdentity</span><span class="p">(</span><span class="n">a</span> <span class="p">[]</span><span class="nb">int</span><span class="p">)</span> <span class="p">[]</span><span class="nb">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">a</span>
<span class="p">}</span>

<span class="n">package</span> <span class="n">p3</span>
<span class="n">var</span> <span class="n">v</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">Call</span><span class="p">(</span><span class="n">p2</span><span class="o">.</span><span class="n">SliceIdentity</span><span class="p">,</span> <span class="n">make</span><span class="p">([]</span><span class="nb">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">Call</span></code> has to support calling a generalized function.
There is no straightforward specialization process that can implement
this case.
(It could be done if the full source code of p1 and p2 are available either when compiling p3 or at link time;
that is how C++ does it, but it is not an approach that fits well with Go.)</p>
<p>However, for many cases, this proposal can be implemented using
function specialization.
Whenever the compiler can use type deduction for a function call, and
the types are known concrete types, and the body of the function is
available, the compiler can generate a version of the function
specialized for those types.
This is, therefore, an optional optimization, in effect a form of
cross-package inlining, which costs compilation time but improves
runtime.</p>
</div>
</div>
<div class="section" id="methods-on-builtin-types">
<h2>Methods on builtin types<a class="headerlink" href="#methods-on-builtin-types" title="Permalink to this headline">¶</a></h2>
<p>This is an optional addendum to the proposal described above.</p>
<p>The proposal does not provide a convenient way to write a function
that works on any numeric type.
For example, there is no convenient way to write this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gen</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="n">func</span> <span class="n">SliceAverage</span><span class="p">(</span><span class="n">a</span> <span class="p">[]</span><span class="n">T</span><span class="p">)</span> <span class="n">T</span> <span class="p">{</span>
	<span class="n">s</span> <span class="o">:=</span> <span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="nb">range</span> <span class="n">a</span> <span class="p">{</span>
		<span class="n">s</span> <span class="o">+=</span> <span class="n">v</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">s</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It would be nice if that function worked for any numeric function.
However, it is not permitted under the proposal described above,
because of the use of <code class="docutils literal notranslate"><span class="pre">+=</span></code> and <code class="docutils literal notranslate"><span class="pre">/</span></code>.
These operators are not available for every type and therefore are not
available for a generalized type.</p>
<p>This approach does work:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gen</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="nb">type</span> <span class="n">Number</span> <span class="n">interface</span> <span class="p">{</span>
	<span class="n">Plus</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">T</span>
	<span class="n">Divide</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">T</span>
<span class="p">}</span>

<span class="n">gen</span> <span class="p">[</span><span class="n">T</span> <span class="n">Number</span><span class="p">[</span><span class="n">T</span><span class="p">]]</span> <span class="n">func</span> <span class="n">SliceAverage</span><span class="p">(</span><span class="n">a</span> <span class="p">[]</span><span class="n">T</span><span class="p">)</span> <span class="n">T</span> <span class="p">{</span>
	<span class="n">s</span> <span class="o">:=</span> <span class="mf">0.</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="nb">range</span> <span class="n">a</span> <span class="p">{</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">Plus</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">Divide</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>However, this requires writing explicit <code class="docutils literal notranslate"><span class="pre">Plus</span></code> and <code class="docutils literal notranslate"><span class="pre">Divide</span></code> methods for
each type you want to use.
These methods are themselves boilerplate:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="p">(</span><span class="n">i</span> <span class="n">MyNum</span><span class="p">)</span> <span class="n">Plus</span><span class="p">(</span><span class="n">v</span> <span class="n">MyNum</span><span class="p">)</span> <span class="n">MyNum</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="n">v</span> <span class="p">}</span>
<span class="n">func</span> <span class="p">(</span><span class="n">i</span> <span class="n">MyNum</span><span class="p">)</span> <span class="n">Divide</span><span class="p">(</span><span class="n">v</span> <span class="n">MyNum</span><span class="p">)</span> <span class="n">MyNum</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">/</span> <span class="n">v</span> <span class="p">}</span>
</pre></div>
</div>
<p>This proposal does not help with this kind of boilerplate function,
because there is no way to use operators with generalized values.</p>
<p>There are a few ways to solve this.
One way that seems to fit well with Go as extended by this proposal is
to declare that for all types that support some language operator, the
type has a corresponding method.
That is, we say that if the type can be used with <code class="docutils literal notranslate"><span class="pre">+</span></code>, the language
defines a method <code class="docutils literal notranslate"><span class="pre">Plus</span></code> (or <code class="docutils literal notranslate"><span class="pre">Binary+</span></code> or whatever) for the type that
implements the operation.
This method can then be picked up by an interface such as the above,
and the standard library can define convenient aggregate interfaces,
such as an interface listing all the methods supported by an integer
type.</p>
<p>Note that it would not help for the standard library to define a
<code class="docutils literal notranslate"><span class="pre">Plus</span></code> method for every integer type, as those methods would not carry
over to user defined types.</p>
</div>
<div class="section" id="operator-methods">
<h2>Operator methods<a class="headerlink" href="#operator-methods" title="Permalink to this headline">¶</a></h2>
<p>It is of course a smallish step from those language-defined methods to
having operator methods, which would permit writing generalized code
using operators rather than method calls.  For the purposes of using
generalized types, however, this is less important than having
language defined methods for operators.</p>
</div>
<div class="section" id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>This proposal will not be adopted.
It has significant flaws.</p>
<p>The factored <code class="docutils literal notranslate"><span class="pre">gen</span></code> syntax is convenient but looks awkward on the page.
You wind up with a trailing close parenthesis after a set of function
definitions.
Indenting all the function definitions looks silly.</p>
<p>This proposal doesn’t let me write a trivial generalized <code class="docutils literal notranslate"><span class="pre">Max</span></code>
function, unless we include operator methods.
Even when we include operator methods, <code class="docutils literal notranslate"><span class="pre">Max</span></code> has to be written in
terms of a <code class="docutils literal notranslate"><span class="pre">Less</span></code> method.</p>
<p>The handling of untyped constants in generalized functions is
extremely awkward.
They must always use a generalized type coercion.</p>
<p>While this proposal is more or less palatable for data structures,
it is much weaker for functions.
You basically can’t do anything with a generalized type,
except assign it and call a method on it.
Writing standardized algorithms will require developing a whole
vocabulary of quasi-standard methods.</p>
<p>The proposal doesn’t help write functions that work on either <code class="docutils literal notranslate"><span class="pre">[]byte</span></code>
or <code class="docutils literal notranslate"><span class="pre">string</span></code>, unless those types get additional operator methods like
<code class="docutils literal notranslate"><span class="pre">Index</span></code> and <code class="docutils literal notranslate"><span class="pre">Len</span></code>.
Even operator methods don’t help with using <code class="docutils literal notranslate"><span class="pre">range</span></code>.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>