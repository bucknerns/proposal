

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Contracts — Draft Design &mdash; Go Design Proposal  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Error Handling — Draft Design" href="go2draft-error-handling.html" />
    <link rel="prev" title="Go 2 Draft Designs" href="go2draft.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Go Design Proposal
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="11502-securitypolicy.html">Proposal: Security Policy for Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="11970-decentralized-gc.html">Proposal: Decentralized GC coordination</a></li>
<li class="toctree-l1"><a class="reference internal" href="12166-subtests.html">Proposal: testing: programmatic sub-test and sub-benchmark support</a></li>
<li class="toctree-l1"><a class="reference internal" href="12302-release-proposal.html">Proposal: A minimal release process for Go repositories</a></li>
<li class="toctree-l1"><a class="reference internal" href="12416-cgo-pointers.html">Proposal: Rules for passing pointers between Go and C</a></li>
<li class="toctree-l1"><a class="reference internal" href="12750-localization.html">Proposal: Localization support in Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="12800-sweep-free-alloc.html">Proposal: Dense mark bits and sweep-free allocation</a></li>
<li class="toctree-l1"><a class="reference internal" href="12914-monotonic.html">Proposal: Monotonic Elapsed Time Measurements in Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="12914-monotonic.html#appendix-time-now-usage">Appendix: time.Now usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="13073-code-of-conduct.html">Proposal: A Code of Conduct for the Go community</a></li>
<li class="toctree-l1"><a class="reference internal" href="13432-mobile-audio.html">Proposal: Audio for Mobile</a></li>
<li class="toctree-l1"><a class="reference internal" href="13504-natural-xml.html">Proposal: Natural XML</a></li>
<li class="toctree-l1"><a class="reference internal" href="14313-benchmark-format.html">Proposal: Go Benchmark Data Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="14386-zip-package-archives.html">Proposal: Zip-based Go package archives</a></li>
<li class="toctree-l1"><a class="reference internal" href="14951-soft-heap-limit.html">Proposal: Separate soft and hard heap size goal</a></li>
<li class="toctree-l1"><a class="reference internal" href="15292-generics.html">Proposal: Go should have generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="16085-conversions-ignore-tags.html">Proposal: Ignore tags in struct type conversions</a></li>
<li class="toctree-l1"><a class="reference internal" href="16339-alias-decls.html">Proposal: Alias declarations for Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="16339-alias-decls.html#appendix">Appendix</a></li>
<li class="toctree-l1"><a class="reference internal" href="16410-heap-viewer.html">Proposal: Go Heap Dump Viewer</a></li>
<li class="toctree-l1"><a class="reference internal" href="16704-cidr-notation-no-proxy.html">Proposal: Add support for CIDR notation in no_proxy variable</a></li>
<li class="toctree-l1"><a class="reference internal" href="17280-profile-labels.html">Proposal: Support for pprof profiler labels</a></li>
<li class="toctree-l1"><a class="reference internal" href="17503-eliminate-rescan.html">Proposal: Eliminate STW stack re-scanning</a></li>
<li class="toctree-l1"><a class="reference internal" href="17505-concurrent-rescan.html">Proposal: Concurrent stack re-scanning</a></li>
<li class="toctree-l1"><a class="reference internal" href="18130-type-alias.html">Proposal: Type Aliases</a></li>
<li class="toctree-l1"><a class="reference internal" href="18802-percpu-sharded.html">Proposal: percpu.Sharded, an API for reducing cache contention</a></li>
<li class="toctree-l1"><a class="reference internal" href="18802-percpu-sharded.html#discussion">Discussion</a></li>
<li class="toctree-l1"><a class="reference internal" href="18802-percpu-sharded.html#backwards-compatibility">Backwards compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="19113-signed-shift-counts.html">Proposal: Permit Signed Integers as Shift Counts for Go 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="19308-number-literals.html">Proposal: Go 2 Number Literal Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html">Proposal: Mid-stack inlining in the Go compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#abstract">Abstract</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#background">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#proposal">Proposal</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#rationale">Rationale</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#compatibility">Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#implementation">Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#prerequisite-changes">Prerequisite Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#preliminary-results">Preliminary Results</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#open-issues">Open issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="19480-xml-stream.html">Proposal: XML Stream</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html">Proposal: emit DWARF inlining info in the Go compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#abstract">Abstract</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#background">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#example">Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#how-the-generated-dwarf-should-look">How the generated DWARF should look</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#outline-of-proposed-changes">Outline of proposed changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#compatibility">Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#implementation">Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#prerequisite-changes">Prerequisite Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#preliminary-results">Preliminary Results</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#open-issues">Open issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="24301-versioned-go.html">Proposal: Versioned Go Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="24543-non-cooperative-preemption.html">Proposal: Non-cooperative goroutine preemption</a></li>
<li class="toctree-l1"><a class="reference internal" href="25530-sumdb.html">Proposal: Secure the Public Go Module Ecosystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="25719-go15vendor.html">Go 1.5 Vendor Experiment</a></li>
<li class="toctree-l1"><a class="reference internal" href="26160-dns-based-vanity-imports.html">Proposal: DNS Based Vanity Imports</a></li>
<li class="toctree-l1"><a class="reference internal" href="26756-rawxml-token.html">Proposal: Raw XML Token</a></li>
<li class="toctree-l1"><a class="reference internal" href="26903-simplify-mark-termination.html">Proposal: Simplify mark termination and eliminate mark 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="27539-internal-abi.html">Proposal: Create an undefined internal calling convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="2775-binary-only-packages.html">Proposal: Binary-Only Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="27935-unbounded-queue-package.html">Proposal: Built in support for high performance unbounded queue</a></li>
<li class="toctree-l1"><a class="reference internal" href="28221-go2-transitions.html">Proposal: Go 2 transition</a></li>
<li class="toctree-l1"><a class="reference internal" href="2981-go-test-json.html">Proposal: <code class="docutils literal notranslate"><span class="pre">-json</span></code> flag in <code class="docutils literal notranslate"><span class="pre">go</span> <span class="pre">test</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="29934-error-values.html">Proposal: Go 2 Error Inspection</a></li>
<li class="toctree-l1"><a class="reference internal" href="30333-smarter-scavenging.html">Proposal: Smarter Scavenging</a></li>
<li class="toctree-l1"><a class="reference internal" href="30411-env.html">Proposal: <code class="docutils literal notranslate"><span class="pre">go</span></code> command configuration file</a></li>
<li class="toctree-l1"><a class="reference internal" href="32437-try-builtin.html">Proposal: A built-in Go error check function, <code class="docutils literal notranslate"><span class="pre">try</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="33974-add-public-lockedfile-pkg.html">Proposal: make the internal lockedfile package public</a></li>
<li class="toctree-l1"><a class="reference internal" href="34481-opencoded-defers.html">Proposal: Low-cost defers through inline code, and extra funcdata to manage the panic case</a></li>
<li class="toctree-l1"><a class="reference internal" href="35112-scaling-the-page-allocator.html">Proposal: Scaling the Go page allocator</a></li>
<li class="toctree-l1"><a class="reference internal" href="36460-lazy-module-loading.html">Proposal: Lazy Module Loading</a></li>
<li class="toctree-l1"><a class="reference internal" href="36606-64-bit-field-alignment.html">Proposal: Make 64-bit fields be 64-bit aligned on 32-bit systems, add //go:packed, //go:align directives</a></li>
<li class="toctree-l1"><a class="reference internal" href="37112-unstable-runtime-metrics.html">Proposal: API for unstable runtime metrics</a></li>
<li class="toctree-l1"><a class="reference internal" href="37720-gopls-workspaces.html">Proposal: Multi-project gopls workspaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="4899-testing-helper.html">Proposal: testing: better support test helper functions with TB.Helper</a></li>
<li class="toctree-l1"><a class="reference internal" href="6282-table-data.html">Proposal: Multi-dimensional slices</a></li>
<li class="toctree-l1"><a class="reference internal" href="6977-overlapping-interfaces.html">Proposal: Permit embedding of interfaces with overlapping method sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="TEMPLATE.html">Proposal: [Title]</a></li>
<li class="toctree-l1"><a class="reference internal" href="cryptography-principles.html">Cryptography Principles</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft.html">Go 2 Draft Designs</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Contracts — Draft Design</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#superseded">Superseded</a></li>
<li class="toctree-l2"><a class="reference internal" href="#abstract">Abstract</a></li>
<li class="toctree-l2"><a class="reference internal" href="#background">Background</a></li>
<li class="toctree-l2"><a class="reference internal" href="#design">Design</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#type-parameters">Type parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-contracts">Type contracts</a></li>
<li class="toctree-l3"><a class="reference internal" href="#contract-introduction">Contract introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-a-contract-to-verify-type-arguments">Using a contract to verify type arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-party-of-the-second-part">The party of the second part</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-a-contract">Using a contract</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multiple-type-parameters">Multiple type parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parameterized-types">Parameterized types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parameterized-type-aliases">Parameterized type aliases</a></li>
<li class="toctree-l3"><a class="reference internal" href="#methods-may-not-take-additional-type-arguments">Methods may not take additional type arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#contract-embedding">Contract embedding</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-types-that-refer-to-themselves-in-contracts">Using types that refer to themselves in contracts</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mutually-referencing-type-parameters">Mutually referencing type parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#passing-parameters-to-a-contract">Passing parameters to a contract</a></li>
<li class="toctree-l3"><a class="reference internal" href="#contract-syntactic-details">Contract syntactic details</a></li>
<li class="toctree-l3"><a class="reference internal" href="#values-of-type-parameters-are-not-boxed">Values of type parameters are not boxed</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function-argument-type-inference">Function argument type inference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#instantiating-a-function">Instantiating a function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-assertions-and-switches">Type assertions and switches</a></li>
<li class="toctree-l3"><a class="reference internal" href="#instantiating-types-in-type-literals">Instantiating types in type literals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-parameterized-types-as-unnamed-function-parameter-types">Using parameterized types as unnamed function parameter types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#embedding-a-parameterized-type-in-a-struct">Embedding a parameterized type in a struct</a></li>
<li class="toctree-l3"><a class="reference internal" href="#embedding-a-parameterized-interface-type-in-an-interface">Embedding a parameterized interface type in an interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reflection">Reflection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#contracts-details">Contracts details</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#methods">Methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pointer-methods">Pointer methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pointer-or-value-methods">Pointer or value methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="#operators">Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#types-in-contracts">Types in contracts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#conjunction-and-disjunction-in-contracts">Conjunction and disjunction in contracts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#both-types-and-methods-in-contracts">Both types and methods in contracts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aggregate-types-in-contracts">Aggregate types in contracts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aggregates-of-type-parameters-in-contracts">Aggregates of type parameters in contracts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#comparable-types-in-contracts">Comparable types in contracts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#observations-on-types-in-contracts">Observations on types in contracts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#type-conversions">Type conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#untyped-constants">Untyped constants</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#implementation">Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#summary">Summary</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#complexity">Complexity</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pervasiveness">Pervasiveness</a></li>
<li class="toctree-l4"><a class="reference internal" href="#efficiency">Efficiency</a></li>
<li class="toctree-l4"><a class="reference internal" href="#omissions">Omissions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#issues">Issues</a></li>
<li class="toctree-l4"><a class="reference internal" href="#discarded-ideas">Discarded ideas</a></li>
<li class="toctree-l4"><a class="reference internal" href="#comparison-with-java">Comparison with Java</a></li>
<li class="toctree-l4"><a class="reference internal" href="#comparison-with-c">Comparison with C++</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#examples">Examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#sort">Sort</a></li>
<li class="toctree-l4"><a class="reference internal" href="#map-keys">Map keys</a></li>
<li class="toctree-l4"><a class="reference internal" href="#map-reduce-filter">Map/Reduce/Filter</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sets">Sets</a></li>
<li class="toctree-l4"><a class="reference internal" href="#channels">Channels</a></li>
<li class="toctree-l4"><a class="reference internal" href="#containers">Containers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#append">Append</a></li>
<li class="toctree-l4"><a class="reference internal" href="#metrics">Metrics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#list-transform">List transform</a></li>
<li class="toctree-l4"><a class="reference internal" href="#context">Context</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dot-product">Dot product</a></li>
<li class="toctree-l4"><a class="reference internal" href="#absolute-difference">Absolute difference</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-handling.html">Error Handling — Draft Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-handling-overview.html">Error Handling — Problem Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-inspection.html">Error Inspection — Draft Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-printing.html">Error Printing — Draft Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-values-overview.html">Error Values — Problem Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-generics-overview.html">Generics — Problem Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-type-parameters.html">Type Parameters - Draft Design</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Go Design Proposal</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Contracts — Draft Design</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/go2draft-contracts.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="contracts-draft-design">
<h1>Contracts — Draft Design<a class="headerlink" href="#contracts-draft-design" title="Permalink to this headline">¶</a></h1>
<p>Ian Lance Taylor<br />Robert Griesemer<br />July 31, 2019</p>
<div class="section" id="superseded">
<h2>Superseded<a class="headerlink" href="#superseded" title="Permalink to this headline">¶</a></h2>
<p>We will not be pursuing the approach outlined in this design draft.
It has been replaced by a <a class="reference external" href="https://go.googlesource.com/proposal/+/refs/heads/master/design/go2draft-type-parameters">new design
draft</a>.
This document exists for historical context.</p>
</div>
<div class="section" id="abstract">
<h2>Abstract<a class="headerlink" href="#abstract" title="Permalink to this headline">¶</a></h2>
<p>We suggest extending the Go language to add optional type parameters
to types and functions.
Type parameters may be constrained by contracts: they may be used as
ordinary types that only support the operations permitted by the
contracts.
Type inference via a unification algorithm is supported to permit
omitting type arguments from function calls in many cases.
Depending on a detail, the design can be fully backward compatible
with Go 1.</p>
</div>
<div class="section" id="background">
<h2>Background<a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h2>
<p>This version of the design draft is similar to the one presented on
August 27, 2018, except that the syntax of contracts is completely
different.</p>
<p>There have been many <a class="reference external" href="https://github.com/golang/go/wiki/ExperienceReports#generics">requests to add additional support for generic
programming</a>
in Go.
There has been extensive discussion on
<a class="reference external" href="https://golang.org/issue/15292">the issue tracker</a> and on
<a class="reference external" href="https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/view">a living document</a>.</p>
<p>There have been several proposals for adding type parameters, which
can be found through the links above.
Many of the ideas presented here have appeared before.
The main new features described here are the syntax and the careful
examination of contracts.</p>
<p>This design draft suggests extending the Go language to add a form of
parametric polymorphism, where the type parameters are bounded not by
a subtyping relationship but by explicitly defined structural
constraints.
Among other languages that support parameteric polymorphism this
design is perhaps most similar to Ada, although the syntax is
completely different.</p>
<p>This design does not support template metaprogramming or any other
form of compile time programming.</p>
<p>As the term <em>generic</em> is widely used in the Go community, we will
use it below as a shorthand to mean a function or type that takes type
parameters.
Don’t confuse the term generic as used in this design with the same
term in other languages like C++, C#, Java, or Rust; they have
similarities but are not the same.</p>
</div>
<div class="section" id="design">
<h2>Design<a class="headerlink" href="#design" title="Permalink to this headline">¶</a></h2>
<p>We will describe the complete design in stages based on examples.</p>
<div class="section" id="type-parameters">
<h3>Type parameters<a class="headerlink" href="#type-parameters" title="Permalink to this headline">¶</a></h3>
<p>Generic code is code that is written using types that will be
specified later.
Each unspecified type is called a <em>type parameter</em>.
When running the generic code, the type parameter will be set to a
<em>type argument</em>.</p>
<p>Here is a function that prints out each element of a slice, where the
element type of the slice, here called <code class="docutils literal notranslate"><span class="pre">T</span></code>, is unknown.
This is a trivial example of the kind of function we want to permit in
order to support generic programming.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Print prints the elements of a slice.</span>
<span class="c1">// It should be possible to call this with any slice value.</span>
<span class="kd">func</span> <span class="nx">Print</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Just an example, not the suggested syntax.</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With this approach, the first decision to make is: how should the type
parameter <code class="docutils literal notranslate"><span class="pre">T</span></code> be declared?
In a language like Go, we expect every identifier to be declared in
some way.</p>
<p>Here we make a design decision: type parameters are similar to
ordinary non-type function parameters, and as such should be listed
along with other parameters.
However, type parameters are not the same as non-type parameters, so
although they appear in the list of parameters we want to distinguish
them.
That leads to our next design decision: we define an additional,
optional, parameter list, describing type parameters.
This parameter list appears before the regular parameters.
It starts with the keyword <code class="docutils literal notranslate"><span class="pre">type</span></code>, and lists type parameters.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Print</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// same as above</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This says that within the function <code class="docutils literal notranslate"><span class="pre">Print</span></code> the identifier <code class="docutils literal notranslate"><span class="pre">T</span></code> is a
type parameter, a type that is currently unknown but that will be
known when the function is called.</p>
<p>Since <code class="docutils literal notranslate"><span class="pre">Print</span></code> has a type parameter, when we call it we must pass a
type argument.
Type arguments are passed much like type parameters are declared: as a
separate list of arguments.
At the call site, the <code class="docutils literal notranslate"><span class="pre">type</span></code> keyword is not required.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span>	<span class="nx">Print</span><span class="p">(</span><span class="kt">int</span><span class="p">)([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">})</span>
</pre></div>
</div>
</div>
<div class="section" id="type-contracts">
<h3>Type contracts<a class="headerlink" href="#type-contracts" title="Permalink to this headline">¶</a></h3>
<p>Let’s make our example slightly more complicated.
Let’s turn it into a function that converts a slice of any type into a
<code class="docutils literal notranslate"><span class="pre">[]string</span></code> by calling a <code class="docutils literal notranslate"><span class="pre">String</span></code> method on each element.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// This function is INVALID.</span>
<span class="kd">func</span> <span class="nx">Stringify</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">(</span><span class="nx">ret</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">ret</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ret</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span> <span class="c1">// INVALID</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This might seem OK at first glance, but in this example, <code class="docutils literal notranslate"><span class="pre">v</span></code> has type
<code class="docutils literal notranslate"><span class="pre">T</span></code>, and we don’t know anything about <code class="docutils literal notranslate"><span class="pre">T</span></code>.
In particular, we don’t know that <code class="docutils literal notranslate"><span class="pre">T</span></code> has a <code class="docutils literal notranslate"><span class="pre">String</span></code> method.
So the call to <code class="docutils literal notranslate"><span class="pre">v.String()</span></code> is invalid.</p>
<p>Naturally, the same issue arises in other languages that support
generic programming.
In C++, for example, a generic function (in C++ terms, a function
template) can call any method on a value of generic type.
That is, in the C++ approach, calling <code class="docutils literal notranslate"><span class="pre">v.String()</span></code> is fine.
If the function is called with a type that does not have a <code class="docutils literal notranslate"><span class="pre">String</span></code>
method, the error is reported at the point of the function call.
These errors can be lengthy, as there may be several layers of generic
function calls before the error occurs, all of which must be reported
for complete clarity.</p>
<p>The C++ approach would be a poor choice for Go.
One reason is the style of the language.
In Go we don’t refer to names, such as, in this case, <code class="docutils literal notranslate"><span class="pre">String</span></code>, and
hope that they exist.
Go resolves all names to their declarations when they are seen.</p>
<p>Another reason is that Go is designed to support programming at
scale.
We must consider the case in which the generic function definition
(<code class="docutils literal notranslate"><span class="pre">Stringify</span></code>, above) and the call to the generic function (not shown,
but perhaps in some other package) are far apart.
In general, all generic code implies a contract that type arguments
need to implement.
In this case, the contract is pretty obvious: the type has to have a
<code class="docutils literal notranslate"><span class="pre">String()</span> <span class="pre">string</span></code> method.
In other cases it may be much less obvious.
We don’t want to derive the contract from whatever <code class="docutils literal notranslate"><span class="pre">Stringify</span></code> happens
to do.
If we did, a minor change to <code class="docutils literal notranslate"><span class="pre">Stringify</span></code> might change the contract.
That would mean that a minor change could cause code far away, that
calls the function, to unexpectedly break.
It’s fine for <code class="docutils literal notranslate"><span class="pre">Stringify</span></code> to deliberately change its contract, and
force users to change.
What we want to avoid is <code class="docutils literal notranslate"><span class="pre">Stringify</span></code> changing its contract
accidentally.</p>
<p>This is an important rule that we believe should apply to any attempt
to define generic programming in Go: there should be an explicit
contract between the generic code and calling code.</p>
</div>
<div class="section" id="contract-introduction">
<h3>Contract introduction<a class="headerlink" href="#contract-introduction" title="Permalink to this headline">¶</a></h3>
<p>In this design, a contract describes the requirements of a set of
types.
We’ll discuss contracts further later, but for now we’ll just say that
one of the things that a contract can do is specify that a type
argument must implement a particular method.</p>
<p>For the <code class="docutils literal notranslate"><span class="pre">Stringify</span></code> example, we need to write a contract that says
that the single type parameter has a <code class="docutils literal notranslate"><span class="pre">String</span></code> method that takes no
arguments and returns a value of type <code class="docutils literal notranslate"><span class="pre">string</span></code>.
We write that like this:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="nx">contract</span> <span class="nx">stringer</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">T</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A contract is introduced with a new keyword <code class="docutils literal notranslate"><span class="pre">contract</span></code>, followed by a
name and a list of identifiers.
The identifiers name the types that the contract will specify.
Specifying a required method looks like defining a method in an
interface type, except that the receiver type must be explicitly
provided.</p>
</div>
<div class="section" id="using-a-contract-to-verify-type-arguments">
<h3>Using a contract to verify type arguments<a class="headerlink" href="#using-a-contract-to-verify-type-arguments" title="Permalink to this headline">¶</a></h3>
<p>A contract serves two purposes.
First, contracts are used to validate a set of type arguments.
As shown above, when a function with type parameters is called, it
will be called with a set of type arguments.
When the compiler sees the function call, it will use the contract to
validate the type arguments.
If the type arguments don’t satisfy the requirements specified by the
contract, the compiler will report a type error: the call is using
types that the function’s contract does not permit.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">stringer</span></code> contract seen earlier requires that the type argument
used for <code class="docutils literal notranslate"><span class="pre">T</span></code> has a <code class="docutils literal notranslate"><span class="pre">String</span></code> method that takes no arguments and
returns a value of type <code class="docutils literal notranslate"><span class="pre">string</span></code>.</p>
</div>
<div class="section" id="the-party-of-the-second-part">
<h3>The party of the second part<a class="headerlink" href="#the-party-of-the-second-part" title="Permalink to this headline">¶</a></h3>
<p>A contract is not used only at the call site.
It is also used to describe what the function using the contract, the
function with type parameters, is permitted to do with those type
parameters.</p>
<p>In a function with type parameters that does not use a contract, such
as the <code class="docutils literal notranslate"><span class="pre">Print</span></code> example shown earlier, the function is only permitted
to use those type parameters in ways that any type may be used in Go.
That is, operations like:</p>
<ul class="simple">
<li><p>declare variables of those types</p></li>
<li><p>assign other values of the same type to those variables</p></li>
<li><p>pass those variables to functions or return them from functions</p></li>
<li><p>take the address of those variables</p></li>
<li><p>define and use other types that use those types, such as a slice of
that type</p></li>
</ul>
<p>If the function wants to take any more specific action with the type
parameter, or a value of the type parameter, the contract must
explicitly support that action.
In the <code class="docutils literal notranslate"><span class="pre">stringer</span></code> example seen earlier, the contract provides the
ability to call a method <code class="docutils literal notranslate"><span class="pre">String</span></code> on a value of the type parameter.
That is, naturally, exactly the operation that the <code class="docutils literal notranslate"><span class="pre">Stringify</span></code>
function needs.</p>
</div>
<div class="section" id="using-a-contract">
<h3>Using a contract<a class="headerlink" href="#using-a-contract" title="Permalink to this headline">¶</a></h3>
<p>We’ve seen how the <code class="docutils literal notranslate"><span class="pre">stringer</span></code> contract can be used to verify that a
type argument is suitable for the <code class="docutils literal notranslate"><span class="pre">Stringify</span></code> function, and we’ve seen
how the contract permits the <code class="docutils literal notranslate"><span class="pre">Stringify</span></code> function to call the <code class="docutils literal notranslate"><span class="pre">String</span></code>
method that it needs.
The final step is showing how the <code class="docutils literal notranslate"><span class="pre">Stringify</span></code> function uses the
<code class="docutils literal notranslate"><span class="pre">stringer</span></code> contract.
This is done by naming the contract at the end of the list of type
parameters.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Stringify</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">stringer</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">(</span><span class="nx">ret</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">ret</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ret</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span> <span class="c1">// now valid</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The list of type parameters (in this case, a list with the single
element <code class="docutils literal notranslate"><span class="pre">T</span></code>) is followed by an optional contract name.
When just the contract name is listed, as above, the contract must
have the same number of parameters as the function has type
parameters; when validating the contract, the type parameters are
passed to the contract in the order in which they appear in the
function signature.
Later we’ll discuss passing explicit type parameters to the contract.</p>
</div>
<div class="section" id="multiple-type-parameters">
<h3>Multiple type parameters<a class="headerlink" href="#multiple-type-parameters" title="Permalink to this headline">¶</a></h3>
<p>Although the examples we’ve seen so far use only a single type
parameter, functions may have multiple type parameters.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Print2</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">)(</span><span class="nx">s1</span> <span class="p">[]</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">s2</span> <span class="p">[]</span><span class="nx">T2</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>Compare this to</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Print2Same</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T1</span><span class="p">)(</span><span class="nx">s1</span> <span class="p">[]</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">s2</span> <span class="p">[]</span><span class="nx">T1</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>In <code class="docutils literal notranslate"><span class="pre">Print2</span></code> <code class="docutils literal notranslate"><span class="pre">s1</span></code> and <code class="docutils literal notranslate"><span class="pre">s2</span></code> may be slices of different types.
In <code class="docutils literal notranslate"><span class="pre">Print2Same</span></code> <code class="docutils literal notranslate"><span class="pre">s1</span></code> and <code class="docutils literal notranslate"><span class="pre">s2</span></code> must be slices of the same element
type.</p>
<p>Although functions may have multiple type parameters, they may only
have a single contract.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="nx">contract</span> <span class="nx">viaStrings</span><span class="p">(</span><span class="nx">To</span><span class="p">,</span> <span class="nx">From</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">To</span>   <span class="nx">Set</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>
	<span class="nx">From</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">SetViaStrings</span><span class="p">(</span><span class="kd">type</span> <span class="nx">To</span><span class="p">,</span> <span class="nx">From</span> <span class="nx">viaStrings</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">From</span><span class="p">)</span> <span class="p">[]</span><span class="nx">To</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">To</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Set</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="parameterized-types">
<h3>Parameterized types<a class="headerlink" href="#parameterized-types" title="Permalink to this headline">¶</a></h3>
<p>We want more than just generic functions: we also want generic types.
We suggest that types be extended to take type parameters.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Vector</span><span class="p">(</span><span class="kd">type</span> <span class="nx">Element</span><span class="p">)</span> <span class="p">[]</span><span class="nx">Element</span>
</pre></div>
</div>
<p>A type’s parameters are just like a function’s type parameters.</p>
<p>Within the type definition, the type parameters may be used like any
other type.</p>
<p>To use a parameterized type, you must supply type arguments.
This looks like a function call, except that the function in this case
is actually a type.
This is called <em>instantiation</em>.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">v</span> <span class="nx">Vector</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
</pre></div>
</div>
<p>Parameterized types can have methods.
The receiver type of a method must list the type parameters.
They are listed without the <code class="docutils literal notranslate"><span class="pre">type</span></code> keyword or any contract.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Vector</span><span class="p">(</span><span class="nx">Element</span><span class="p">))</span> <span class="nx">Push</span><span class="p">(</span><span class="nx">x</span> <span class="nx">Element</span><span class="p">)</span> <span class="p">{</span> <span class="o">*</span><span class="nx">v</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">v</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>A parameterized type can refer to itself in cases where a type can
ordinarily refer to itself, but when it does so the type arguments
must be the type parameters, listed in the same order.
This restriction prevents infinite recursion of type instantiation.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// This is OK.</span>
<span class="kd">type</span> <span class="nx">List</span><span class="p">(</span><span class="kd">type</span> <span class="nx">Element</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">next</span> <span class="o">*</span><span class="nx">List</span><span class="p">(</span><span class="nx">Element</span><span class="p">)</span>
	<span class="nx">val</span>  <span class="nx">Element</span>
<span class="p">}</span>

<span class="c1">// This type is INVALID.</span>
<span class="kd">type</span> <span class="nx">P</span><span class="p">(</span><span class="kd">type</span> <span class="nx">Element1</span><span class="p">,</span> <span class="nx">Element2</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">F</span> <span class="o">*</span><span class="nx">P</span><span class="p">(</span><span class="nx">Element2</span><span class="p">,</span> <span class="nx">Element1</span><span class="p">)</span> <span class="c1">// INVALID; must be (Element1, Element2)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>(Note: with more understanding of how people want to write code, it
may be possible to relax this rule to permit some cases that use
different type arguments.)</p>
<p>The type parameter of a parameterized type may have contracts.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">StringableVector</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">stringer</span><span class="p">)</span> <span class="p">[]</span><span class="nx">T</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">StringableVector</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">sb</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Builder</span>
	<span class="nx">sb</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="s">&quot;[&quot;</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">sb</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">sb</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span>
	<span class="p">}</span>
	<span class="nx">sb</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="s">&quot;]&quot;</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">sb</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When a parameterized type is a struct, and the type parameter is
embedded as a field in the struct, the name of the field is the name
of the type parameter, not the name of the type argument.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Lockable</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">T</span>
	<span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Lockable</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Get</span><span class="p">()</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">l</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">l</span><span class="p">.</span><span class="nx">T</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="parameterized-type-aliases">
<h3>Parameterized type aliases<a class="headerlink" href="#parameterized-type-aliases" title="Permalink to this headline">¶</a></h3>
<p>Type aliases may not have parameters.
This restriction exists because it is unclear how to handle a type
alias with type parameters that have a contract.</p>
<p>Type aliases may refer to instantiated types.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">VectorInt</span> <span class="p">=</span> <span class="nx">Vector</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
</pre></div>
</div>
<p>If a type alias refers to a parameterized type, it must provide type
arguments.</p>
</div>
<div class="section" id="methods-may-not-take-additional-type-arguments">
<h3>Methods may not take additional type arguments<a class="headerlink" href="#methods-may-not-take-additional-type-arguments" title="Permalink to this headline">¶</a></h3>
<p>Although methods of a parameterized type may use the type’s
parameters, methods may not themselves have additional type
parameters.
Where it would be useful to add type arguments to a method, people
will have to write a suitably parameterized top-level function.</p>
<p>This restriction avoids having to specify the details of exactly when
a method with type arguments implements an interface.
(This is a feature that can perhaps be added later if it proves
necessary.)</p>
</div>
<div class="section" id="contract-embedding">
<h3>Contract embedding<a class="headerlink" href="#contract-embedding" title="Permalink to this headline">¶</a></h3>
<p>A contract may embed another contract, by listing it in the
contract body with type arguments.
This will look a bit like a method definition in the contract body,
but it will be different because there will be no receiver type.
It is handled as if the embedded contract’s body were placed into the
calling contract, with the embedded contract’s type parameters
replaced by the embedded type arguments.</p>
<p>This contract embeds the contract <code class="docutils literal notranslate"><span class="pre">stringer</span></code> defined earlier.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="nx">contract</span> <span class="nx">PrintStringer</span><span class="p">(</span><span class="nx">X</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">stringer</span><span class="p">(</span><span class="nx">X</span><span class="p">)</span>
	<span class="nx">X</span> <span class="nx">Print</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is equivalent to</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="nx">contract</span> <span class="nx">PrintStringer</span><span class="p">(</span><span class="nx">X</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">X</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>
	<span class="nx">X</span> <span class="nx">Print</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="using-types-that-refer-to-themselves-in-contracts">
<h3>Using types that refer to themselves in contracts<a class="headerlink" href="#using-types-that-refer-to-themselves-in-contracts" title="Permalink to this headline">¶</a></h3>
<p>Although this is implied by what has already been discussed, it’s
worth pointing out explicitly that a contract may require a method to
have an argument whose type is the same as the method’s receiver
type.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">compare</span>

<span class="c1">// The equal contract describes types that have an Equal method with</span>
<span class="c1">// an argument of the same type as the receiver type.</span>
<span class="nx">contract</span> <span class="nx">equal</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">T</span> <span class="nx">Equal</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="c1">// Index returns the index of e in s, or -1.</span>
<span class="kd">func</span> <span class="nx">Index</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">equal</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">e</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="c1">// Both e and v are type T, so it&#39;s OK to call e.Equal(v).</span>
		<span class="k">if</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">i</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This function can be used with any type that has an <code class="docutils literal notranslate"><span class="pre">Equal</span></code> method
whose single parameter type is the same as the receiver type.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="s">&quot;compare&quot;</span>

<span class="kd">type</span> <span class="nx">EqualInt</span> <span class="kt">int</span>

<span class="c1">// The Equal method lets EqualInt satisfy the compare.equal contract.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="nx">EqualInt</span><span class="p">)</span> <span class="nx">Equal</span><span class="p">(</span><span class="nx">b</span> <span class="nx">EqualInt</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">a</span> <span class="o">==</span> <span class="nx">b</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nx">Index</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">EqualInt</span><span class="p">,</span> <span class="nx">e</span> <span class="nx">EqualInt</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">compare</span><span class="p">.</span><span class="nx">Index</span><span class="p">(</span><span class="nx">EqualInt</span><span class="p">)(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example, when we pass <code class="docutils literal notranslate"><span class="pre">EqualInt</span></code> to <code class="docutils literal notranslate"><span class="pre">compare.Index</span></code>, we
check whether <code class="docutils literal notranslate"><span class="pre">EqualInt</span></code> satisfies the contract <code class="docutils literal notranslate"><span class="pre">compare.equal</span></code>.
We replace <code class="docutils literal notranslate"><span class="pre">T</span></code> with <code class="docutils literal notranslate"><span class="pre">EqualInt</span></code> in the declaration of the <code class="docutils literal notranslate"><span class="pre">Equal</span></code>
method in the <code class="docutils literal notranslate"><span class="pre">equal</span></code> contract, and see whether <code class="docutils literal notranslate"><span class="pre">EqualInt</span></code> has a
matching method.
<code class="docutils literal notranslate"><span class="pre">EqualInt</span></code> has a method <code class="docutils literal notranslate"><span class="pre">Equal</span></code> that accepts a parameter of type
<code class="docutils literal notranslate"><span class="pre">EqualInt</span></code>, so all is well, and the compilation succeeds.</p>
</div>
<div class="section" id="mutually-referencing-type-parameters">
<h3>Mutually referencing type parameters<a class="headerlink" href="#mutually-referencing-type-parameters" title="Permalink to this headline">¶</a></h3>
<p>Within a contract, methods may refer to any of the contract’s type
parameters.</p>
<p>For example, consider a generic graph package that contains generic
algorithms that work with graphs.
The algorithms use two types, <code class="docutils literal notranslate"><span class="pre">Node</span></code> and <code class="docutils literal notranslate"><span class="pre">Edge</span></code>.
<code class="docutils literal notranslate"><span class="pre">Node</span></code> is expected to have a method <code class="docutils literal notranslate"><span class="pre">Edges()</span> <span class="pre">[]Edge</span></code>.
<code class="docutils literal notranslate"><span class="pre">Edge</span></code> is expected to have a method <code class="docutils literal notranslate"><span class="pre">Nodes()</span> <span class="pre">(Node,</span> <span class="pre">Node)</span></code>.
A graph can be represented as a <code class="docutils literal notranslate"><span class="pre">[]Node</span></code>.</p>
<p>This simple representation is enough to implement graph algorithms
like finding the shortest path.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">graph</span>

<span class="nx">contract</span> <span class="nx">G</span><span class="p">(</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">Edge</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">Node</span> <span class="nx">Edges</span><span class="p">()</span> <span class="p">[]</span><span class="nx">Edge</span>
	<span class="nx">Edge</span> <span class="nx">Nodes</span><span class="p">()</span> <span class="p">(</span><span class="nx">from</span> <span class="nx">Node</span><span class="p">,</span> <span class="nx">to</span> <span class="nx">Node</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Graph</span><span class="p">(</span><span class="kd">type</span> <span class="nx">Node</span><span class="p">,</span> <span class="nx">Edge</span> <span class="nx">G</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">New</span><span class="p">(</span><span class="kd">type</span> <span class="nx">Node</span><span class="p">,</span> <span class="nx">Edge</span> <span class="nx">G</span><span class="p">)(</span><span class="nx">nodes</span> <span class="p">[]</span><span class="nx">Node</span><span class="p">)</span> <span class="o">*</span><span class="nx">Graph</span><span class="p">(</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">Edge</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">Graph</span><span class="p">(</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">Edge</span><span class="p">))</span> <span class="nx">ShortestPath</span><span class="p">(</span><span class="nx">from</span><span class="p">,</span> <span class="nx">to</span> <span class="nx">Node</span><span class="p">)</span> <span class="p">[]</span><span class="nx">Edge</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>While at first glance this may look like a typical use of interface
types, <code class="docutils literal notranslate"><span class="pre">Node</span></code> and <code class="docutils literal notranslate"><span class="pre">Edge</span></code> are non-interface types with specific
methods.
In order to use <code class="docutils literal notranslate"><span class="pre">graph.Graph</span></code>, the type arguments used for <code class="docutils literal notranslate"><span class="pre">Node</span></code> and
<code class="docutils literal notranslate"><span class="pre">Edge</span></code> have to define methods that follow a certain pattern, but they
don’t have to actually use interface types to do so.</p>
<p>For example, consider these type definitions in some other package:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Vertex</span> <span class="kd">struct</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Vertex</span><span class="p">)</span> <span class="nx">Edges</span><span class="p">()</span> <span class="p">[]</span><span class="o">*</span><span class="nx">FromTo</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="kd">type</span> <span class="nx">FromTo</span> <span class="kd">struct</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">ft</span> <span class="o">*</span><span class="nx">FromTo</span><span class="p">)</span> <span class="nx">Nodes</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">Vertex</span><span class="p">,</span> <span class="o">*</span><span class="nx">Vertex</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>There are no interface types here, but we can instantiate
<code class="docutils literal notranslate"><span class="pre">graph.Graph</span></code> using the type arguments <code class="docutils literal notranslate"><span class="pre">*Vertex</span></code> and <code class="docutils literal notranslate"><span class="pre">*FromTo</span></code>:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">g</span> <span class="p">=</span> <span class="nx">graph</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="o">*</span><span class="nx">Vertex</span><span class="p">,</span> <span class="o">*</span><span class="nx">FromTo</span><span class="p">)([]</span><span class="o">*</span><span class="nx">Vertex</span><span class="p">{</span> <span class="o">...</span> <span class="p">})</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">*Vertex</span></code> and <code class="docutils literal notranslate"><span class="pre">*FromTo</span></code> are not interface types, but when used
together they define methods that implement the contract <code class="docutils literal notranslate"><span class="pre">graph.G</span></code>.
Note that we couldn’t use plain <code class="docutils literal notranslate"><span class="pre">Vertex</span></code> or <code class="docutils literal notranslate"><span class="pre">FromTo</span></code>, since the
required methods are pointer methods, not value methods.</p>
<p>Although <code class="docutils literal notranslate"><span class="pre">Node</span></code> and <code class="docutils literal notranslate"><span class="pre">Edge</span></code> do not have to be instantiated with
interface types, it is also OK to use interface types if you like.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">NodeInterface</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nx">Edges</span><span class="p">()</span> <span class="p">[]</span><span class="nx">EdgeInterface</span> <span class="p">}</span>
<span class="kd">type</span> <span class="nx">EdgeInterface</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nx">Nodes</span><span class="p">()</span> <span class="p">(</span><span class="nx">NodeInterface</span><span class="p">,</span> <span class="nx">NodeInterface</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>We could instantiate <code class="docutils literal notranslate"><span class="pre">graph.Graph</span></code> with the types <code class="docutils literal notranslate"><span class="pre">NodeInterface</span></code> and
<code class="docutils literal notranslate"><span class="pre">EdgeInterface</span></code>, since they implement the <code class="docutils literal notranslate"><span class="pre">graph.G</span></code> contract.
There isn’t much reason to instantiate a type this way, but it is
permitted.</p>
<p>This ability for type parameters to refer to other type parameters
illustrates an important point: it should be a requirement for any
attempt to add generics to Go that it be possible to instantiate
generic code with multiple type arguments that refer to each other in
ways that the compiler can check.</p>
<p>As it is a common observation that contracts share some
characteristics of interface types, it’s worth stressing that this
capability is one that contracts provide but interface types do not.</p>
</div>
<div class="section" id="passing-parameters-to-a-contract">
<h3>Passing parameters to a contract<a class="headerlink" href="#passing-parameters-to-a-contract" title="Permalink to this headline">¶</a></h3>
<p>As mentioned earlier, by default the type parameters are passed to the
contract in the order in which they appear in the function signature.
It is also possible to explicitly pass type parameters to a contract
as though they were arguments.
This is useful if the contract and the generic function take type
parameters in a different order, or if only some parameters need a
contract.</p>
<p>In this example the type parameter <code class="docutils literal notranslate"><span class="pre">E</span></code> can be any type, but the type
parameter <code class="docutils literal notranslate"><span class="pre">M</span></code> must implement the <code class="docutils literal notranslate"><span class="pre">String</span></code> method.
The function passes just <code class="docutils literal notranslate"><span class="pre">M</span></code> to the <code class="docutils literal notranslate"><span class="pre">stringer</span></code> contract, leaving <code class="docutils literal notranslate"><span class="pre">E</span></code>
as though it had no constraints.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">MapAndPrint</span><span class="p">(</span><span class="kd">type</span> <span class="nx">E</span><span class="p">,</span> <span class="nx">M</span> <span class="nx">stringer</span><span class="p">(</span><span class="nx">M</span><span class="p">))(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">E</span><span class="p">,</span> <span class="nx">f</span><span class="p">(</span><span class="nx">E</span><span class="p">)</span> <span class="nx">M</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">v</span><span class="p">).</span><span class="nx">String</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="contract-syntactic-details">
<h3>Contract syntactic details<a class="headerlink" href="#contract-syntactic-details" title="Permalink to this headline">¶</a></h3>
<p>Contracts may only appear at the top level of a package.</p>
<p>While contracts could be defined to work within the body of a
function, it’s hard to think of realistic examples in which they would
be useful.
We see this as similar to the way that methods can not be defined
within the body of a function.
A minor point is that only permitting contracts at the top level
permits the design to be Go 1 compatible.</p>
<p>There are a few ways to handle the syntax:</p>
<ul class="simple">
<li><p>We could make <code class="docutils literal notranslate"><span class="pre">contract</span></code> be a keyword only at the start of a
top-level declaration, and otherwise be a normal identifier.</p></li>
<li><p>We could declare that if you use <code class="docutils literal notranslate"><span class="pre">contract</span></code> at the start of a
top-level declaration, then it becomes a keyword for the entire
package.</p></li>
<li><p>We could make <code class="docutils literal notranslate"><span class="pre">contract</span></code> always be a keyword, albeit one that can
only appear in one place, in which case this design is not Go 1
compatible.</p></li>
</ul>
<p>Like other top level declarations, a contract is exported if its name
starts with an uppercase letter.
If exported it may be used by functions, types, or contracts in other
packages.</p>
</div>
<div class="section" id="values-of-type-parameters-are-not-boxed">
<h3>Values of type parameters are not boxed<a class="headerlink" href="#values-of-type-parameters-are-not-boxed" title="Permalink to this headline">¶</a></h3>
<p>In the current implementations of Go, interface values always hold
pointers.
Putting a non-pointer value in an interface variable causes the value
to be <em>boxed</em>.
That means that the actual value is stored somewhere else, on the heap
or stack, and the interface value holds a pointer to that location.</p>
<p>In this design, values of generic types are not boxed.
For example, let’s consider a function that works for any type <code class="docutils literal notranslate"><span class="pre">T</span></code>
with a <code class="docutils literal notranslate"><span class="pre">Set(string)</span></code> method that initializes the value based on a
string, and uses it to convert a slice of <code class="docutils literal notranslate"><span class="pre">string</span></code> to a slice of <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">from</span>

<span class="nx">contract</span> <span class="nx">setter</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">T</span> <span class="nx">Set</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Strings</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">setter</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ret</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Set</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ret</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now let’s see some code in a different package.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Settable</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Settable</span><span class="p">)</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Atoi</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">F</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// The type of nums is []Settable.</span>
	<span class="nx">nums</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">from</span><span class="p">.</span><span class="nx">Strings</span><span class="p">(</span><span class="nx">Settable</span><span class="p">)([]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
	<span class="c1">// Settable can be converted directly to int.</span>
	<span class="c1">// This will set first to 1.</span>
	<span class="nx">first</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When we call <code class="docutils literal notranslate"><span class="pre">from.Strings</span></code> with the type <code class="docutils literal notranslate"><span class="pre">Settable</span></code> we get back a
<code class="docutils literal notranslate"><span class="pre">[]Settable</span></code> (and an error).
The values in that slice will be <code class="docutils literal notranslate"><span class="pre">Settable</span></code> values, which is to say,
they will be integers.
They will not be boxed as pointers, even though they were created and
set by a generic function.</p>
<p>Similarly, when a parameterized type is instantiated it will have the
expected types as components.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">pair</span>

<span class="kd">type</span> <span class="nx">Pair</span><span class="p">(</span><span class="kd">type</span> <span class="nx">carT</span><span class="p">,</span> <span class="nx">cdrT</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">f1</span> <span class="nx">carT</span>
	<span class="nx">f2</span> <span class="nx">cdrT</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When this is instantiated, the fields will not be boxed, and no
unexpected memory allocations will occur.
The type <code class="docutils literal notranslate"><span class="pre">pair.Pair(int,</span> <span class="pre">string)</span></code> is convertible to <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">{</span> <span class="pre">f1</span> <span class="pre">int;</span> <span class="pre">f2</span> <span class="pre">string</span> <span class="pre">}</span></code>.</p>
</div>
<div class="section" id="function-argument-type-inference">
<h3>Function argument type inference<a class="headerlink" href="#function-argument-type-inference" title="Permalink to this headline">¶</a></h3>
<p>In many cases, when calling a function with type parameters, we can
use type inference to avoid having to explicitly write out the type
arguments.</p>
<p>Go back to the example of a call to our simple <code class="docutils literal notranslate"><span class="pre">Print</span></code> function:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span>	<span class="nx">Print</span><span class="p">(</span><span class="kt">int</span><span class="p">)([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">})</span>
</pre></div>
</div>
<p>The type argument <code class="docutils literal notranslate"><span class="pre">int</span></code> in the function call can be inferred from the
type of the non-type argument.</p>
<p>This can only be done when all the function’s type parameters are used
for the types of the function’s (non-type) input parameters.
If there are some type parameters that are used only for the
function’s result parameter types, or only in the body of the
function, then it is not possible to infer the type arguments for the
function, since there is no value from which to infer the types.
For example, when calling <code class="docutils literal notranslate"><span class="pre">from.Strings</span></code> as defined earlier, the type
parameters cannot be inferred because the function’s type parameter
<code class="docutils literal notranslate"><span class="pre">T</span></code> is not used for an input parameter, only for a result.</p>
<p>When the function’s type arguments can be inferred, the language uses
type unification.
On the caller side we have the list of types of the actual (non-type)
arguments, which for the <code class="docutils literal notranslate"><span class="pre">Print</span></code> example here is simply <code class="docutils literal notranslate"><span class="pre">[]int</span></code>.
On the function side is the list of the types of the function’s
non-type parameters, which here is <code class="docutils literal notranslate"><span class="pre">[]T</span></code>.
In the lists, we discard respective arguments for which the function
side does not use a type parameter.
We must then unify the remaining argument types.</p>
<p>Type unification is a two pass algorithm.
In the first pass, we ignore untyped constants on the caller side and
their corresponding types in the function definition.</p>
<p>We compare corresponding types in the lists.
Their structure must be identical, except that type parameters on the
function side match the type that appears on the caller side at the
point where the type parameter occurs.
If the same type parameter appears more than once on the function
side, it will match multiple argument types on the caller side.
Those caller types must be identical, or type unification fails, and
we report an error.</p>
<p>After the first pass, we check any untyped constants on the caller
side.
If there are no untyped constants, or if the type parameters in the
corresponding function types have matched other input types, then
type unification is complete.</p>
<p>Otherwise, for the second pass, for any untyped constants whose
corresponding function types are not yet set, we determine the default
type of the untyped constant in <a class="reference external" href="https://golang.org/ref/spec#Constants">the usual
way</a>.
Then we run the type unification algorithm again, this time with no
untyped constants.</p>
<p>In this example</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span>	<span class="nx">s1</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
	<span class="nx">Print</span><span class="p">(</span><span class="nx">s1</span><span class="p">)</span>
</pre></div>
</div>
<p>we compare <code class="docutils literal notranslate"><span class="pre">[]int</span></code> with <code class="docutils literal notranslate"><span class="pre">[]T</span></code>, match <code class="docutils literal notranslate"><span class="pre">T</span></code> with <code class="docutils literal notranslate"><span class="pre">int</span></code>, and we are done.
The single type parameter <code class="docutils literal notranslate"><span class="pre">T</span></code> is <code class="docutils literal notranslate"><span class="pre">int</span></code>, so we infer that the call
to <code class="docutils literal notranslate"><span class="pre">Print</span></code> is really a call to <code class="docutils literal notranslate"><span class="pre">Print(int)</span></code>.</p>
<p>For a more complex example, consider</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">transform</span>

<span class="kd">func</span> <span class="nx">Slice</span><span class="p">(</span><span class="kd">type</span> <span class="nx">From</span><span class="p">,</span> <span class="nx">To</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">From</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">From</span><span class="p">)</span> <span class="nx">To</span><span class="p">)</span> <span class="p">[]</span><span class="nx">To</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">To</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The two type parameters <code class="docutils literal notranslate"><span class="pre">From</span></code> and <code class="docutils literal notranslate"><span class="pre">To</span></code> are both used for input
parameters, so type inference is possible.
In the call</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span>	<span class="nx">strs</span> <span class="o">:=</span> <span class="nx">transform</span><span class="p">.</span><span class="nx">Slice</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Itoa</span><span class="p">)</span>
</pre></div>
</div>
<p>we unify <code class="docutils literal notranslate"><span class="pre">[]int</span></code> with <code class="docutils literal notranslate"><span class="pre">[]From</span></code>, matching <code class="docutils literal notranslate"><span class="pre">From</span></code> with <code class="docutils literal notranslate"><span class="pre">int</span></code>.
We unify the type of <code class="docutils literal notranslate"><span class="pre">strconv.Itoa</span></code>, which is <code class="docutils literal notranslate"><span class="pre">func(int)</span> <span class="pre">string</span></code>,
with <code class="docutils literal notranslate"><span class="pre">func(From)</span> <span class="pre">To</span></code>, matching <code class="docutils literal notranslate"><span class="pre">From</span></code> with <code class="docutils literal notranslate"><span class="pre">int</span></code> and <code class="docutils literal notranslate"><span class="pre">To</span></code> with
<code class="docutils literal notranslate"><span class="pre">string</span></code>.
<code class="docutils literal notranslate"><span class="pre">From</span></code> is matched twice, both times with <code class="docutils literal notranslate"><span class="pre">int</span></code>.
Unification succeeds, so the call written as <code class="docutils literal notranslate"><span class="pre">transform.Slice</span></code> is a
call of <code class="docutils literal notranslate"><span class="pre">transform.Slice(int,</span> <span class="pre">string)</span></code>.</p>
<p>To see the untyped constant rule in effect, consider</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">pair</span>

<span class="kd">func</span> <span class="nx">New</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)(</span><span class="nx">f1</span><span class="p">,</span> <span class="nx">f2</span> <span class="nx">T</span><span class="p">)</span> <span class="o">*</span><span class="nx">Pair</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>In the call <code class="docutils literal notranslate"><span class="pre">pair.New(1,</span> <span class="pre">2)</span></code> both arguments are untyped constants, so
both are ignored in the first pass.
There is nothing to unify.
We still have two untyped constants after the first pass.
Both are set to their default type, <code class="docutils literal notranslate"><span class="pre">int</span></code>.
The second run of the type unification pass unifies <code class="docutils literal notranslate"><span class="pre">T</span></code> with <code class="docutils literal notranslate"><span class="pre">int</span></code>,
so the final call is <code class="docutils literal notranslate"><span class="pre">pair.New(int)(1,</span> <span class="pre">2)</span></code>.</p>
<p>In the call <code class="docutils literal notranslate"><span class="pre">pair.New(1,</span> <span class="pre">int64(2))</span></code> the first argument is an untyped
constant, so we ignore it in the first pass.
We then unify <code class="docutils literal notranslate"><span class="pre">int64</span></code> with <code class="docutils literal notranslate"><span class="pre">T</span></code>.
At this point the type parameter corresponding to the untyped constant
is fully determined, so the final call is <code class="docutils literal notranslate"><span class="pre">pair.New(int64)(1,</span> <span class="pre">int64(2))</span></code>.</p>
<p>In the call <code class="docutils literal notranslate"><span class="pre">pair.New(1,</span> <span class="pre">2.5)</span></code> both arguments are untyped constants,
so we move on the second pass.
This time we set the first constant to <code class="docutils literal notranslate"><span class="pre">int</span></code> and the second to
<code class="docutils literal notranslate"><span class="pre">float64</span></code>.
We then try to unify <code class="docutils literal notranslate"><span class="pre">T</span></code> with both <code class="docutils literal notranslate"><span class="pre">int</span></code> and <code class="docutils literal notranslate"><span class="pre">float64</span></code>, so
unification fails, and we report a compilation error.</p>
<p>Note that type inference is done without regard to contracts.
First we use type inference to determine the type arguments to use for
the package, and then, if that succeeds, we check whether those type
arguments implement the contract.</p>
<p>Note that after successful type inference, the compiler must still
check that the arguments can be assigned to the parameters, as for any
function call.
This need not be the case when untyped constants are involved.</p>
<p>(Note: Type inference is a convenience feature.
Although we think it is an important feature, it does not add any
functionality to the design, only convenience in using it.
It would be possible to omit it from the initial implementation, and
see whether it seems to be needed.
That said, this feature doesn’t require additional syntax, and is
likely to significantly reduce the stutter of repeated type arguments
in code.)</p>
<p>(Note: We could also consider supporting type inference for
composite literals of parameterized types.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Pair</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">f1</span><span class="p">,</span> <span class="nx">f2</span> <span class="nx">T</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nx">V</span> <span class="p">=</span> <span class="nx">Pair</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span> <span class="c1">// inferred as Pair(int){1, 2}</span>
</pre></div>
</div>
<p>It’s not clear how often this will arise in real code.)</p>
</div>
<div class="section" id="instantiating-a-function">
<h3>Instantiating a function<a class="headerlink" href="#instantiating-a-function" title="Permalink to this headline">¶</a></h3>
<p>Go normally permits you to refer to a function without passing any
arguments, producing a value of function type.
You may not do this with a function that has type parameters; all type
arguments must be known at compile time.
However, you can instantiate the function, by passing type arguments,
without passing any non-type arguments.
This will produce an ordinary function value with no type parameters.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// PrintInts will be type func([]int).</span>
<span class="kd">var</span> <span class="nx">PrintInts</span> <span class="p">=</span> <span class="nx">Print</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="type-assertions-and-switches">
<h3>Type assertions and switches<a class="headerlink" href="#type-assertions-and-switches" title="Permalink to this headline">¶</a></h3>
<p>A useful function with type parameters will support any type argument
that implements the contract.
Sometimes, though, it’s possible to use a more efficient
function implementation for some type arguments.
The language already has mechanisms for code to find out what type it
is working with: type assertions and type switches.
Those are normally only permitted with interface types.
In this design, functions are also permitted to use them with values
whose types are type parameters, or are based on type parameters.</p>
<p>This doesn’t add any functionality, as the function could get the same
information using the reflect package.
It’s merely occasionally convenient, and it may result in more
efficient code.</p>
<p>For example, this code is permitted even if it is called with a type
argument that is not an interface type.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="nx">contract</span> <span class="nx">reader</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">T</span> <span class="nx">Read</span><span class="p">([]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">ReadByte</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">reader</span><span class="p">)(</span><span class="nx">r</span> <span class="nx">T</span><span class="p">)</span> <span class="p">(</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">br</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ByteReader</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">br</span><span class="p">.</span><span class="nx">ReadByte</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">b</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="kt">byte</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Read</span><span class="p">(</span><span class="nx">b</span><span class="p">[:])</span>
	<span class="k">return</span> <span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">err</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="instantiating-types-in-type-literals">
<h3>Instantiating types in type literals<a class="headerlink" href="#instantiating-types-in-type-literals" title="Permalink to this headline">¶</a></h3>
<p>When instantiating a type at the end of a type literal, there is a
parsing ambiguity.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="nx">x1</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">T</span><span class="p">(</span><span class="nx">v1</span><span class="p">)</span>
<span class="nx">x2</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">T</span><span class="p">(</span><span class="nx">v2</span><span class="p">){}</span>
</pre></div>
</div>
<p>In this example, the first case is a type conversion of <code class="docutils literal notranslate"><span class="pre">v1</span></code> to the
type <code class="docutils literal notranslate"><span class="pre">[]T</span></code>.
The second case is a composite literal of type <code class="docutils literal notranslate"><span class="pre">[]T(v2)</span></code>, where <code class="docutils literal notranslate"><span class="pre">T</span></code> is
a parameterized type that we are instantiating with the type argument
<code class="docutils literal notranslate"><span class="pre">v2</span></code>.
The ambiguity is at the point where we see the open parenthesis: at
that point the parser doesn’t know whether it is seeing a type
conversion or something like a composite literal.</p>
<p>To avoid this ambiguity, we require that type instantiations at the
end of a type literal be parenthesized.
To write a type literal that is a slice of a type instantiation, you
must write <code class="docutils literal notranslate"><span class="pre">[](T(v1))</span></code>.
Without those parentheses, <code class="docutils literal notranslate"><span class="pre">[]T(x)</span></code> is parsed as <code class="docutils literal notranslate"><span class="pre">([]T)(x)</span></code>, not as
<code class="docutils literal notranslate"><span class="pre">[](T(x))</span></code>.
This only applies to slice, array, map, chan, and func type literals
ending in a type name.
Of course it is always possible to use a separate type declaration to
give a name to the instantiated type, and to use that.
This is only an issue when the type is instantiated in place.</p>
</div>
<div class="section" id="using-parameterized-types-as-unnamed-function-parameter-types">
<h3>Using parameterized types as unnamed function parameter types<a class="headerlink" href="#using-parameterized-types-as-unnamed-function-parameter-types" title="Permalink to this headline">¶</a></h3>
<p>When parsing a parameterized type as an unnamed function parameter
type, there is a parsing ambiguity.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">x</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span>
</pre></div>
</div>
<p>In this example we don’t know whether the function has a single
unnamed parameter of the parameterized type <code class="docutils literal notranslate"><span class="pre">x(T)</span></code>, or whether this is
a named parameter <code class="docutils literal notranslate"><span class="pre">x</span></code> of the type <code class="docutils literal notranslate"><span class="pre">(T)</span></code> (written with parentheses).</p>
<p>For backward compatibility, we treat this as the latter case: <code class="docutils literal notranslate"><span class="pre">x(T)</span></code>
is a parameter <code class="docutils literal notranslate"><span class="pre">x</span></code> of type <code class="docutils literal notranslate"><span class="pre">(T)</span></code>.
In order to describe a function with a single unnamed parameter of
type <code class="docutils literal notranslate"><span class="pre">x(T)</span></code>, either the parameter must be named, or extra parentheses
must be used.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">f1</span> <span class="kd">func</span><span class="p">(</span><span class="nx">_</span> <span class="nx">x</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span>
<span class="kd">var</span> <span class="nx">f2</span> <span class="kd">func</span><span class="p">((</span><span class="nx">x</span><span class="p">(</span><span class="nx">T</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="section" id="embedding-a-parameterized-type-in-a-struct">
<h3>Embedding a parameterized type in a struct<a class="headerlink" href="#embedding-a-parameterized-type-in-a-struct" title="Permalink to this headline">¶</a></h3>
<p>There is a parsing ambiguity when embedding a parameterized type
in a struct type.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">S1</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">f</span> <span class="nx">T</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">S2</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">S1</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example we don’t know whether struct <code class="docutils literal notranslate"><span class="pre">S2</span></code> has a single
field named <code class="docutils literal notranslate"><span class="pre">S1</span></code> of type <code class="docutils literal notranslate"><span class="pre">(int)</span></code>, or whether we
are trying to embed the instantiated type <code class="docutils literal notranslate"><span class="pre">S1(int)</span></code> into <code class="docutils literal notranslate"><span class="pre">S2</span></code>.</p>
<p>For backward compatibility, we treat this as the former case: <code class="docutils literal notranslate"><span class="pre">S2</span></code> has
a field named <code class="docutils literal notranslate"><span class="pre">S1</span></code>.</p>
<p>In order to embed an instantiated type in a struct, we could require that
extra parentheses be used.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">S2</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="p">(</span><span class="nx">S1</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is currently not supported by the language, so this would suggest
generally extending the language to permit types embedded in structs to
be parenthesized.</p>
</div>
<div class="section" id="embedding-a-parameterized-interface-type-in-an-interface">
<h3>Embedding a parameterized interface type in an interface<a class="headerlink" href="#embedding-a-parameterized-interface-type-in-an-interface" title="Permalink to this headline">¶</a></h3>
<p>There is a parsing ambiguity when embedding a parameterized interface
type in another interface type.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">I1</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">M</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">I2</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">I1</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example we don’t know whether interface <code class="docutils literal notranslate"><span class="pre">I2</span></code> has a single
method named <code class="docutils literal notranslate"><span class="pre">I1</span></code> that takes an argument of type <code class="docutils literal notranslate"><span class="pre">int</span></code>, or whether we
are trying to embed the instantiated type <code class="docutils literal notranslate"><span class="pre">I1(int)</span></code> into <code class="docutils literal notranslate"><span class="pre">I2</span></code>.</p>
<p>For backward compatibility, we treat this as the former case: <code class="docutils literal notranslate"><span class="pre">I2</span></code> has
a method named <code class="docutils literal notranslate"><span class="pre">I1</span></code>.</p>
<p>In order to embed an instantiated interface, we could require that
extra parentheses be used.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">I2</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="p">(</span><span class="nx">I1</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is currently not supported by the language, so this would suggest
generally extending the language to permit embedded interface types to
be parenthesized.</p>
</div>
<div class="section" id="reflection">
<h3>Reflection<a class="headerlink" href="#reflection" title="Permalink to this headline">¶</a></h3>
<p>We do not propose to change the reflect package in any way.
When a type or function is instantiated, all of the type parameters
will become ordinary non-generic types.
The <code class="docutils literal notranslate"><span class="pre">String</span></code> method of a <code class="docutils literal notranslate"><span class="pre">reflect.Type</span></code> value of an instantiated type
will return the name with the type arguments in parentheses.
For example, <code class="docutils literal notranslate"><span class="pre">List(int)</span></code>.</p>
<p>It’s impossible for non-generic code to refer to generic code without
instantiating it, so there is no reflection information for
uninstantiated generic types or functions.</p>
</div>
<div class="section" id="contracts-details">
<h3>Contracts details<a class="headerlink" href="#contracts-details" title="Permalink to this headline">¶</a></h3>
<p>Let’s take a deeper look at contracts.</p>
<p>Operations on values whose type is a type parameter must be permitted
by the type parameter’s contract.
This means that the power of generic functions is tied precisely to
the interpretation of the contract body.
It also means that the language requires a precise definition of the
operations that are permitted by a given contract.</p>
<div class="section" id="methods">
<h4>Methods<a class="headerlink" href="#methods" title="Permalink to this headline">¶</a></h4>
<p>All the contracts we’ve seen so far show only method calls in the
contract body.
If a method call appears in the contract body, that method may be
called on a value in any statement or expression in the function
body.
It will take argument and result types as specified in the contract
body.</p>
</div>
<div class="section" id="pointer-methods">
<h4>Pointer methods<a class="headerlink" href="#pointer-methods" title="Permalink to this headline">¶</a></h4>
<p>In some cases we need to require that a method be a pointer method.
This will happen when a function needs to declare variables whose
type is the type parameter, and also needs to call methods that are
defined for the pointer to the type parameter.</p>
<p>For example:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="nx">contract</span> <span class="nx">setter</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">T</span> <span class="nx">Set</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Init</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">setter</span><span class="p">)(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">r</span> <span class="nx">T</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MyInt</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">MyInt</span><span class="p">)</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">v</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Atoi</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="s">&quot;Init failed&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="nx">MyInt</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// INVALID</span>
<span class="c1">// MyInt does not have a Set method, only *MyInt has one.</span>
<span class="kd">var</span> <span class="nx">Init1</span> <span class="p">=</span> <span class="nx">Init</span><span class="p">(</span><span class="nx">MyInt</span><span class="p">)(</span><span class="s">&quot;1&quot;</span><span class="p">)</span>

<span class="c1">// DOES NOT WORK</span>
<span class="c1">// r in Init is type *MyInt with value nil,</span>
<span class="c1">// so the Set method does a nil pointer deference.</span>
<span class="kd">var</span> <span class="nx">Init2</span> <span class="p">=</span> <span class="nx">Init</span><span class="p">(</span><span class="o">*</span><span class="nx">MyInt</span><span class="p">)(</span><span class="s">&quot;2&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">Init</span></code> cannot be instantiated with the type <code class="docutils literal notranslate"><span class="pre">MyInt</span></code>, as
that type does not have a method <code class="docutils literal notranslate"><span class="pre">Set</span></code>; only <code class="docutils literal notranslate"><span class="pre">*MyInt</span></code> has <code class="docutils literal notranslate"><span class="pre">Set</span></code>.</p>
<p>But instantiating <code class="docutils literal notranslate"><span class="pre">Init</span></code> with <code class="docutils literal notranslate"><span class="pre">*MyInt</span></code> doesn’t work either, as then
the local variable <code class="docutils literal notranslate"><span class="pre">r</span></code> in <code class="docutils literal notranslate"><span class="pre">Init</span></code> is a value of type <code class="docutils literal notranslate"><span class="pre">*MyInt</span></code>
initialized to the zero value, which for a pointer is <code class="docutils literal notranslate"><span class="pre">nil</span></code>.
The <code class="docutils literal notranslate"><span class="pre">Init</span></code> function then invokes the <code class="docutils literal notranslate"><span class="pre">Set</span></code> method on a <code class="docutils literal notranslate"><span class="pre">nil</span></code> pointer,
causing a <code class="docutils literal notranslate"><span class="pre">nil</span></code> pointer dereference at the line <code class="docutils literal notranslate"><span class="pre">*p</span> <span class="pre">=</span> <span class="pre">MyInt(v)</span></code>.</p>
<p>In order to permit this kind of code, contracts permit specifying that
for a type parameter <code class="docutils literal notranslate"><span class="pre">T</span></code> the pointer type <code class="docutils literal notranslate"><span class="pre">*T</span></code> has a method.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="nx">contract</span> <span class="nx">setter</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">*</span><span class="nx">T</span> <span class="nx">Set</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With this definition of <code class="docutils literal notranslate"><span class="pre">setter</span></code>, instantiating <code class="docutils literal notranslate"><span class="pre">Init</span></code> with <code class="docutils literal notranslate"><span class="pre">MyInt</span></code> is
valid and the code works.
The local variable <code class="docutils literal notranslate"><span class="pre">r</span></code> has type <code class="docutils literal notranslate"><span class="pre">MyInt</span></code>, and the address of <code class="docutils literal notranslate"><span class="pre">r</span></code> is
passed as the receiver of the <code class="docutils literal notranslate"><span class="pre">Set</span></code> pointer method.
Instantiating <code class="docutils literal notranslate"><span class="pre">Init</span></code> with <code class="docutils literal notranslate"><span class="pre">*MyInt</span></code> is now invalid, as the type
<code class="docutils literal notranslate"><span class="pre">**MyInt</span></code> does not have a method <code class="docutils literal notranslate"><span class="pre">Set</span></code>.</p>
<p>Listing a <code class="docutils literal notranslate"><span class="pre">*T</span></code> method in a contract means that the method must be on
the type <code class="docutils literal notranslate"><span class="pre">*T</span></code>, and it means that the parameterized function is only
permitted to call the method on an addressable value of type <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
</div>
<div class="section" id="pointer-or-value-methods">
<h4>Pointer or value methods<a class="headerlink" href="#pointer-or-value-methods" title="Permalink to this headline">¶</a></h4>
<p>If a method is listed in a contract with a plain <code class="docutils literal notranslate"><span class="pre">T</span></code> rather than <code class="docutils literal notranslate"><span class="pre">*T</span></code>,
then it may be either a pointer method or a value method of <code class="docutils literal notranslate"><span class="pre">T</span></code>.
In order to avoid worrying about this distinction, in a generic
function body all method calls will be pointer method calls.
If necessary, the function body will insert temporary variables,
not seen by the user, in order to get an addressable variable to use
to call the method.</p>
<p>For example, this code is valid, even though <code class="docutils literal notranslate"><span class="pre">LookupAsString</span></code> calls
<code class="docutils literal notranslate"><span class="pre">String</span></code> in a context that requires a value method, and <code class="docutils literal notranslate"><span class="pre">MyInt</span></code> only
has a pointer method.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">LookupAsString</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">stringer</span><span class="p">)(</span><span class="nx">m</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">m</span><span class="p">[</span><span class="nx">k</span><span class="p">].</span><span class="nx">String</span><span class="p">()</span> <span class="c1">// Note: calls method on value of type T</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MyInt</span> <span class="kt">int</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">MyInt</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Itoa</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">))</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">F</span><span class="p">(</span><span class="nx">m</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="nx">MyInt</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">LookupAsString</span><span class="p">(</span><span class="nx">MyInt</span><span class="p">)(</span><span class="nx">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This makes it easier to understand which types satisfy a contract, and
how a contract may be used.
It has the drawback that in some cases a pointer method that modifies
the value to which the receiver points may be called on a temporary
variable that is discarded after the method completes.
It may be possible to add a vet warning for a case where a generic
function uses a temporary variable for a method call and the function
is instantiated with a type that has only a pointer method, not a
value method.</p>
<p>(Note: we should revisit this decision if it leads to confusion or
incorrect code.)</p>
</div>
<div class="section" id="operators">
<h4>Operators<a class="headerlink" href="#operators" title="Permalink to this headline">¶</a></h4>
<p>Method calls are not sufficient for everything we want to express.
Consider this simple function that returns the smallest element of a
slice of values, where the slice is assumed to be non-empty.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// This function is INVALID.</span>
<span class="kd">func</span> <span class="nx">Smallest</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">// panics if slice is empty</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">v</span> <span class="p">&lt;</span> <span class="nx">r</span> <span class="p">{</span> <span class="c1">// INVALID</span>
			<span class="nx">r</span> <span class="p">=</span> <span class="nx">v</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Any reasonable generics implementation should let you write this
function.
The problem is the expression <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">&lt;</span> <span class="pre">r</span></code>.
This assumes that <code class="docutils literal notranslate"><span class="pre">T</span></code> supports the <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> operator, but there is no
contract requiring that.
Without a contract the function body can only use operations that are
available for all types, but not all Go types support <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>.</p>
<p>It follows that we need a way to write a contract that accepts only
types that support <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>.
In order to do that, we observe that, aside from two exceptions that
we will discuss later, all the arithmetic, comparison, and logical
operators defined by the language may only be used with types that are
predeclared by the language, or with defined types whose underlying
type is one of those predeclared types.
That is, the operator <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> can only be used with a predeclared type
such as <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">float64</span></code>, or a defined type whose underlying type is
one of those types.
Go does not permit using <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> with an aggregate type or with an
arbitrary defined type.</p>
<p>This means that rather than try to write a contract for <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, we can
approach this the other way around: instead of saying which operators
a contract should support, we can say which (underlying) types a
contract should accept.</p>
</div>
<div class="section" id="types-in-contracts">
<h4>Types in contracts<a class="headerlink" href="#types-in-contracts" title="Permalink to this headline">¶</a></h4>
<p>A contract may list explicit types that may be used as type
arguments.
These are expressed in the form <code class="docutils literal notranslate"><span class="pre">type-parameter-name</span> <span class="pre">type,</span> <span class="pre">type...</span></code>.
The <code class="docutils literal notranslate"><span class="pre">type</span></code> must be a predeclared type, such as <code class="docutils literal notranslate"><span class="pre">int</span></code>, or an aggregate
as discussed below.
For example,</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="nx">contract</span> <span class="nx">SignedInteger</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">T</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int8</span><span class="p">,</span> <span class="kt">int16</span><span class="p">,</span> <span class="kt">int32</span><span class="p">,</span> <span class="kt">int64</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This contract specifies that the type argument must be one of the
listed types (<code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">int8</span></code>, and so forth), or it must be a defined
type whose underlying type is one of the listed types.</p>
<p>When a parameterized function using this contract has a value of type
<code class="docutils literal notranslate"><span class="pre">T</span></code>, it may use any operation that is permitted by all of the listed
types.
This can be an operation like <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, or for aggregate types an operation
like <code class="docutils literal notranslate"><span class="pre">range</span></code> or <code class="docutils literal notranslate"><span class="pre">&lt;-</span></code>.
If the function can be compiled successfully using each type listed in
the contract, then the operation is permitted.</p>
<p>For the <code class="docutils literal notranslate"><span class="pre">Smallest</span></code> example shown earlier, we could use a contract like
this:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="nx">contract</span> <span class="nx">Ordered</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">T</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int8</span><span class="p">,</span> <span class="kt">int16</span><span class="p">,</span> <span class="kt">int32</span><span class="p">,</span> <span class="kt">int64</span><span class="p">,</span>
		<span class="kt">uint</span><span class="p">,</span> <span class="kt">uint8</span><span class="p">,</span> <span class="kt">uint16</span><span class="p">,</span> <span class="kt">uint32</span><span class="p">,</span> <span class="kt">uint64</span><span class="p">,</span> <span class="kt">uintptr</span><span class="p">,</span>
		<span class="kt">float32</span><span class="p">,</span> <span class="kt">float64</span><span class="p">,</span>
		<span class="kt">string</span>
<span class="p">}</span>
</pre></div>
</div>
<p>(In practice this contract would likely be defined and exported in a
new standard library package, <code class="docutils literal notranslate"><span class="pre">contracts</span></code>, so that it could be used by
function and type and contract definitions.)</p>
<p>Given that contract, we can write this function, now valid:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Smallest</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">Ordered</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">// panics if slice is empty</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">v</span> <span class="p">&lt;</span> <span class="nx">r</span> <span class="p">{</span>
			<span class="nx">r</span> <span class="p">=</span> <span class="nx">v</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="conjunction-and-disjunction-in-contracts">
<h4>Conjunction and disjunction in contracts<a class="headerlink" href="#conjunction-and-disjunction-in-contracts" title="Permalink to this headline">¶</a></h4>
<p>The use of comma to separate types is a general mechanism.
A contract can be considered as a set of constraints, where the
constraints are either methods or types.
Separating constraints by a semicolon or newline means that the
constraints are a conjunction: each constraint must be satisfied.
Separating constraints by a comma means that the constraints are a
disjunction: at least one of the constraints must be satisified.</p>
<p>With a conjunction of constraints in a contract, a generic function
may use any operation permitted by at least one of the constraints.
With a disjunction, a generic function may use any operation permitted
by all of the constraints.</p>
<p>Syntactically, the type parameter being constrained must be listed for
each individual conjunction constraint, but only once for the
disjunction constraints.</p>
<p>Normally methods will be listed as a conjunction, separated by a
semicolon or newline.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// PrintStringer1 and PrintStringer2 are equivalent.</span>
<span class="nx">contract</span> <span class="nx">PrintStringer1</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">T</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>
	<span class="nx">T</span> <span class="nx">Print</span><span class="p">()</span>
<span class="p">}</span>

<span class="nx">contract</span> <span class="nx">PrintStringer2</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">T</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span><span class="p">;</span> <span class="nx">T</span> <span class="nx">Print</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Normally builtin types will be listed as a disjunction, separated by
commas.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="nx">contract</span> <span class="nx">Float</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">T</span> <span class="kt">float32</span><span class="p">,</span> <span class="kt">float64</span>
<span class="p">}</span>
</pre></div>
</div>
<p>However, this is not required.
For example:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="nx">contract</span> <span class="nx">IOCloser</span><span class="p">(</span><span class="nx">S</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">S</span> <span class="nx">Read</span><span class="p">([]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">),</span> <span class="c1">// note trailing comma</span>
		<span class="nx">Write</span><span class="p">([]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="nx">S</span> <span class="nx">Close</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This contract accepts any type that has a <code class="docutils literal notranslate"><span class="pre">Close</span></code> method and also has
either a <code class="docutils literal notranslate"><span class="pre">Read</span></code> or a <code class="docutils literal notranslate"><span class="pre">Write</span></code> method (or both).
To put it another way, it accepts any type that implements either
<code class="docutils literal notranslate"><span class="pre">io.ReadCloser</span></code> or <code class="docutils literal notranslate"><span class="pre">io.WriteCloser</span></code> (or both).
In a generic function using this contract permits calling the
<code class="docutils literal notranslate"><span class="pre">Close</span></code> method, but calling the <code class="docutils literal notranslate"><span class="pre">Read</span></code> or <code class="docutils literal notranslate"><span class="pre">Write</span></code> method requires a
type assertion to an interface type.
It’s not clear whether this is useful, but it is valid.</p>
<p>Another, pedantic, example:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="nx">contract</span> <span class="nx">unsatisfiable</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">T</span> <span class="kt">int</span>
	<span class="nx">T</span> <span class="kt">uint</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This contract permits any type that is both <code class="docutils literal notranslate"><span class="pre">int</span></code> and <code class="docutils literal notranslate"><span class="pre">uint</span></code>.
Since there is no such type, the contract does not permit any type.
This is valid but useless.</p>
</div>
<div class="section" id="both-types-and-methods-in-contracts">
<h4>Both types and methods in contracts<a class="headerlink" href="#both-types-and-methods-in-contracts" title="Permalink to this headline">¶</a></h4>
<p>A contract may list both builtin types and methods, typically using
conjunctions and disjunctions as follows:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="nx">contract</span> <span class="nx">StringableSignedInteger</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">T</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int8</span><span class="p">,</span> <span class="kt">int16</span><span class="p">,</span> <span class="kt">int32</span><span class="p">,</span> <span class="kt">int64</span>
	<span class="nx">T</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This contract permits any type defined as one of the listed types,
provided it also has a <code class="docutils literal notranslate"><span class="pre">String()</span> <span class="pre">string</span></code> method.
Although the <code class="docutils literal notranslate"><span class="pre">StringableSignedInteger</span></code> contract explicitly lists
<code class="docutils literal notranslate"><span class="pre">int</span></code>, the type <code class="docutils literal notranslate"><span class="pre">int</span></code> is not permitted as a type argument, since <code class="docutils literal notranslate"><span class="pre">int</span></code>
does not have a <code class="docutils literal notranslate"><span class="pre">String</span></code> method.
An example of a type argument that would be permitted is <code class="docutils literal notranslate"><span class="pre">MyInt</span></code>,
defined as:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">MyInt</span> <span class="kt">int</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">mi</span> <span class="nx">MyInt</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;MyInt(%d)&quot;</span><span class="p">,</span> <span class="nx">mi</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="aggregate-types-in-contracts">
<h4>Aggregate types in contracts<a class="headerlink" href="#aggregate-types-in-contracts" title="Permalink to this headline">¶</a></h4>
<p>A type in a contract need not be a predeclared type; it can be a type
literal composed of predeclared types.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="nx">contract</span> <span class="nx">byteseq</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">T</span> <span class="kt">string</span><span class="p">,</span> <span class="p">[]</span><span class="kt">byte</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The same rules apply.
The type argument for this contract may be <code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">[]byte</span></code> or a
type whose underlying type is one of those.
A parameterized function with this contract may use any operation
permitted by both <code class="docutils literal notranslate"><span class="pre">string</span></code> and <code class="docutils literal notranslate"><span class="pre">[]byte</span></code>.</p>
<p>Given these definitions</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">MyByte</span> <span class="kt">byte</span>
<span class="kd">type</span> <span class="nx">MyByteAlias</span> <span class="p">=</span> <span class="kt">byte</span>
</pre></div>
</div>
<p>the <code class="docutils literal notranslate"><span class="pre">byteseq</span></code> contract is satisfied by any of <code class="docutils literal notranslate"><span class="pre">string</span></code>, <code class="docutils literal notranslate"><span class="pre">[]byte</span></code>,
<code class="docutils literal notranslate"><span class="pre">[]MyByte</span></code>, <code class="docutils literal notranslate"><span class="pre">[]MyByteAlias</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">byteseq</span></code> contract permits writing generic functions that work
for either <code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">[]byte</span></code> types.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Join</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">byteseq</span><span class="p">)(</span><span class="nx">a</span> <span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">sep</span> <span class="nx">T</span><span class="p">)</span> <span class="p">(</span><span class="nx">ret</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Use the result parameter as a zero value;</span>
		<span class="c1">// see discussion of zero value below.</span>
		<span class="k">return</span> <span class="nx">ret</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">T</span><span class="p">(</span><span class="nb">append</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="kc">nil</span><span class="p">),</span> <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">...</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">sep</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="c1">// len works for both string and []byte</span>
	<span class="p">}</span>

	<span class="nx">b</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
	<span class="nx">bp</span> <span class="o">:=</span> <span class="nb">copy</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">s</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">{</span>
		<span class="nx">bp</span> <span class="o">+=</span> <span class="nb">copy</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="nx">bp</span><span class="p">:],</span> <span class="nx">sep</span><span class="p">)</span>
		<span class="nx">bp</span> <span class="o">+=</span> <span class="nb">copy</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="nx">bp</span><span class="p">:],</span> <span class="nx">s</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">T</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="aggregates-of-type-parameters-in-contracts">
<h4>Aggregates of type parameters in contracts<a class="headerlink" href="#aggregates-of-type-parameters-in-contracts" title="Permalink to this headline">¶</a></h4>
<p>A type literal in a contract can refer not only to predeclared types,
but also to type parameters.
In this example, the <code class="docutils literal notranslate"><span class="pre">Slice</span></code> contract takes two parameters.
The first type parameter is required to be a slice of the second.
There are no constraints on the second type parameter.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="nx">contract</span> <span class="nx">Slice</span><span class="p">(</span><span class="nx">S</span><span class="p">,</span> <span class="nx">Element</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">S</span> <span class="p">[]</span><span class="nx">Element</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can use the <code class="docutils literal notranslate"><span class="pre">Slice</span></code> contract to define a function that takes an
argument of a slice type and returns a result of that same type.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Map</span><span class="p">(</span><span class="kd">type</span> <span class="nx">S</span><span class="p">,</span> <span class="nx">Element</span> <span class="nx">Slice</span><span class="p">)(</span><span class="nx">s</span> <span class="nx">S</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">Element</span><span class="p">)</span> <span class="nx">Element</span><span class="p">)</span> <span class="nx">S</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">S</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MySlice</span> <span class="p">[]</span><span class="kt">int</span>

<span class="kd">func</span> <span class="nx">DoubleMySlice</span><span class="p">(</span><span class="nx">s</span> <span class="nx">MySlice</span><span class="p">)</span> <span class="nx">MySlice</span> <span class="p">{</span>
	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">Map</span><span class="p">(</span><span class="nx">MySlice</span><span class="p">,</span> <span class="kt">int</span><span class="p">)(</span><span class="nx">s</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">e</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">e</span> <span class="p">})</span>
	<span class="c1">// Here v has type MySlice, not type []int.</span>
	<span class="k">return</span> <span class="nx">v</span>
<span class="p">}</span>
</pre></div>
</div>
<p>(Note: the type inference rules described above do not permit
inferring both <code class="docutils literal notranslate"><span class="pre">MySlice</span></code> and <code class="docutils literal notranslate"><span class="pre">int</span></code> when <code class="docutils literal notranslate"><span class="pre">DoubleMySlice</span></code> calls <code class="docutils literal notranslate"><span class="pre">Map</span></code>.
It may be worth extending them, to make it easier to use functions
that are careful to return the same result type as input type.
Similarly, we would consider extending the type inference rules to
permit inferring the type <code class="docutils literal notranslate"><span class="pre">Edge</span></code> from the type <code class="docutils literal notranslate"><span class="pre">Node</span></code> in the
<code class="docutils literal notranslate"><span class="pre">graph.New</span></code> example shown earlier.)</p>
<p>To avoid a parsing ambiguity, when a type literal in a contract refers
to a parameterized type, extra parentheses are required, so that it is
not confused with a method.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">M</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="p">[]</span><span class="nx">T</span>

<span class="nx">contract</span> <span class="nx">C</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">T</span> <span class="nx">M</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span>   <span class="c1">// T must implement the method M with an argument of type T</span>
	<span class="nx">T</span> <span class="p">(</span><span class="nx">M</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="c1">// T must be the type M(T)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="comparable-types-in-contracts">
<h4>Comparable types in contracts<a class="headerlink" href="#comparable-types-in-contracts" title="Permalink to this headline">¶</a></h4>
<p>Earlier we mentioned that there are two exceptions to the rule that
operators may only be used with types that are predeclared by the
language.
The exceptions are <code class="docutils literal notranslate"><span class="pre">==</span></code> and <code class="docutils literal notranslate"><span class="pre">!=</span></code>, which are permitted for struct,
array, and interface types.
These are useful enough that we want to be able to write a contract
that accepts any comparable type.</p>
<p>To do this we introduce a new predeclared contract: <code class="docutils literal notranslate"><span class="pre">comparable</span></code>.
The <code class="docutils literal notranslate"><span class="pre">comparable</span></code> contract takes a single type parameter.
It accepts as a type argument any comparable type.
It permits in a parameterized function the use of <code class="docutils literal notranslate"><span class="pre">==</span></code> and <code class="docutils literal notranslate"><span class="pre">!=</span></code> with
values of that type parameter.</p>
<p>As a predeclared contract, <code class="docutils literal notranslate"><span class="pre">comparable</span></code> may be used in a function or
type definition, or it may be embedded in another contract.</p>
<p>For example, this function may be instantiated with any comparable
type:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Index</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">comparable</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">x</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="nx">x</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">i</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="observations-on-types-in-contracts">
<h4>Observations on types in contracts<a class="headerlink" href="#observations-on-types-in-contracts" title="Permalink to this headline">¶</a></h4>
<p>It may seem awkward to explicitly list types in a contract, but it is
clear both as to which type arguments are permitted at the call site,
and which operations are permitted by the parameterized function.</p>
<p>If the language later changes to support operator methods (there are
no such plans at present), then contracts will handle them as they do
any other kind of method.</p>
<p>There will always be a limited number of predeclared types, and a
limited number of operators that those types support.
Future language changes will not fundamentally change those facts, so
this approach will continue to be useful.</p>
<p>This approach does not attempt to handle every possible operator.
For example, there is no way to usefully express the struct field
reference <code class="docutils literal notranslate"><span class="pre">.</span></code> or the general index operator <code class="docutils literal notranslate"><span class="pre">[]</span></code>.
The expectation is that those will be handled using aggregate types in
a parameterized function definition, rather than requiring aggregate
types as a type argument.
For example, we expect functions that want to index into a slice to be
parameterized on the slice element type <code class="docutils literal notranslate"><span class="pre">T</span></code>, and to use parameters or
variables of type <code class="docutils literal notranslate"><span class="pre">[]T</span></code>.</p>
<p>As shown in the <code class="docutils literal notranslate"><span class="pre">DoubleMySlice</span></code> example above, this approach makes it
awkward to write generic functions that accept and return an aggregate
type and want to return the same result type as their argument type.
Defined aggregate types are not common, but they do arise.
This awkwardness is a weakness of this approach.</p>
</div>
<div class="section" id="type-conversions">
<h4>Type conversions<a class="headerlink" href="#type-conversions" title="Permalink to this headline">¶</a></h4>
<p>In a function with two type parameters <code class="docutils literal notranslate"><span class="pre">From</span></code> and <code class="docutils literal notranslate"><span class="pre">To</span></code>, a value of
type <code class="docutils literal notranslate"><span class="pre">From</span></code> may be converted to a value of type <code class="docutils literal notranslate"><span class="pre">To</span></code> if all the
types accepted by <code class="docutils literal notranslate"><span class="pre">From</span></code>’s contract can be converted to all the
types accepted by <code class="docutils literal notranslate"><span class="pre">To</span></code>’s contract.
If either type parameter does not accept types, then type conversions
are not permitted.</p>
<p>For example:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="nx">contract</span> <span class="nx">integer</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">T</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int8</span><span class="p">,</span> <span class="kt">int16</span><span class="p">,</span> <span class="kt">int32</span><span class="p">,</span> <span class="kt">int64</span><span class="p">,</span>
		<span class="kt">uint</span><span class="p">,</span> <span class="kt">uint8</span><span class="p">,</span> <span class="kt">uint16</span><span class="p">,</span> <span class="kt">uint32</span><span class="p">,</span> <span class="kt">uint64</span><span class="p">,</span> <span class="kt">uintptr</span>
<span class="p">}</span>

<span class="nx">contract</span> <span class="nx">integer2</span><span class="p">(</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">integer</span><span class="p">(</span><span class="nx">T1</span><span class="p">)</span>
	<span class="nx">integer</span><span class="p">(</span><span class="nx">T2</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Convert</span><span class="p">(</span><span class="kd">type</span> <span class="nx">To</span><span class="p">,</span> <span class="nx">From</span> <span class="nx">integer2</span><span class="p">)(</span><span class="nx">from</span> <span class="nx">From</span><span class="p">)</span> <span class="nx">To</span> <span class="p">{</span>
	<span class="nx">to</span> <span class="o">:=</span> <span class="nx">To</span><span class="p">(</span><span class="nx">from</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">From</span><span class="p">(</span><span class="nx">to</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">from</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&quot;conversion out of range&quot;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">to</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The type conversions in <code class="docutils literal notranslate"><span class="pre">Convert</span></code> are permitted because Go permits
every integer type to be converted to every other integer type.</p>
</div>
<div class="section" id="untyped-constants">
<h4>Untyped constants<a class="headerlink" href="#untyped-constants" title="Permalink to this headline">¶</a></h4>
<p>Some functions use untyped constants.
An untyped constant is permitted with a value of some type parameter
if it is permitted with every type accepted by the type parameter’s
contract.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="nx">contract</span> <span class="nx">integer</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">T</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int8</span><span class="p">,</span> <span class="kt">int16</span><span class="p">,</span> <span class="kt">int32</span><span class="p">,</span> <span class="kt">int64</span><span class="p">,</span>
		<span class="kt">uint</span><span class="p">,</span> <span class="kt">uint8</span><span class="p">,</span> <span class="kt">uint16</span><span class="p">,</span> <span class="kt">uint32</span><span class="p">,</span> <span class="kt">uint64</span><span class="p">,</span> <span class="kt">uintptr</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Add10</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">integer</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v</span> <span class="o">+</span> <span class="mi">10</span> <span class="c1">// OK: 10 can convert to any integer type</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// This function is INVALID.</span>
<span class="kd">func</span> <span class="nx">Add1024</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">integer</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v</span> <span class="o">+</span> <span class="mi">1024</span> <span class="c1">// INVALID: 1024 not permitted by int8/uint8</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="implementation">
<h3>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h3>
<p>Russ Cox <a class="reference external" href="https://research.swtch.com/generic">famously observed</a> that
generics require choosing among slow programmers, slow compilers, or
slow execution times.</p>
<p>We believe that this design permits different implementation choices.
Code may be compiled separately for each set of type arguments, or it
may be compiled as though each type argument is handled similarly to
an interface type with method calls, or there may be some combination
of the two.</p>
<p>In other words, this design permits people to stop choosing slow
programmers, and permits the implementation to decide between slow
compilers (compile each set of type arguments separately) or slow
execution times (use method calls for each operation on a value of a
type argument).</p>
</div>
<div class="section" id="summary">
<h3>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h3>
<p>While this document is long and detailed, the actual design reduces to
a few major points.</p>
<ul class="simple">
<li><p>Functions and types can have type parameters, which are defined
using optional contracts.</p></li>
<li><p>Contracts describe the methods required and the builtin types
permitted for a type argument.</p></li>
<li><p>Contracts describe the methods and operations permitted for a type
parameter.</p></li>
<li><p>Type inference will often permit omitting type arguments when
calling functions with type parameters.</p></li>
</ul>
<p>This design is completely backward compatible, in that any valid Go 1
program will still be valid if this design is adopted (assuming
<code class="docutils literal notranslate"><span class="pre">contract</span></code> is treated as a pseudo-keyword that is only meaningful at
top level).</p>
<p>We believe that this design addresses people’s needs for generic
programming in Go, without making the language any more complex than
necessary.</p>
<p>We can’t truly know the impact on the language without years of
experience with this design.
That said, here are some speculations.</p>
<div class="section" id="complexity">
<h4>Complexity<a class="headerlink" href="#complexity" title="Permalink to this headline">¶</a></h4>
<p>One of the great aspects of Go is its simplicity.
Clearly this design makes the language more complex.</p>
<p>We believe that the increased complexity is small for people reading
well written generic code, rather than writing it.
Naturally people must learn the new syntax for declaring type
parameters.
The code within a generic function reads like ordinary Go code, as can
be seen in the examples below.
It is an easy shift to go from <code class="docutils literal notranslate"><span class="pre">[]int</span></code> to <code class="docutils literal notranslate"><span class="pre">[]T</span></code>.
Type parameter contracts serve effectively as documentation,
describing the type.</p>
<p>We expect that most people will not write generic code themselves, but
many people are likely to write packages that use generic code written
by others.
In the common case, generic functions work exactly like non-generic
functions: you simply call them.
Type inference means that you do not have to write out the type
arguments explicitly.
The type inference rules are designed to be unsurprising: either the
type arguments are deduced correctly, or the call fails and requires
explicit type parameters.
Type inference uses type identity, with no attempt to resolve two
types that are similar but not identical, which removes significant
complexity.</p>
<p>People using generic types will have to pass explicit type arguments.
The syntax for this is familiar.
The only change is passing arguments to types rather than only to
functions.</p>
<p>In general, we have tried to avoid surprises in the design.
Only time will tell whether we succeeded.</p>
</div>
<div class="section" id="pervasiveness">
<h4>Pervasiveness<a class="headerlink" href="#pervasiveness" title="Permalink to this headline">¶</a></h4>
<p>We expect that a few new packages will be added to the standard
library.
A new <code class="docutils literal notranslate"><span class="pre">slices</span></code> packages will be similar to the existing bytes and
strings packages, operating on slices of any element type.
New <code class="docutils literal notranslate"><span class="pre">maps</span></code> and <code class="docutils literal notranslate"><span class="pre">chans</span></code> packages will provide simple algorithms that
are currently duplicated for each element type.
A <code class="docutils literal notranslate"><span class="pre">set</span></code> package may be added.</p>
<p>A new <code class="docutils literal notranslate"><span class="pre">contracts</span></code> packages will provide standard embeddable contracts,
such as contracts that permit all integer types or all numeric types.</p>
<p>Packages like <code class="docutils literal notranslate"><span class="pre">container/list</span></code> and <code class="docutils literal notranslate"><span class="pre">container/ring</span></code>, and types like
<code class="docutils literal notranslate"><span class="pre">sync.Map</span></code>, will be updated to be compile-time type-safe.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">math</span></code> package will be extended to provide a set of simple
standard algorithms for all numeric types, such as the ever popular
<code class="docutils literal notranslate"><span class="pre">Min</span></code> and <code class="docutils literal notranslate"><span class="pre">Max</span></code> functions.</p>
<p>It is likely that new special purpose compile-time type-safe container
types will be developed, and some may become widely used.</p>
<p>We do not expect approaches like the C++ STL iterator types to become
widely used.
In Go that sort of idea is more naturally expressed using an interface
type.
In C++ terms, using an interface type for an iterator can be seen as
carrying an abstraction penalty, in that run-time efficiency will be
less than C++ approaches that in effect inline all code; we believe
that Go programmers will continue to find that sort of penalty to be
acceptable.</p>
<p>As we get more container types, we may develop a standard <code class="docutils literal notranslate"><span class="pre">Iterator</span></code>
interface.
That may in turn lead to pressure to modify the language to add some
mechanism for using an <code class="docutils literal notranslate"><span class="pre">Iterator</span></code> with the <code class="docutils literal notranslate"><span class="pre">range</span></code> clause.
That is very speculative, though.</p>
</div>
<div class="section" id="efficiency">
<h4>Efficiency<a class="headerlink" href="#efficiency" title="Permalink to this headline">¶</a></h4>
<p>It is not clear what sort of efficiency people expect from generic
code.</p>
<p>Generic functions, rather than generic types, can probably be compiled
using an interface-based approach.
That will optimize compile time, in that the package is only compiled
once, but there will be some run time cost.</p>
<p>Generic types may most naturally be compiled multiple times for each
set of type arguments.
This will clearly carry a compile time cost, but there shouldn’t be
any run time cost.
Compilers can also choose to implement generic types similarly to
interface types, using special purpose methods to access each element
that depends on a type parameter.</p>
<p>Only experience will show what people expect in this area.</p>
</div>
<div class="section" id="omissions">
<h4>Omissions<a class="headerlink" href="#omissions" title="Permalink to this headline">¶</a></h4>
<p>We believe that this design covers the basic requirements for
generic programming.
However, there are a number of programming constructs that are not
supported.</p>
<ul class="simple">
<li><p>No specialization.
There is no way to write multiple versions of a generic function
that are designed to work with specific type arguments (other than
using type assertions or type switches).</p></li>
<li><p>No metaprogramming.
There is no way to write code that is executed at compile time to
generate code to be executed at run time.</p></li>
<li><p>No higher level abstraction.
There is no way to speak about a function with type arguments other
than to call it or instantiate it.
There is no way to speak about a parameterized type other than to
instantiate it.</p></li>
<li><p>No general type description.
For operator support contracts use specific types, rather than
describing the characteristics that a type must have.
This is easy to understand but may be limiting at times.</p></li>
<li><p>No covariance or contravariance.</p></li>
<li><p>No operator methods.
You can write a generic container that is compile-time type-safe,
but you can only access it with ordinary methods, not with syntax
like <code class="docutils literal notranslate"><span class="pre">c[k]</span></code>.
Similarly, there is no way to use <code class="docutils literal notranslate"><span class="pre">range</span></code> with a generic container
type.</p></li>
<li><p>No currying.
There is no way to specify only some of the type arguments, other
than by using a type alias or a helper function.</p></li>
<li><p>No adaptors.
There is no way for a contract to define adaptors that could be used
to support type arguments that do not already satisfy the contract,
such as, for example, defining an <code class="docutils literal notranslate"><span class="pre">==</span></code> operator in terms of an
<code class="docutils literal notranslate"><span class="pre">Equal</span></code> method, or vice-versa.</p></li>
<li><p>No parameterization on non-type values such as constants.
This arises most obviously for arrays, where it might sometimes be
convenient to write <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">Matrix(type</span> <span class="pre">n</span> <span class="pre">int)</span> <span class="pre">[n][n]float64</span></code>.
It might also sometimes be useful to specify significant values for
a container type, such as a default value for elements.</p></li>
</ul>
</div>
<div class="section" id="issues">
<h4>Issues<a class="headerlink" href="#issues" title="Permalink to this headline">¶</a></h4>
<p>There are some issues with this design that deserve a more detailed
discussion.
We think these issues are relatively minor compared to the design as a
whole, but they still deserve a complete hearing and discussion.</p>
<div class="section" id="the-zero-value">
<h5>The zero value<a class="headerlink" href="#the-zero-value" title="Permalink to this headline">¶</a></h5>
<p>This design has no simple expression for the zero value of a type
parameter.
For example, consider this implementation of optional values that uses
pointers:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Optional</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">p</span> <span class="o">*</span><span class="nx">T</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="nx">Optional</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Val</span><span class="p">()</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">o</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">*</span><span class="nx">o</span><span class="p">.</span><span class="nx">p</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">zero</span> <span class="nx">T</span>
	<span class="k">return</span> <span class="nx">zero</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the case where <code class="docutils literal notranslate"><span class="pre">o.p</span> <span class="pre">==</span> <span class="pre">nil</span></code>, we want to return the zero value of
<code class="docutils literal notranslate"><span class="pre">T</span></code>, but we have no way to write that.
It would be nice to be able to write <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">nil</span></code>, but that wouldn’t
work if <code class="docutils literal notranslate"><span class="pre">T</span></code> is, say, <code class="docutils literal notranslate"><span class="pre">int</span></code>; in that case we would have to write
<code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">0</span></code>.
And, of course, there is no contract to support either <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">nil</span></code> or
<code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">0</span></code>.</p>
<p>Some approaches to this are:</p>
<ul class="simple">
<li><p>Use <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">zero</span> <span class="pre">T</span></code>, as above, which works with the existing design
but requires an extra statement.</p></li>
<li><p>Use <code class="docutils literal notranslate"><span class="pre">*new(T)</span></code>, which is ugly but works with the existing design.</p></li>
<li><p>For results only, name the result parameter <code class="docutils literal notranslate"><span class="pre">_</span></code>, and use a naked
<code class="docutils literal notranslate"><span class="pre">return</span></code> statement to return the zero value.</p></li>
<li><p>Extend the design to permit using <code class="docutils literal notranslate"><span class="pre">nil</span></code> as the zero value of any
generic type (but see <a class="reference external" href="https://golang.org/issue/22729">issue 22729</a>).</p></li>
<li><p>Extend the design to permit using <code class="docutils literal notranslate"><span class="pre">T{}</span></code>, where <code class="docutils literal notranslate"><span class="pre">T</span></code> is a type
parameter, to indicate the zero value of the type.</p></li>
<li><p>Change the language to permit using <code class="docutils literal notranslate"><span class="pre">_</span></code> on the right hand of an
assignment (including <code class="docutils literal notranslate"><span class="pre">return</span></code> or a function call) as proposed in
<a class="reference external" href="https://golang.org/issue/19642">issue 19642</a>.</p></li>
</ul>
<p>We feel that more experience with this design is needed before
deciding what, if anything, to do here.</p>
</div>
<div class="section" id="lots-of-irritating-silly-parentheses">
<h5>Lots of irritating silly parentheses<a class="headerlink" href="#lots-of-irritating-silly-parentheses" title="Permalink to this headline">¶</a></h5>
<p>Calling a function with type parameters requires an additional list of
type arguments if the type arguments can not be inferred.
If the function returns a function, and we call that, we get still
more parentheses.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span>	<span class="nx">F</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float64</span><span class="p">)(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)(</span><span class="nx">s</span><span class="p">)</span>
</pre></div>
</div>
<p>We experimented with other syntaxes, such as using a colon to separate
the type arguments from the regular arguments.
The current design seems to be the nicest, but perhaps something
better is possible.</p>
</div>
<div class="section" id="pointer-vs-value-methods-in-contracts">
<h5>Pointer vs. value methods in contracts<a class="headerlink" href="#pointer-vs-value-methods-in-contracts" title="Permalink to this headline">¶</a></h5>
<p>Contracts do not provide a way to distinguish between pointer and
value methods, so types that provide either will satisfy a contract.
This in turn requires that parameterized functions always permit
either kind of method.
This may be confusing, in that a parameterized function may invoke a
pointer method on a temporary value; if the pointer method changes the
value to which the receiver points, those changes will be lost.
We will have to judge from experience how much this confuses people in
practice.</p>
</div>
<div class="section" id="defined-aggregate-types">
<h5>Defined aggregate types<a class="headerlink" href="#defined-aggregate-types" title="Permalink to this headline">¶</a></h5>
<p>As discussed above, an extra type parameter is required for a function
to take, as an argument, a defined type whose underlying type is an
aggregate type, and to return the same defined type as a result.</p>
<p>For example, this function will map a function across a slice.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Map</span><span class="p">(</span><span class="kd">type</span> <span class="nx">Element</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">Element</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">Element</span><span class="p">)</span> <span class="nx">Element</span><span class="p">)</span> <span class="p">[]</span><span class="nx">Element</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">Element</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</pre></div>
</div>
<p>However, when called on a defined type, it will return a slice of the
element type of that type, rather than the defined type itself.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">MySlice</span> <span class="p">[]</span><span class="kt">int</span>

<span class="kd">func</span> <span class="nx">DoubleMySlice</span><span class="p">(</span><span class="nx">s</span> <span class="nx">MySlice</span><span class="p">)</span> <span class="nx">MySlice</span> <span class="p">{</span>
	<span class="nx">s2</span> <span class="o">:=</span> <span class="nx">Map</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">e</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">e</span> <span class="p">})</span>
	<span class="c1">// Here s2 is type []int, not type MySlice.</span>
	<span class="k">return</span> <span class="nx">MySlice</span><span class="p">(</span><span class="nx">s2</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As discussed above with an example, this can be avoided by using an
extra type parameter for <code class="docutils literal notranslate"><span class="pre">Map</span></code>, and using a contract that describes
the required relationship between the slice and element types.
This works but is awkward.</p>
</div>
<div class="section" id="identifying-the-matched-predeclared-type">
<h5>Identifying the matched predeclared type<a class="headerlink" href="#identifying-the-matched-predeclared-type" title="Permalink to this headline">¶</a></h5>
<p>In this design we suggest permitting type assertions and type switches
on values whose types are based on type parameters, but those type
assertions and switches would always test the actual type argument.
The design doesn’t provide any way to test the contract type matched
by the type argument.</p>
<p>Here is an example that shows the difference.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="nx">contract</span> <span class="nx">Float</span><span class="p">(</span><span class="nx">F</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">F</span> <span class="kt">float32</span><span class="p">,</span> <span class="kt">float64</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">NewtonSqrt</span><span class="p">(</span><span class="kd">type</span> <span class="nx">F</span> <span class="nx">Float</span><span class="p">)(</span><span class="nx">v</span> <span class="nx">F</span><span class="p">)</span> <span class="nx">F</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">iterations</span> <span class="kt">int</span>
	<span class="k">switch</span> <span class="nx">v</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="kt">float32</span><span class="p">:</span>
		<span class="nx">iterations</span> <span class="p">=</span> <span class="mi">4</span>
	<span class="k">case</span> <span class="kt">float64</span><span class="p">:</span>
		<span class="nx">iterations</span> <span class="p">=</span> <span class="mi">5</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;unexpected type %T&quot;</span><span class="p">,</span> <span class="nx">v</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="c1">// Code omitted.</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MyFloat</span> <span class="kt">float32</span>

<span class="kd">var</span> <span class="nx">G</span> <span class="p">=</span> <span class="nx">NewtonSqrt</span><span class="p">(</span><span class="nx">MyFloat</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span>
</pre></div>
</div>
<p>This code will panic when initializing <code class="docutils literal notranslate"><span class="pre">G</span></code>, because the type of <code class="docutils literal notranslate"><span class="pre">v</span></code> in
the <code class="docutils literal notranslate"><span class="pre">NewtonSqrt</span></code> function will be <code class="docutils literal notranslate"><span class="pre">MyFloat</span></code>, not <code class="docutils literal notranslate"><span class="pre">float32</span></code> or
<code class="docutils literal notranslate"><span class="pre">float64</span></code>.
What this function actually wants to test is not the type of <code class="docutils literal notranslate"><span class="pre">v</span></code>, but
the type that <code class="docutils literal notranslate"><span class="pre">v</span></code> matched in the contract.</p>
<p>One way to handle this would be to permit type switches on the type
<code class="docutils literal notranslate"><span class="pre">F</span></code>, rather than the value <code class="docutils literal notranslate"><span class="pre">v</span></code>, with the proviso that the type <code class="docutils literal notranslate"><span class="pre">F</span></code>
would always match a type defined in the contract.
This kind of type switch would only be permitted if the contract does
list explicit types, and only types listed in the contract would be
permitted as cases.</p>
<p>If we took this approach, we would stop permitting type assertions and
switches on values whose type is based on a type parameter.
Those assertions and switches can always be done by first converting
the value to the empty interface type.</p>
<p>A different approach would be that if a contract specifies any types
for a type parameter, then let type switches and assertions on values
whose type is, or is based on, that type parameter to match only the
types listed in the type parameter’s contract.
It is still possible to match the value’s actual type by first
converting it to the <code class="docutils literal notranslate"><span class="pre">interface{}</span></code> type and then doing the type
assertion or switch.</p>
</div>
</div>
<div class="section" id="discarded-ideas">
<h4>Discarded ideas<a class="headerlink" href="#discarded-ideas" title="Permalink to this headline">¶</a></h4>
<p>This design is not perfect, and it will be changed as we gain
experience with it.
That said, there are many ideas that we’ve already considered in
detail.
This section lists some of those ideas in the hopes that it will help
to reduce repetitive discussion.
The ideas are presented in the form of a FAQ.</p>
<div class="section" id="why-not-use-interfaces-instead-of-contracts">
<h5>Why not use interfaces instead of contracts?<a class="headerlink" href="#why-not-use-interfaces-instead-of-contracts" title="Permalink to this headline">¶</a></h5>
<p><em>The interface method syntax is familiar.</em>
<em>Why introduce another way to write methods?</em></p>
<p>Contracts, unlike interfaces, support multiple types, including
describing ways that the types refer to each other.</p>
<p>It is unclear how to represent operators using interface methods.
We considered syntaxes like <code class="docutils literal notranslate"><span class="pre">+(T,</span> <span class="pre">T)</span> <span class="pre">T</span></code>, but that is confusing and
repetitive.
Also, a minor point, but <code class="docutils literal notranslate"><span class="pre">==(T,</span> <span class="pre">T)</span> <span class="pre">bool</span></code> does not correspond to the
<code class="docutils literal notranslate"><span class="pre">==</span></code> operator, which returns an untyped boolean value, not <code class="docutils literal notranslate"><span class="pre">bool</span></code>.
We also considered writing simply <code class="docutils literal notranslate"><span class="pre">+</span></code> or <code class="docutils literal notranslate"><span class="pre">==</span></code>.
That seems to work but unfortunately the semicolon insertion rules
require writing a semicolon after each operator at the end of a line.
Using contracts that look like functions gives us a familiar syntax at
the cost of some repetition.
These are not fatal problems, but they are difficulties.</p>
<p>More seriously, a contract is a relationship between the definition of
a generic function and the callers of that function.
To put it another way, it is a relationship between a set of type
parameters and a set of type arguments.
The contract defines how values of the type parameters may be used,
and defines the requirements on the type arguments.
That is why it is called a contract: because it defines the behavior
on both sides.</p>
<p>An interface is a type, not a relationship between function
definitions and callers.
A program can have a value of an interface type, but it makes no sense
to speak of a value of a contract type.
A value of interface type has both a static type (the interface type)
and a dynamic type (some non-interface type), but there is no similar
concept for contracts.</p>
<p>In other words, contracts are not extensions of interface types.
There are things you can do with a contract that you cannot do with an
interface type, and there are things you can do with an interace type
that you cannot do with a contract.</p>
<p>It is true that a contract that has a single type parameter and that
lists only methods, not builtin types, for that type parameter, looks
similar to an interface type.
But all the similarity amounts to is that both provide a list of
methods.
We could consider permitting using an interface type as a contract
with a single type parameter that lists only methods.
But that should not mislead us into thinking that contracts are
interfaces.</p>
</div>
<div class="section" id="why-not-permit-contracts-to-describe-a-type">
<h5>Why not permit contracts to describe a type?<a class="headerlink" href="#why-not-permit-contracts-to-describe-a-type" title="Permalink to this headline">¶</a></h5>
<p><em>In order to use operators contracts have to explicitly and tediously</em>
<em>list types.</em>
<em>Why not permit them to describe a type?</em></p>
<p>There are many different ways that a Go type can be used.
While it is possible to invent notation to describe the various
operations in a contract, it leads to a proliferation of additional
syntactic constructs, making contracts complicated and hard to read.
The approach used in this design is simpler and relies on only a few
new syntactic constructs and names.</p>
</div>
<div class="section" id="why-not-put-type-parameters-on-packages">
<h5>Why not put type parameters on packages?<a class="headerlink" href="#why-not-put-type-parameters-on-packages" title="Permalink to this headline">¶</a></h5>
<p>We investigated this extensively.
It becomes problematic when you want to write a <code class="docutils literal notranslate"><span class="pre">list</span></code> package, and
you want that package to include a <code class="docutils literal notranslate"><span class="pre">Transform</span></code> function that converts
a <code class="docutils literal notranslate"><span class="pre">List</span></code> of one element type to a <code class="docutils literal notranslate"><span class="pre">List</span></code> of another element type.
It’s very awkward for a function in one instantiation of a package to
return a type that requires a different instantiation of the package.</p>
<p>It also confuses package boundaries with type definitions.
There is no particular reason to think that the uses of parameterized
types will break down neatly into packages.
Sometimes they will, sometimes they won’t.</p>
</div>
<div class="section" id="why-not-use-the-syntax-f-t-like-c-and-java">
<h5>Why not use the syntax <code class="docutils literal notranslate"><span class="pre">F&lt;T&gt;</span></code> like C++ and Java?<a class="headerlink" href="#why-not-use-the-syntax-f-t-like-c-and-java" title="Permalink to this headline">¶</a></h5>
<p>When parsing code within a function, such as <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">:=</span> <span class="pre">F&lt;T&gt;</span></code>, at the point
of seeing the <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> it’s ambiguous whether we are seeing a type
instantiation or an expression using the <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> operator.
Resolving that requires effectively unbounded lookahead.
In general we strive to keep the Go parser simple.</p>
</div>
<div class="section" id="why-not-use-the-syntax-f-t">
<h5>Why not use the syntax <code class="docutils literal notranslate"><span class="pre">F[T]</span></code>?<a class="headerlink" href="#why-not-use-the-syntax-f-t" title="Permalink to this headline">¶</a></h5>
<p>When parsing a type declaration <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">A</span> <span class="pre">[T]</span> <span class="pre">int</span></code> it’s ambiguous
whether this is a parameterized type defined (uselessly) as <code class="docutils literal notranslate"><span class="pre">int</span></code> or
whether it is an array type with <code class="docutils literal notranslate"><span class="pre">T</span></code> elements.
However, this would be addressed by requiring <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">A</span> <span class="pre">[type</span> <span class="pre">T]</span> <span class="pre">int</span></code>
for a parameterized type.</p>
<p>Parsing declarations like <code class="docutils literal notranslate"><span class="pre">func</span> <span class="pre">f(A[T]int)</span></code> (a single parameter of
type <code class="docutils literal notranslate"><span class="pre">[T]int</span></code>) and <code class="docutils literal notranslate"><span class="pre">func</span> <span class="pre">f(A[T],</span> <span class="pre">int)</span></code> (two parameters, one of type
<code class="docutils literal notranslate"><span class="pre">A[T]</span></code> and one of type <code class="docutils literal notranslate"><span class="pre">int</span></code>) show that some additional parsing
lookahead is required.
This is solvable but adds parsing complexity.</p>
<p>The language generally permits a trailing comma in a comma-separated
list, so <code class="docutils literal notranslate"><span class="pre">A[T,]</span></code> should be permitted if <code class="docutils literal notranslate"><span class="pre">A</span></code> is a parameterized type,
but normally would not be permitted for an index expression.
However, the parser can’t know whether <code class="docutils literal notranslate"><span class="pre">A</span></code> is a parameterized type or
a value of slice, array, or map type, so this parse error can not be
reported until after type checking is complete.
Again, solvable but complicated.</p>
<p>More generally, we felt that the square brackets were too intrusive on
the page and that parentheses were more Go like.
We will reevaluate this decision as we gain more experience.</p>
</div>
<div class="section" id="why-not-use-ft">
<h5>Why not use <code class="docutils literal notranslate"><span class="pre">F«T»</span></code>?<a class="headerlink" href="#why-not-use-ft" title="Permalink to this headline">¶</a></h5>
<p>We considered it but we couldn’t bring ourselves to require
non-ASCII.</p>
</div>
<div class="section" id="why-not-define-contracts-in-a-standard-package">
<h5>Why not define contracts in a standard package?<a class="headerlink" href="#why-not-define-contracts-in-a-standard-package" title="Permalink to this headline">¶</a></h5>
<p><em>Instead of writing out contracts, use names like</em>
<em><code class="docutils literal notranslate"><span class="pre">contracts.Arithmetic</span></code> and <code class="docutils literal notranslate"><span class="pre">contracts.Comparable</span></code>.</em></p>
<p>Listing all the possible combinations of types gets rather lengthy.
It also introduces a new set of names that not only the writer of
generic code, but, more importantly, the reader, must remember.
One of the driving goals of this design is to introduce as few new
names as possible.
In this design we introduce one new keyword and one new predefined
name.</p>
<p>We expect that if people find such names useful, we can introduce a
package <code class="docutils literal notranslate"><span class="pre">contracts</span></code> that defines the useful names in the form of
contracts that can be used by other types and functions and embedded
in other contracts.</p>
</div>
</div>
<div class="section" id="comparison-with-java">
<h4>Comparison with Java<a class="headerlink" href="#comparison-with-java" title="Permalink to this headline">¶</a></h4>
<p>Most complaints about Java generics center around type erasure.
This design does not have type erasure.
The reflection information for a generic type will include the full
compile-time type information.</p>
<p>In Java type wildcards (<code class="docutils literal notranslate"><span class="pre">List&lt;?</span> <span class="pre">extends</span> <span class="pre">Number&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">List&lt;?</span> <span class="pre">super</span> <span class="pre">Number&gt;</span></code>) implement covariance and contravariance.
These concepts are missing from Go, which makes generic types much
simpler.</p>
</div>
<div class="section" id="comparison-with-c">
<h4>Comparison with C++<a class="headerlink" href="#comparison-with-c" title="Permalink to this headline">¶</a></h4>
<p>C++ templates do not enforce any constraints on the type arguments
(unless the concept proposal is adopted).
This means that changing template code can accidentally break far-off
instantiations.
It also means that error messages are reported only at instantiation
time, and can be deeply nested and difficult to understand.
This design avoids these problems through explicit contracts.</p>
<p>C++ supports template metaprogramming, which can be thought of as
ordinary programming done at compile time using a syntax that is
completely different than that of non-template C++.
This design has no similar feature.
This saves considerable complexity while losing some power and run
time efficiency.</p>
</div>
</div>
<div class="section" id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h3>
<p>The following sections are examples of how this design could be used.
This is intended to address specific areas where people have created
user experience reports concerned with Go’s lack of generics.</p>
<div class="section" id="sort">
<h4>Sort<a class="headerlink" href="#sort" title="Permalink to this headline">¶</a></h4>
<p>Before the introduction of <code class="docutils literal notranslate"><span class="pre">sort.Slice</span></code>, a common complaint was the
need for boilerplate definitions in order to use <code class="docutils literal notranslate"><span class="pre">sort.Sort</span></code>.
With this design, we can add to the sort package as follows:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">orderedSlice</span><span class="p">(</span><span class="kd">type</span> <span class="nx">Elem</span> <span class="nx">Ordered</span><span class="p">)</span> <span class="p">[]</span><span class="nx">Elem</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">orderedSlice</span><span class="p">(</span><span class="nx">Elem</span><span class="p">))</span> <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span>           <span class="p">{</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">orderedSlice</span><span class="p">(</span><span class="nx">Elem</span><span class="p">))</span> <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">orderedSlice</span><span class="p">(</span><span class="nx">Elem</span><span class="p">))</span> <span class="nx">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span>      <span class="p">{</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">}</span>

<span class="c1">// OrderedSlice sorts the slice s in ascending order.</span>
<span class="c1">// The elements of s must be ordered using the &lt; operator.</span>
<span class="kd">func</span> <span class="nx">OrderedSlice</span><span class="p">(</span><span class="kd">type</span> <span class="nx">Elem</span> <span class="nx">Ordered</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">Elem</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">orderedSlice</span><span class="p">(</span><span class="nx">Elem</span><span class="p">)(</span><span class="nx">s</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now we can write:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span>	<span class="nx">sort</span><span class="p">.</span><span class="nx">OrderedSlice</span><span class="p">(</span><span class="kt">int32</span><span class="p">)([]</span><span class="kt">int32</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">})</span>
</pre></div>
</div>
<p>We can rely on type inference to omit the type argument list:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span>	<span class="nx">sort</span><span class="p">.</span><span class="nx">OrderedSlice</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">})</span>
</pre></div>
</div>
<p>Along the same lines, we can add a function for sorting using a
comparison function, similar to <code class="docutils literal notranslate"><span class="pre">sort.Slice</span></code> but writing the function
to take values rather than slice indexes.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">sliceFn</span><span class="p">(</span><span class="kd">type</span> <span class="nx">Elem</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">s</span> <span class="p">[]</span><span class="nx">Elem</span>
	<span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">Elem</span><span class="p">,</span> <span class="nx">Elem</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">sliceFn</span><span class="p">(</span><span class="nx">Elem</span><span class="p">))</span> <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span>           <span class="p">{</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">s</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">sliceFn</span><span class="p">(</span><span class="nx">Elem</span><span class="p">))</span> <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">s</span><span class="p">.</span><span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">sliceFn</span><span class="p">(</span><span class="nx">Elem</span><span class="p">))</span> <span class="nx">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span>      <span class="p">{</span> <span class="nx">s</span><span class="p">.</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">s</span><span class="p">.</span><span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">s</span><span class="p">.</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">}</span>

<span class="c1">// SliceFn sorts the slice s according to the function f.</span>
<span class="kd">func</span> <span class="nx">SliceFn</span><span class="p">(</span><span class="kd">type</span> <span class="nx">Elem</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">Elem</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">Elem</span><span class="p">,</span> <span class="nx">Elem</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">Sort</span><span class="p">(</span><span class="nx">sliceFn</span><span class="p">(</span><span class="nx">Elem</span><span class="p">){</span><span class="nx">s</span><span class="p">,</span> <span class="nx">f</span><span class="p">})</span>
<span class="p">}</span>
</pre></div>
</div>
<p>An example of calling this might be:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span>	<span class="kd">var</span> <span class="nx">s</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Person</span>
	<span class="c1">// ...</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nx">SliceFn</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span> <span class="o">*</span><span class="nx">Person</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">p1</span><span class="p">.</span><span class="nx">Name</span> <span class="p">&lt;</span> <span class="nx">p2</span><span class="p">.</span><span class="nx">Name</span> <span class="p">})</span>
</pre></div>
</div>
</div>
<div class="section" id="map-keys">
<h4>Map keys<a class="headerlink" href="#map-keys" title="Permalink to this headline">¶</a></h4>
<p>Here is how to get a slice of the keys of any map.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">maps</span>

<span class="c1">// Keys returns the keys of the map m.</span>
<span class="c1">// Note that map keys (here called type K) must be comparable.</span>
<span class="kd">func</span> <span class="nx">Keys</span><span class="p">(</span><span class="kd">type</span> <span class="nx">K</span><span class="p">,</span> <span class="nx">V</span> <span class="nx">comparable</span><span class="p">(</span><span class="nx">K</span><span class="p">))(</span><span class="nx">m</span> <span class="kd">map</span><span class="p">[</span><span class="nx">K</span><span class="p">]</span><span class="nx">V</span><span class="p">)</span> <span class="p">[]</span><span class="nx">K</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">K</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
		<span class="nx">r</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In typical use the types will be inferred.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span>	<span class="nx">k</span> <span class="o">:=</span> <span class="nx">maps</span><span class="p">.</span><span class="nx">Keys</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">})</span> <span class="c1">// sets k to []int{1, 2} (or {2, 1})</span>
</pre></div>
</div>
</div>
<div class="section" id="map-reduce-filter">
<h4>Map/Reduce/Filter<a class="headerlink" href="#map-reduce-filter" title="Permalink to this headline">¶</a></h4>
<p>Here is an example of how to write map, reduce, and filter functions
for slices.
These functions are intended to correspond to the similar functions in
Lisp, Python, Java, and so forth.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Package slices implements various slice algorithms.</span>
<span class="kn">package</span> <span class="nx">slices</span>

<span class="c1">// Map turns a []T1 to a []T2 using a mapping function.</span>
<span class="kd">func</span> <span class="nx">Map</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T1</span><span class="p">)</span> <span class="nx">T2</span><span class="p">)</span> <span class="p">[]</span><span class="nx">T2</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">T2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>

<span class="c1">// Reduce reduces a []T1 to a single value using a reduction function.</span>
<span class="kd">func</span> <span class="nx">Reduce</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">initializer</span> <span class="nx">T2</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T2</span><span class="p">,</span> <span class="nx">T1</span><span class="p">)</span> <span class="nx">T2</span><span class="p">)</span> <span class="nx">T2</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">initializer</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">r</span> <span class="p">=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>

<span class="c1">// Filter filters values from a slice using a filter function.</span>
<span class="kd">func</span> <span class="nx">Filter</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">[]</span><span class="nx">T</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">r</span> <span class="p">[]</span><span class="nx">T</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">f</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">r</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Example calls:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
	<span class="nx">floats</span> <span class="o">:=</span> <span class="nx">slices</span><span class="p">.</span><span class="nx">Map</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">})</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="nx">slices</span><span class="p">.</span><span class="nx">Reduce</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">i</span> <span class="o">+</span> <span class="nx">j</span> <span class="p">})</span>
	<span class="nx">evens</span> <span class="o">:=</span> <span class="nx">slices</span><span class="p">.</span><span class="nx">Filter</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">})</span>
</pre></div>
</div>
</div>
<div class="section" id="sets">
<h4>Sets<a class="headerlink" href="#sets" title="Permalink to this headline">¶</a></h4>
<p>Many people have asked for Go’s builtin map type to be extended, or
rather reduced, to support a set type.
Here is a type-safe implementation of a set type, albeit one that uses
methods rather than operators like <code class="docutils literal notranslate"><span class="pre">[]</span></code>.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Package set implements sets of any type.</span>
<span class="kn">package</span> <span class="nx">set</span>

<span class="kd">type</span> <span class="nx">Set</span><span class="p">(</span><span class="kd">type</span> <span class="nx">Elem</span> <span class="nx">comparable</span><span class="p">)</span> <span class="kd">map</span><span class="p">[</span><span class="nx">Elem</span><span class="p">]</span><span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="nx">Make</span><span class="p">(</span><span class="kd">type</span> <span class="nx">Elem</span> <span class="nx">comparable</span><span class="p">)()</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">Elem</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">make</span><span class="p">(</span><span class="nx">Set</span><span class="p">(</span><span class="nx">Elem</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">Elem</span><span class="p">))</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">v</span> <span class="nx">Elem</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">s</span><span class="p">[</span><span class="nx">v</span><span class="p">]</span> <span class="p">=</span> <span class="kd">struct</span><span class="p">{}{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">Elem</span><span class="p">))</span> <span class="nx">Delete</span><span class="p">(</span><span class="nx">v</span> <span class="nx">Elem</span><span class="p">)</span> <span class="p">{</span>
	<span class="nb">delete</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">Elem</span><span class="p">))</span> <span class="nx">Contains</span><span class="p">(</span><span class="nx">v</span> <span class="nx">Elem</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">v</span><span class="p">]</span>
	<span class="k">return</span> <span class="nx">ok</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">Elem</span><span class="p">))</span> <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">Elem</span><span class="p">))</span> <span class="nx">Iterate</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">Elem</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">f</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Example use:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">set</span><span class="p">.</span><span class="nx">Make</span><span class="p">(</span><span class="kt">int</span><span class="p">)()</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="nb">panic</span><span class="p">(</span><span class="s">&quot;unexpected 2&quot;</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>This example, like the sort examples above, show how to use this
design to provide a compile-time type-safe wrapper around an
existing API.</p>
</div>
<div class="section" id="channels">
<h4>Channels<a class="headerlink" href="#channels" title="Permalink to this headline">¶</a></h4>
<p>Many simple general purpose channel functions are never written,
because they must be written using reflection and the caller must type
assert the results.
With this design they become easy to write.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">chans</span>

<span class="kn">import</span> <span class="s">&quot;runtime&quot;</span>

<span class="c1">// Ranger returns a Sender and a Receiver. The Receiver provides a</span>
<span class="c1">// Next method to retrieve values. The Sender provides a Send method</span>
<span class="c1">// to send values and a Close method to stop sending values. The Next</span>
<span class="c1">// method indicates when the Sender has been closed, and the Send</span>
<span class="c1">// method indicates when the Receiver has been freed.</span>
<span class="c1">//</span>
<span class="c1">// This is a convenient way to exit a goroutine sending values when</span>
<span class="c1">// the receiver stops reading them.</span>
<span class="kd">func</span> <span class="nx">Ranger</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)()</span> <span class="p">(</span><span class="o">*</span><span class="nx">Sender</span><span class="p">(</span><span class="nx">T</span><span class="p">),</span> <span class="o">*</span><span class="nx">Receiver</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">T</span><span class="p">)</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Sender</span><span class="p">(</span><span class="nx">T</span><span class="p">){</span><span class="nx">values</span><span class="p">:</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">done</span><span class="p">:</span> <span class="nx">d</span><span class="p">}</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Receiver</span><span class="p">(</span><span class="nx">T</span><span class="p">){</span><span class="nx">values</span><span class="p">:</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">done</span><span class="p">:</span> <span class="nx">d</span><span class="p">}</span>
	<span class="nx">runtime</span><span class="p">.</span><span class="nx">SetFinalizer</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">finalize</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">r</span>
<span class="p">}</span>

<span class="c1">// A sender is used to send values to a Receiver.</span>
<span class="kd">type</span> <span class="nx">Sender</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">values</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">T</span>
	<span class="nx">done</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="c1">// Send sends a value to the receiver. It returns whether any more</span>
<span class="c1">// values may be sent; if it returns false the value was not sent.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Sender</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Send</span><span class="p">(</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">s</span><span class="p">.</span><span class="nx">values</span> <span class="o">&lt;-</span> <span class="nx">v</span><span class="p">:</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">s</span><span class="p">.</span><span class="nx">done</span><span class="p">:</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Close tells the receiver that no more values will arrive.</span>
<span class="c1">// After Close is called, the Sender may no longer be used.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Sender</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Close</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">values</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// A Receiver receives values from a Sender.</span>
<span class="kd">type</span> <span class="nx">Receiver</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">values</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">T</span>
	<span class="nx">done</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="c1">// Next returns the next value from the channel. The bool result</span>
<span class="c1">// indicates whether the value is valid, or whether the Sender has</span>
<span class="c1">// been closed and no more values will be received.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Receiver</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Next</span><span class="p">()</span> <span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">r</span><span class="p">.</span><span class="nx">values</span>
	<span class="k">return</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span>
<span class="p">}</span>

<span class="c1">// finalize is a finalizer for the receiver.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Receiver</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">finalize</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is an example of using this function in the next section.</p>
</div>
<div class="section" id="containers">
<h4>Containers<a class="headerlink" href="#containers" title="Permalink to this headline">¶</a></h4>
<p>One of the frequent requests for generics in Go is the ability to
write compile-time type-safe containers.
This design makes it easy to write a compile-time type-safe wrapper
around an existing container; we won’t write out an example for that.
This design also makes it easy to write a compile-time type-safe
container that does not use boxing.</p>
<p>Here is an example of an ordered map implemented as a binary tree.
The details of how it works are not too important.
The important points are:</p>
<ul class="simple">
<li><p>The code is written in a natural Go style, using the key and value
types where needed.</p></li>
<li><p>The keys and values are stored directly in the nodes of the tree,
not using pointers and not boxed as interface values.</p></li>
</ul>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Package orderedmap provides an ordered map, implemented as a binary tree.</span>
<span class="kn">package</span> <span class="nx">orderedmap</span>

<span class="kn">import</span> <span class="s">&quot;chans&quot;</span>

<span class="c1">// Map is an ordered map.</span>
<span class="kd">type</span> <span class="nx">Map</span><span class="p">(</span><span class="kd">type</span> <span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">root</span>    <span class="o">*</span><span class="nx">node</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">)</span>
	<span class="nx">compare</span> <span class="kd">func</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">K</span><span class="p">)</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="c1">// node is the type of a node in the binary tree.</span>
<span class="kd">type</span> <span class="nx">node</span><span class="p">(</span><span class="kd">type</span> <span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">key</span>         <span class="nx">K</span>
	<span class="nx">val</span>         <span class="nx">V</span>
	<span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="o">*</span><span class="nx">node</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// New returns a new map.</span>
<span class="kd">func</span> <span class="nx">New</span><span class="p">(</span><span class="kd">type</span> <span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">)(</span><span class="nx">compare</span> <span class="kd">func</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">K</span><span class="p">)</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Map</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Map</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">){</span><span class="nx">compare</span><span class="p">:</span> <span class="nx">compare</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// find looks up key in the map, and returns either a pointer</span>
<span class="c1">// to the node holding key, or a pointer to the location where</span>
<span class="c1">// such a node would go.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">))</span> <span class="nx">find</span><span class="p">(</span><span class="nx">key</span> <span class="nx">K</span><span class="p">)</span> <span class="o">**</span><span class="nx">node</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">pn</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">root</span>
	<span class="k">for</span> <span class="o">*</span><span class="nx">pn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="nx">cmp</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">compare</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="nx">pn</span><span class="p">).</span><span class="nx">key</span><span class="p">);</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">cmp</span> <span class="p">&lt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="nx">pn</span> <span class="p">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="nx">pn</span><span class="p">).</span><span class="nx">left</span>
		<span class="k">case</span> <span class="nx">cmp</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="nx">pn</span> <span class="p">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="nx">pn</span><span class="p">).</span><span class="nx">right</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="k">return</span> <span class="nx">pn</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">pn</span>
<span class="p">}</span>

<span class="c1">// Insert inserts a new key/value into the map.</span>
<span class="c1">// If the key is already present, the value is replaced.</span>
<span class="c1">// Returns true if this is a new key, false if already present.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">))</span> <span class="nx">Insert</span><span class="p">(</span><span class="nx">key</span> <span class="nx">K</span><span class="p">,</span> <span class="nx">val</span> <span class="nx">V</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">pn</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="k">if</span> <span class="o">*</span><span class="nx">pn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="p">(</span><span class="o">*</span><span class="nx">pn</span><span class="p">).</span><span class="nx">val</span> <span class="p">=</span> <span class="nx">val</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="nx">pn</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">node</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">){</span><span class="nx">key</span><span class="p">:</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">val</span><span class="p">:</span> <span class="nx">val</span><span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="c1">// Find returns the value associated with a key, or zero if not present.</span>
<span class="c1">// The found result reports whether the key was found.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">))</span> <span class="nx">Find</span><span class="p">(</span><span class="nx">key</span> <span class="nx">K</span><span class="p">)</span> <span class="p">(</span><span class="nx">V</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">pn</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="k">if</span> <span class="o">*</span><span class="nx">pn</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">zero</span> <span class="nx">V</span> <span class="c1">// see the discussion of zero values, above</span>
		<span class="k">return</span> <span class="nx">zero</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">pn</span><span class="p">).</span><span class="nx">val</span><span class="p">,</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="c1">// keyValue is a pair of key and value used when iterating.</span>
<span class="kd">type</span> <span class="nx">keyValue</span><span class="p">(</span><span class="kd">type</span> <span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">key</span> <span class="nx">K</span>
	<span class="nx">val</span> <span class="nx">V</span>
<span class="p">}</span>

<span class="c1">// InOrder returns an iterator that does an in-order traversal of the map.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">))</span> <span class="nx">InOrder</span><span class="p">()</span> <span class="o">*</span><span class="nx">Iterator</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">sender</span><span class="p">,</span> <span class="nx">receiver</span> <span class="o">:=</span> <span class="nx">chans</span><span class="p">.</span><span class="nx">Ranger</span><span class="p">(</span><span class="nx">keyValue</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">))()</span>
	<span class="kd">var</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">node</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">))</span> <span class="kt">bool</span>
	<span class="nx">f</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">))</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
		<span class="c1">// Stop sending values if sender.Send returns false,</span>
		<span class="c1">// meaning that nothing is listening at the receiver end.</span>
		<span class="k">return</span> <span class="nx">f</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="nx">sender</span><span class="p">.</span><span class="nx">Send</span><span class="p">(</span><span class="nx">keyValue</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">){</span><span class="nx">n</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">val</span><span class="p">})</span> <span class="o">&amp;&amp;</span>
			<span class="nx">f</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">f</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">root</span><span class="p">)</span>
		<span class="nx">sender</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
	<span class="p">}()</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Iterator</span><span class="p">{</span><span class="nx">receiver</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Iterator is used to iterate over the map.</span>
<span class="kd">type</span> <span class="nx">Iterator</span><span class="p">(</span><span class="kd">type</span> <span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">*</span><span class="nx">chans</span><span class="p">.</span><span class="nx">Receiver</span><span class="p">(</span><span class="nx">keyValue</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// Next returns the next key and value pair, and a boolean indicating</span>
<span class="c1">// whether they are valid or whether we have reached the end.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">it</span> <span class="o">*</span><span class="nx">Iterator</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">))</span> <span class="nx">Next</span><span class="p">()</span> <span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">keyval</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nx">Next</span><span class="p">()</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">zerok</span> <span class="nx">K</span>
		<span class="kd">var</span> <span class="nx">zerov</span> <span class="nx">V</span>
		<span class="k">return</span> <span class="nx">zerok</span><span class="p">,</span> <span class="nx">zerov</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">keyval</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">keyval</span><span class="p">.</span><span class="nx">val</span><span class="p">,</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is what it looks like to use this package:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="s">&quot;container/orderedmap&quot;</span>

<span class="kd">var</span> <span class="nx">m</span> <span class="p">=</span> <span class="nx">orderedmap</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">)(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Compare</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">.</span><span class="nx">Insert</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="append">
<h4>Append<a class="headerlink" href="#append" title="Permalink to this headline">¶</a></h4>
<p>The predeclared <code class="docutils literal notranslate"><span class="pre">append</span></code> function exists to replace the boilerplate
otherwise required to grow a slice.
Before <code class="docutils literal notranslate"><span class="pre">append</span></code> was added to the language, there was a function <code class="docutils literal notranslate"><span class="pre">Add</span></code>
in the bytes package with the signature</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">t</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span>
</pre></div>
</div>
<p>that appended two <code class="docutils literal notranslate"><span class="pre">[]byte</span></code> values together, returning a new slice.
That was fine for <code class="docutils literal notranslate"><span class="pre">[]byte</span></code>, but if you had a slice of some other
type, you had to write essentially the same code to append more
values.
If this design were available back then, perhaps we would not have
added <code class="docutils literal notranslate"><span class="pre">append</span></code> to the language.
Instead, we could write something like this:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">slices</span>

<span class="c1">// Append adds values to the end of a slice, returning a new slice.</span>
<span class="kd">func</span> <span class="nx">Append</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">t</span> <span class="o">...</span><span class="nx">T</span><span class="p">)</span> <span class="p">[]</span><span class="nx">T</span> <span class="p">{</span>
	<span class="nx">lens</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="nx">tot</span> <span class="o">:=</span> <span class="nx">lens</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">tot</span> <span class="o">&lt;=</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[:</span><span class="nx">tot</span><span class="p">]</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">news</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">tot</span><span class="p">,</span> <span class="nx">tot</span> <span class="o">+</span> <span class="nx">tot</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
		<span class="nb">copy</span><span class="p">(</span><span class="nx">news</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
		<span class="nx">s</span> <span class="p">=</span> <span class="nx">news</span>
	<span class="p">}</span>
	<span class="nb">copy</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">lens</span><span class="p">:</span><span class="nx">tot</span><span class="p">],</span> <span class="nx">t</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</pre></div>
</div>
<p>That example uses the predeclared <code class="docutils literal notranslate"><span class="pre">copy</span></code> function, but that’s OK, we
can write that one too:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Copy copies values from t to s, stopping when either slice is</span>
<span class="c1">// full, returning the number of values copied.</span>
<span class="kd">func</span> <span class="nx">Copy</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">t</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">t</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">i</span>
<span class="p">}</span>
</pre></div>
</div>
<p>These functions can be used as one would expect:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">slices</span><span class="p">.</span><span class="nx">Append</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
	<span class="nx">slices</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">3</span><span class="p">:],</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">})</span>
</pre></div>
</div>
<p>This code doesn’t implement the special case of appending or copying a
<code class="docutils literal notranslate"><span class="pre">string</span></code> to a <code class="docutils literal notranslate"><span class="pre">[]byte</span></code>, and it’s unlikely to be as efficient as the
implementation of the predeclared function.
Still, this example shows that using this design would permit append
and copy to be written generically, once, without requiring any
additional special language features.</p>
</div>
<div class="section" id="metrics">
<h4>Metrics<a class="headerlink" href="#metrics" title="Permalink to this headline">¶</a></h4>
<p>In a <a class="reference external" href="https://medium.com/&#64;sameer_74231/go-experience-report-for-generics-google-metrics-api-b019d597aaa4">Go experience
report</a>
Sameer Ajmani describes a metrics implementation.
Each metric has a value and one or more fields.
The fields have different types.
Defining a metric requires specifying the types of the fields, and
creating a value with an Add method.
The Add method takes the field types as arguments, and records an
instance of that set of fields.
The C++ implementation uses a variadic template.
The Java implementation includes the number of fields in the name of
the type.
Both the C++ and Java implementations provide compile-time type-safe
Add methods.</p>
<p>Here is how to use this design to provide similar functionality in
Go with a compile-time type-safe Add method.
Because there is no support for a variadic number of type arguments,
we must use different names for a different number of arguments, as in
Java.
This implementation only works for comparable types.
A more complex implementation could accept a comparison function to
work with arbitrary types.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">metrics</span>

<span class="kn">import</span> <span class="s">&quot;sync&quot;</span>

<span class="kd">type</span> <span class="nx">Metric1</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">comparable</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
	<span class="nx">m</span>  <span class="kd">map</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span><span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Metric1</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">m</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">m</span><span class="p">[</span><span class="nx">v</span><span class="p">]</span><span class="o">++</span>
<span class="p">}</span>

<span class="nx">contract</span> <span class="nx">cmp2</span><span class="p">(</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">comparable</span><span class="p">(</span><span class="nx">T1</span><span class="p">)</span>
	<span class="nx">comparable</span><span class="p">(</span><span class="nx">T2</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">key2</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span> <span class="nx">cmp2</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">f1</span> <span class="nx">T1</span>
	<span class="nx">f2</span> <span class="nx">T2</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Metric2</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span> <span class="nx">cmp2</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
	<span class="nx">m</span>  <span class="kd">map</span><span class="p">[</span><span class="nx">key2</span><span class="p">(</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">)]</span><span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Metric2</span><span class="p">(</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">))</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">v1</span> <span class="nx">T1</span><span class="p">,</span> <span class="nx">v2</span> <span class="nx">T2</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">m</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">key2</span><span class="p">(</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">)]</span><span class="kt">int</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">(</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">){</span><span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">}]</span><span class="o">++</span>
<span class="p">}</span>

<span class="nx">contract</span> <span class="nx">cmp3</span><span class="p">(</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">,</span> <span class="nx">T3</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">comparable</span><span class="p">(</span><span class="nx">T1</span><span class="p">)</span>
	<span class="nx">comparable</span><span class="p">(</span><span class="nx">T2</span><span class="p">)</span>
	<span class="nx">comparable</span><span class="p">(</span><span class="nx">T3</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">key3</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">,</span> <span class="nx">T3</span> <span class="nx">cmp3</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">f1</span> <span class="nx">T1</span>
	<span class="nx">f2</span> <span class="nx">T2</span>
	<span class="nx">f3</span> <span class="nx">T3</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Metric3</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">,</span> <span class="nx">T3</span> <span class="nx">cmp3</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
	<span class="nx">m</span>  <span class="kd">map</span><span class="p">[</span><span class="nx">key3</span><span class="p">(</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">,</span> <span class="nx">T3</span><span class="p">)]</span><span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Metric3</span><span class="p">(</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">,</span> <span class="nx">T3</span><span class="p">))</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">v1</span> <span class="nx">T1</span><span class="p">,</span> <span class="nx">v2</span> <span class="nx">T2</span><span class="p">,</span> <span class="nx">v3</span> <span class="nx">T3</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">m</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">key3</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">(</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">,</span> <span class="nx">T3</span><span class="p">){</span><span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">,</span> <span class="nx">v3</span><span class="p">}]</span><span class="o">++</span>
<span class="p">}</span>

<span class="c1">// Repeat for the maximum number of permitted arguments.</span>
</pre></div>
</div>
<p>Using this package looks like this:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="s">&quot;metrics&quot;</span>

<span class="kd">var</span> <span class="nx">m</span> <span class="p">=</span> <span class="nx">metrics</span><span class="p">.</span><span class="nx">Metric2</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">){}</span>

<span class="kd">func</span> <span class="nx">F</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="c1">// this call is type checked at compile time</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This package implementation has a certain amount of repetition due to
the lack of support for variadic package type parameters.
Using the package, though, is easy and type safe.</p>
</div>
<div class="section" id="list-transform">
<h4>List transform<a class="headerlink" href="#list-transform" title="Permalink to this headline">¶</a></h4>
<p>While slices are efficient and easy to use, there are occasional cases
where a linked list is appropriate.
This example primarily shows transforming a linked list of one type to
another type, as an example of using different instantiations of the
same parameterized type.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">list</span>

<span class="c1">// List is a linked list.</span>
<span class="kd">type</span> <span class="nx">List</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span> <span class="o">*</span><span class="nx">element</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// An element is an entry in a linked list.</span>
<span class="kd">type</span> <span class="nx">element</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">next</span> <span class="o">*</span><span class="nx">element</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span>
	<span class="nx">val</span>  <span class="nx">T</span>
<span class="p">}</span>

<span class="c1">// Push pushes an element to the end of the list.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">lst</span> <span class="o">*</span><span class="nx">List</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Push</span><span class="p">(</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">lst</span><span class="p">.</span><span class="nx">tail</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">lst</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">element</span><span class="p">(</span><span class="nx">T</span><span class="p">){</span><span class="nx">val</span><span class="p">:</span> <span class="nx">v</span><span class="p">}</span>
		<span class="nx">lst</span><span class="p">.</span><span class="nx">tail</span> <span class="p">=</span> <span class="nx">lst</span><span class="p">.</span><span class="nx">head</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">lst</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">element</span><span class="p">(</span><span class="nx">T</span><span class="p">){</span><span class="nx">val</span><span class="p">:</span> <span class="nx">v</span> <span class="p">}</span>
		<span class="nx">lst</span><span class="p">.</span><span class="nx">tail</span> <span class="p">=</span> <span class="nx">lst</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nx">next</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Iterator ranges over a list.</span>
<span class="kd">type</span> <span class="nx">Iterator</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">next</span> <span class="o">**</span><span class="nx">element</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Range returns an Iterator starting at the head of the list.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">lst</span> <span class="o">*</span><span class="nx">List</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Range</span><span class="p">()</span> <span class="o">*</span><span class="nx">Iterator</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">Iterator</span><span class="p">(</span><span class="nx">T</span><span class="p">){</span><span class="nx">next</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">lst</span><span class="p">.</span><span class="nx">head</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Next advances the iterator.</span>
<span class="c1">// It returns whether there are more elements.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">it</span> <span class="o">*</span><span class="nx">Iterator</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Next</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="o">*</span><span class="nx">it</span><span class="p">.</span><span class="nx">next</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">it</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">).</span><span class="nx">next</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="c1">// Val returns the value of the current element.</span>
<span class="c1">// The bool result reports whether the value is valid.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">it</span> <span class="o">*</span><span class="nx">Iterator</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Val</span><span class="p">()</span> <span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="o">*</span><span class="nx">it</span><span class="p">.</span><span class="nx">next</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">zero</span> <span class="nx">T</span>
		<span class="k">return</span> <span class="nx">zero</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">).</span><span class="nx">val</span><span class="p">,</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="c1">// Transform runs a transform function on a list returning a new list.</span>
<span class="kd">func</span> <span class="nx">Transform</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">)(</span><span class="nx">lst</span> <span class="o">*</span><span class="nx">List</span><span class="p">(</span><span class="nx">T1</span><span class="p">),</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T1</span><span class="p">)</span> <span class="nx">T2</span><span class="p">)</span> <span class="o">*</span><span class="nx">List</span><span class="p">(</span><span class="nx">T2</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">List</span><span class="p">(</span><span class="nx">T2</span><span class="p">){}</span>
	<span class="nx">it</span> <span class="o">:=</span> <span class="nx">lst</span><span class="p">.</span><span class="nx">Range</span><span class="p">()</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">Val</span><span class="p">();</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="nx">ret</span><span class="p">.</span><span class="nx">Push</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="nx">it</span><span class="p">.</span><span class="nx">Next</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="context">
<h4>Context<a class="headerlink" href="#context" title="Permalink to this headline">¶</a></h4>
<p>The standard “context” package provides a <code class="docutils literal notranslate"><span class="pre">Context.Value</span></code> method to
fetch a value from a context.
The method returns <code class="docutils literal notranslate"><span class="pre">interface{}</span></code>, so using it normally requires a type
assertion to the correct type.
Here is an example of how we can add type parameters to the “context”
package to provide a type-safe wrapper around <code class="docutils literal notranslate"><span class="pre">Context.Value</span></code>.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Key is a key that can be used with Context.Value.</span>
<span class="c1">// Rather than calling Context.Value directly, use Key.Load.</span>
<span class="c1">//</span>
<span class="c1">// The zero value of Key is not ready for use; use NewKey.</span>
<span class="kd">type</span> <span class="nx">Key</span><span class="p">(</span><span class="kd">type</span> <span class="nx">V</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// NewKey returns a key used to store values of type V in a Context.</span>
<span class="c1">// Every Key returned is unique, even if the name is reused.</span>
<span class="kd">func</span> <span class="nx">NewKey</span><span class="p">(</span><span class="kd">type</span> <span class="nx">V</span><span class="p">)(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Key</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Key</span><span class="p">(</span><span class="nx">V</span><span class="p">){</span><span class="nx">name</span><span class="p">:</span> <span class="nx">name</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// WithValue returns a new context with v associated with k.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">k</span> <span class="o">*</span><span class="nx">Key</span><span class="p">(</span><span class="nx">V</span><span class="p">))</span> <span class="nx">WithValue</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">v</span> <span class="nx">V</span><span class="p">)</span> <span class="nx">Context</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">WithValue</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Value loads the value associated with k from ctx and reports</span>
<span class="c1">//whether it was successful.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">k</span> <span class="o">*</span><span class="nx">Key</span><span class="p">(</span><span class="nx">V</span><span class="p">))</span> <span class="nx">Value</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">V</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">v</span><span class="p">,</span> <span class="nx">present</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">Value</span><span class="p">(</span><span class="nx">k</span><span class="p">).(</span><span class="nx">V</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">v</span><span class="p">.(</span><span class="nx">V</span><span class="p">),</span> <span class="nx">present</span>
<span class="p">}</span>

<span class="c1">// String returns the name and expected value type.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">k</span> <span class="o">*</span><span class="nx">Key</span><span class="p">(</span><span class="nx">V</span><span class="p">))</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">v</span> <span class="nx">V</span>
	<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%s(%T)&quot;</span><span class="p">,</span> <span class="nx">k</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To see how this might be used, consider the net/http package’s
<code class="docutils literal notranslate"><span class="pre">ServerContextKey</span></code>:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">ServerContextKey</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">contextKey</span><span class="p">{</span><span class="s">&quot;http-server&quot;</span><span class="p">}</span>

	<span class="c1">// used as:</span>
	<span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Value</span><span class="p">(</span><span class="nx">ServerContextKey</span><span class="p">,</span> <span class="nx">srv</span><span class="p">)</span>
	<span class="nx">s</span><span class="p">,</span> <span class="nx">present</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">Value</span><span class="p">(</span><span class="nx">ServerContextKey</span><span class="p">).(</span><span class="o">*</span><span class="nx">Server</span><span class="p">)</span>
</pre></div>
</div>
<p>This could be written instead as</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">ServerContextKey</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nx">NewKey</span><span class="p">(</span><span class="o">*</span><span class="nx">Server</span><span class="p">)(</span><span class="s">&quot;http_server&quot;</span><span class="p">)</span>

	<span class="c1">// used as:</span>
	<span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">ServerContextKey</span><span class="p">.</span><span class="nx">WithValue</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">srv</span><span class="p">)</span>
	<span class="nx">s</span><span class="p">,</span> <span class="nx">present</span> <span class="o">:=</span> <span class="nx">ServerContextKey</span><span class="p">.</span><span class="nx">Value</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
</pre></div>
</div>
<p>Code that uses <code class="docutils literal notranslate"><span class="pre">Key.WithValue</span></code> and <code class="docutils literal notranslate"><span class="pre">Key.Value</span></code> instead of
<code class="docutils literal notranslate"><span class="pre">context.WithValue</span></code> and <code class="docutils literal notranslate"><span class="pre">context.Value</span></code> does not need any type
assertions and is compile-time type-safe.</p>
</div>
<div class="section" id="dot-product">
<h4>Dot product<a class="headerlink" href="#dot-product" title="Permalink to this headline">¶</a></h4>
<p>A generic dot product implementation that works for slices of any
numeric type.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Numeric is a contract that matches any numeric type.</span>
<span class="c1">// It would likely be in a contracts package in the standard library.</span>
<span class="nx">contract</span> <span class="nx">Numeric</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">T</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int8</span><span class="p">,</span> <span class="kt">int16</span><span class="p">,</span> <span class="kt">int32</span><span class="p">,</span> <span class="kt">int64</span><span class="p">,</span>
		<span class="kt">uint</span><span class="p">,</span> <span class="kt">uint8</span><span class="p">,</span> <span class="kt">uint16</span><span class="p">,</span> <span class="kt">uint32</span><span class="p">,</span> <span class="kt">uint64</span><span class="p">,</span> <span class="kt">uintptr</span><span class="p">,</span>
		<span class="kt">float32</span><span class="p">,</span> <span class="kt">float64</span><span class="p">,</span>
		<span class="kt">complex64</span><span class="p">,</span> <span class="kt">complex128</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">DotProduct</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">Numeric</span><span class="p">)(</span><span class="nx">s1</span><span class="p">,</span> <span class="nx">s2</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s2</span><span class="p">)</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&quot;DotProduct: slices of unequal length&quot;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">r</span> <span class="nx">T</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s1</span> <span class="p">{</span>
		<span class="nx">r</span> <span class="o">+=</span> <span class="nx">s1</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">*</span> <span class="nx">s2</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="absolute-difference">
<h4>Absolute difference<a class="headerlink" href="#absolute-difference" title="Permalink to this headline">¶</a></h4>
<p>Compute the absolute difference between two numeric values, by using
an <code class="docutils literal notranslate"><span class="pre">Abs</span></code> method.
This uses the same <code class="docutils literal notranslate"><span class="pre">Numeric</span></code> contract defined in the last example.</p>
<p>This example uses more machinery than is appropriate for the simple
case of computing the absolute difference.
It is intended to show how the common part of algorithms can be
factored into code that uses methods, where the exact definition of
the methods can very based on the kind of type being used.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// NumericAbs matches numeric types with an Abs method.</span>
<span class="nx">contract</span> <span class="nx">NumericAbs</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">Numeric</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span>
	<span class="nx">T</span> <span class="nx">Abs</span><span class="p">()</span> <span class="nx">T</span>
<span class="p">}</span>

<span class="c1">// AbsDifference computes the absolute value of the difference of</span>
<span class="c1">// a and b, where the absolute value is determined by the Abs method.</span>
<span class="kd">func</span> <span class="nx">AbsDifference</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">NumericAbs</span><span class="p">)(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span>
	<span class="k">return</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Abs</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can define an <code class="docutils literal notranslate"><span class="pre">Abs</span></code> method appropriate for different numeric types.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// OrderedNumeric matches numeric types that support the &lt; operator.</span>
<span class="nx">contract</span> <span class="nx">OrderedNumeric</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">T</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int8</span><span class="p">,</span> <span class="kt">int16</span><span class="p">,</span> <span class="kt">int32</span><span class="p">,</span> <span class="kt">int64</span><span class="p">,</span>
		<span class="kt">uint</span><span class="p">,</span> <span class="kt">uint8</span><span class="p">,</span> <span class="kt">uint16</span><span class="p">,</span> <span class="kt">uint32</span><span class="p">,</span> <span class="kt">uint64</span><span class="p">,</span> <span class="kt">uintptr</span><span class="p">,</span>
		<span class="kt">float32</span><span class="p">,</span> <span class="kt">float64</span>
<span class="p">}</span>

<span class="c1">// Complex matches the two complex types, which do not have a &lt; operator.</span>
<span class="nx">contract</span> <span class="nx">Complex</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">T</span> <span class="kt">complex64</span><span class="p">,</span> <span class="kt">complex128</span>
<span class="p">}</span>

<span class="c1">// OrderedAbs is a helper type that defines an Abs method for</span>
<span class="c1">// ordered numeric types.</span>
<span class="kd">type</span> <span class="nx">OrderedAbs</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">OrderedNumeric</span><span class="p">)</span> <span class="nx">T</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="nx">OrderedAbs</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Abs</span><span class="p">()</span> <span class="nx">OrderedAbs</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">a</span>
<span class="p">}</span>

<span class="c1">// ComplexAbs is a helper type that defines an Abs method for</span>
<span class="c1">// complex types.</span>
<span class="kd">type</span> <span class="nx">ComplexAbs</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">Complex</span><span class="p">)</span> <span class="nx">T</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="nx">ComplexAbs</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Abs</span><span class="p">()</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nb">real</span><span class="p">(</span><span class="nx">a</span><span class="p">))</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nb">imag</span><span class="p">(</span><span class="nx">a</span><span class="p">))</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sqrt</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span> <span class="nx">r</span> <span class="o">+</span> <span class="nx">i</span> <span class="o">*</span> <span class="nx">i</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">T</span><span class="p">(</span><span class="nb">complex</span><span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can then define functions that do the work for the caller by
converting to and from the types we just defined.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">OrderedAbsDifference</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">OrderedNumeric</span><span class="p">)(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">T</span><span class="p">(</span><span class="nx">AbsDifference</span><span class="p">(</span><span class="nx">OrderedAbs</span><span class="p">(</span><span class="nx">T</span><span class="p">)(</span><span class="nx">a</span><span class="p">),</span> <span class="nx">OrderedAbs</span><span class="p">(</span><span class="nx">T</span><span class="p">)(</span><span class="nx">b</span><span class="p">)))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">ComplexAbsDifference</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">Complex</span><span class="p">)(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">T</span><span class="p">(</span><span class="nx">AbsDifference</span><span class="p">(</span><span class="nx">ComplexAbs</span><span class="p">(</span><span class="nx">T</span><span class="p">)(</span><span class="nx">a</span><span class="p">),</span> <span class="nx">ComplexAbs</span><span class="p">(</span><span class="nx">T</span><span class="p">)(</span><span class="nx">b</span><span class="p">)))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It’s worth noting that this design is not powerful enough to write
code like the following:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// This function is INVALID.</span>
<span class="kd">func</span> <span class="nx">GeneralAbsDifference</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">Numeric</span><span class="p">)(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">a</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int8</span><span class="p">,</span> <span class="kt">int16</span><span class="p">,</span> <span class="kt">int32</span><span class="p">,</span> <span class="kt">int64</span><span class="p">,</span>
		<span class="kt">uint</span><span class="p">,</span> <span class="kt">uint8</span><span class="p">,</span> <span class="kt">uint16</span><span class="p">,</span> <span class="kt">uint32</span><span class="p">,</span> <span class="kt">uint64</span><span class="p">,</span> <span class="kt">uintptr</span><span class="p">,</span>
		<span class="kt">float32</span><span class="p">,</span> <span class="kt">float64</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">OrderedAbsDifference</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="c1">// INVALID</span>
	<span class="k">case</span> <span class="kt">complex64</span><span class="p">,</span> <span class="kt">complex128</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">ComplexAbsDifference</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="c1">// INVALID</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The calls to <code class="docutils literal notranslate"><span class="pre">OrderedAbsDifference</span></code> and <code class="docutils literal notranslate"><span class="pre">ComplexAbsDifference</span></code> are
invalid, because not all the types that satisfy the <code class="docutils literal notranslate"><span class="pre">Numeric</span></code> contract
can satisfy the <code class="docutils literal notranslate"><span class="pre">OrderedNumeric</span></code> or <code class="docutils literal notranslate"><span class="pre">Complex</span></code> contracts.
Although the type switch means that this code would conceptually work
at run time, there is no support for writing this code at compile
time.
This another of way of expressing one of the omissions listed above:
this design does not provide for specialization.</p>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="go2draft-error-handling.html" class="btn btn-neutral float-right" title="Error Handling — Draft Design" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="go2draft.html" class="btn btn-neutral float-left" title="Go 2 Draft Designs" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>