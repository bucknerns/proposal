

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Proposal: Make 64-bit fields be 64-bit aligned on 32-bit systems, add //go:packed, //go:align directives &mdash; Go Design Proposal  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Proposal: API for unstable runtime metrics" href="37112-unstable-runtime-metrics.html" />
    <link rel="prev" title="Proposal: Lazy Module Loading" href="36460-lazy-module-loading.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Go Design Proposal
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="11502-securitypolicy.html">Proposal: Security Policy for Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="11970-decentralized-gc.html">Proposal: Decentralized GC coordination</a></li>
<li class="toctree-l1"><a class="reference internal" href="12166-subtests.html">Proposal: testing: programmatic sub-test and sub-benchmark support</a></li>
<li class="toctree-l1"><a class="reference internal" href="12302-release-proposal.html">Proposal: A minimal release process for Go repositories</a></li>
<li class="toctree-l1"><a class="reference internal" href="12416-cgo-pointers.html">Proposal: Rules for passing pointers between Go and C</a></li>
<li class="toctree-l1"><a class="reference internal" href="12750-localization.html">Proposal: Localization support in Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="12800-sweep-free-alloc.html">Proposal: Dense mark bits and sweep-free allocation</a></li>
<li class="toctree-l1"><a class="reference internal" href="12914-monotonic.html">Proposal: Monotonic Elapsed Time Measurements in Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="12914-monotonic.html#appendix-time-now-usage">Appendix: time.Now usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="13073-code-of-conduct.html">Proposal: A Code of Conduct for the Go community</a></li>
<li class="toctree-l1"><a class="reference internal" href="13432-mobile-audio.html">Proposal: Audio for Mobile</a></li>
<li class="toctree-l1"><a class="reference internal" href="13504-natural-xml.html">Proposal: Natural XML</a></li>
<li class="toctree-l1"><a class="reference internal" href="14313-benchmark-format.html">Proposal: Go Benchmark Data Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="14386-zip-package-archives.html">Proposal: Zip-based Go package archives</a></li>
<li class="toctree-l1"><a class="reference internal" href="14951-soft-heap-limit.html">Proposal: Separate soft and hard heap size goal</a></li>
<li class="toctree-l1"><a class="reference internal" href="15292-generics.html">Proposal: Go should have generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="16085-conversions-ignore-tags.html">Proposal: Ignore tags in struct type conversions</a></li>
<li class="toctree-l1"><a class="reference internal" href="16339-alias-decls.html">Proposal: Alias declarations for Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="16339-alias-decls.html#appendix">Appendix</a></li>
<li class="toctree-l1"><a class="reference internal" href="16410-heap-viewer.html">Proposal: Go Heap Dump Viewer</a></li>
<li class="toctree-l1"><a class="reference internal" href="16704-cidr-notation-no-proxy.html">Proposal: Add support for CIDR notation in no_proxy variable</a></li>
<li class="toctree-l1"><a class="reference internal" href="17280-profile-labels.html">Proposal: Support for pprof profiler labels</a></li>
<li class="toctree-l1"><a class="reference internal" href="17503-eliminate-rescan.html">Proposal: Eliminate STW stack re-scanning</a></li>
<li class="toctree-l1"><a class="reference internal" href="17505-concurrent-rescan.html">Proposal: Concurrent stack re-scanning</a></li>
<li class="toctree-l1"><a class="reference internal" href="18130-type-alias.html">Proposal: Type Aliases</a></li>
<li class="toctree-l1"><a class="reference internal" href="18802-percpu-sharded.html">Proposal: percpu.Sharded, an API for reducing cache contention</a></li>
<li class="toctree-l1"><a class="reference internal" href="18802-percpu-sharded.html#discussion">Discussion</a></li>
<li class="toctree-l1"><a class="reference internal" href="18802-percpu-sharded.html#backwards-compatibility">Backwards compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="19113-signed-shift-counts.html">Proposal: Permit Signed Integers as Shift Counts for Go 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="19308-number-literals.html">Proposal: Go 2 Number Literal Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html">Proposal: Mid-stack inlining in the Go compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#abstract">Abstract</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#background">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#proposal">Proposal</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#rationale">Rationale</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#compatibility">Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#implementation">Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#prerequisite-changes">Prerequisite Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#preliminary-results">Preliminary Results</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#open-issues">Open issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="19480-xml-stream.html">Proposal: XML Stream</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html">Proposal: emit DWARF inlining info in the Go compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#abstract">Abstract</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#background">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#example">Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#how-the-generated-dwarf-should-look">How the generated DWARF should look</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#outline-of-proposed-changes">Outline of proposed changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#compatibility">Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#implementation">Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#prerequisite-changes">Prerequisite Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#preliminary-results">Preliminary Results</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#open-issues">Open issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="24301-versioned-go.html">Proposal: Versioned Go Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="24543-non-cooperative-preemption.html">Proposal: Non-cooperative goroutine preemption</a></li>
<li class="toctree-l1"><a class="reference internal" href="25530-sumdb.html">Proposal: Secure the Public Go Module Ecosystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="25719-go15vendor.html">Go 1.5 Vendor Experiment</a></li>
<li class="toctree-l1"><a class="reference internal" href="26160-dns-based-vanity-imports.html">Proposal: DNS Based Vanity Imports</a></li>
<li class="toctree-l1"><a class="reference internal" href="26756-rawxml-token.html">Proposal: Raw XML Token</a></li>
<li class="toctree-l1"><a class="reference internal" href="26903-simplify-mark-termination.html">Proposal: Simplify mark termination and eliminate mark 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="27539-internal-abi.html">Proposal: Create an undefined internal calling convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="2775-binary-only-packages.html">Proposal: Binary-Only Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="27935-unbounded-queue-package.html">Proposal: Built in support for high performance unbounded queue</a></li>
<li class="toctree-l1"><a class="reference internal" href="28221-go2-transitions.html">Proposal: Go 2 transition</a></li>
<li class="toctree-l1"><a class="reference internal" href="2981-go-test-json.html">Proposal: <code class="docutils literal notranslate"><span class="pre">-json</span></code> flag in <code class="docutils literal notranslate"><span class="pre">go</span> <span class="pre">test</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="29934-error-values.html">Proposal: Go 2 Error Inspection</a></li>
<li class="toctree-l1"><a class="reference internal" href="30333-smarter-scavenging.html">Proposal: Smarter Scavenging</a></li>
<li class="toctree-l1"><a class="reference internal" href="30411-env.html">Proposal: <code class="docutils literal notranslate"><span class="pre">go</span></code> command configuration file</a></li>
<li class="toctree-l1"><a class="reference internal" href="32437-try-builtin.html">Proposal: A built-in Go error check function, <code class="docutils literal notranslate"><span class="pre">try</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="33974-add-public-lockedfile-pkg.html">Proposal: make the internal lockedfile package public</a></li>
<li class="toctree-l1"><a class="reference internal" href="34481-opencoded-defers.html">Proposal: Low-cost defers through inline code, and extra funcdata to manage the panic case</a></li>
<li class="toctree-l1"><a class="reference internal" href="35112-scaling-the-page-allocator.html">Proposal: Scaling the Go page allocator</a></li>
<li class="toctree-l1"><a class="reference internal" href="36460-lazy-module-loading.html">Proposal: Lazy Module Loading</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Proposal: Make 64-bit fields be 64-bit aligned on 32-bit systems, add //go:packed, //go:align directives</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#abstract">Abstract</a></li>
<li class="toctree-l2"><a class="reference internal" href="#background">Background</a></li>
<li class="toctree-l2"><a class="reference internal" href="#proposal">Proposal</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#alignment-changes">Alignment changes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#addition-of-a-go-packed-directive">Addition of a <code class="docutils literal notranslate"><span class="pre">//go:packed</span></code> directive</a></li>
<li class="toctree-l3"><a class="reference internal" href="#addition-of-a-go-align-directive">Addition of a <code class="docutils literal notranslate"><span class="pre">//go:align</span></code> directive</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vet-and-compiler-checks">Vet and compiler checks</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#alternate-proposals">Alternate proposals</a></li>
<li class="toctree-l2"><a class="reference internal" href="#alternate-syntax">Alternate syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="#compatibility">Compatibility</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implementation">Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#open-issues">Open Issues</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="37112-unstable-runtime-metrics.html">Proposal: API for unstable runtime metrics</a></li>
<li class="toctree-l1"><a class="reference internal" href="37720-gopls-workspaces.html">Proposal: Multi-project gopls workspaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="4899-testing-helper.html">Proposal: testing: better support test helper functions with TB.Helper</a></li>
<li class="toctree-l1"><a class="reference internal" href="6282-table-data.html">Proposal: Multi-dimensional slices</a></li>
<li class="toctree-l1"><a class="reference internal" href="6977-overlapping-interfaces.html">Proposal: Permit embedding of interfaces with overlapping method sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="TEMPLATE.html">Proposal: [Title]</a></li>
<li class="toctree-l1"><a class="reference internal" href="cryptography-principles.html">Cryptography Principles</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft.html">Go 2 Draft Designs</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-contracts.html">Contracts — Draft Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-handling.html">Error Handling — Draft Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-handling-overview.html">Error Handling — Problem Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-inspection.html">Error Inspection — Draft Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-printing.html">Error Printing — Draft Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-values-overview.html">Error Values — Problem Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-generics-overview.html">Generics — Problem Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-type-parameters.html">Type Parameters - Draft Design</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Go Design Proposal</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Proposal: Make 64-bit fields be 64-bit aligned on 32-bit systems, add //go:packed, //go:align directives</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/36606-64-bit-field-alignment.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="proposal-make-64-bit-fields-be-64-bit-aligned-on-32-bit-systems-add-go-packed-go-align-directives">
<h1>Proposal: Make 64-bit fields be 64-bit aligned on 32-bit systems, add //go:packed, //go:align directives<a class="headerlink" href="#proposal-make-64-bit-fields-be-64-bit-aligned-on-32-bit-systems-add-go-packed-go-align-directives" title="Permalink to this headline">¶</a></h1>
<p>Author(s): Dan Scales (with input from many others)</p>
<p>Last updated: 2020-06-08</p>
<p>Initial proposal and discussion at:  https://github.com/golang/go/issues/36606</p>
<div class="section" id="abstract">
<h2>Abstract<a class="headerlink" href="#abstract" title="Permalink to this headline">¶</a></h2>
<p>We propose to change the default layout of structs on 32-bit systems such that
64-bit fields will be 8-byte (64-bit) aligned. The layout of structs on 64-bit systems
will not change. For compatibility reasons (and finer control of struct layout),
we also propose the addition of a <code class="docutils literal notranslate"><span class="pre">//go:packed</span></code> directive that applies to struct
types. When the <code class="docutils literal notranslate"><span class="pre">//go:packed</span></code> directive is specified immediately before a struct
type, then that struct will have a fully-packed layout, where fields are placed
in order with no padding between them and hence no alignment based on types. The
developer must explicitly add padding to enforce any desired alignment.  We also
propose the addition of a <code class="docutils literal notranslate"><span class="pre">//go:align</span></code> directive that applies to all types.  It
sets the required alignment in bytes for the associated type.  This directive
will be useful in general, but specifically can be used to set the required
alignment for packed structs.</p>
</div>
<div class="section" id="background">
<h2>Background<a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h2>
<p>Currently, each Go type has a required alignment in bytes.
This alignment is used for setting the alignment for any
variable of the associated type (whether global variable, local variable,
argument, return value, or heap allocation) or a field of the associated type in
a struct. The actual alignments are implementation-dependent.  In gc, the alignment
can be 1, 2, 4, or 8 bytes.  The alignment determination is fairly straightforward,
and mostly encapsulated in the functions <code class="docutils literal notranslate"><span class="pre">gc.dowidth()</span></code> and <code class="docutils literal notranslate"><span class="pre">gc.widstruct()</span></code> in
<code class="docutils literal notranslate"><span class="pre">cmd/compile/internal/gc/align.go</span></code>.  gccgo and GoLLVM have slightly different alignments
for some types.  This proposal is focused on the alignments used in gc.</p>
<p>The alignment rules differ slightly between 64-bit and 32-bit systems. Of
course, certain types (such as pointers and integers) have different sizes
and hence different alignments. The main other difference is the treatment of
64-bit basic types such as <code class="docutils literal notranslate"><span class="pre">int64</span></code>, <code class="docutils literal notranslate"><span class="pre">uint64</span></code>, and <code class="docutils literal notranslate"><span class="pre">float64</span></code>. On 64-bit systems, the
alignment of 64-bit basic types is 8 bytes (64 bits), while on 32-bit systems,
the alignment of these types is 4 bytes (32 bits). This means that fields in a
struct on a 32-bit system that have a 64-bit basic type may be aligned only to 4
bytes, rather than to 8 bytes.</p>
<p>There are a few more alignment rules for global variables and heap-allocated
locations. Any heap-allocated type that is 8 bytes or more is always aligned on
an 8-byte boundary, even on 32-bit systems (see <code class="docutils literal notranslate"><span class="pre">runtime.mallocgc</span></code>).
Any global variable which is a
64-bit base type or is a struct also always is aligned on 8 bytes (even on
32-bit systems). Hence, the above alignment difference for 64-bit base types
between 64-bit and 32-bit systems really only occurs for fields in a struct and
for stack variables (including arguments and return values).</p>
<p>The main goal of this change is to avoid the bugs that frequently happen on
32-bit systems, where a developer wants to be able to do 64-bit operations (such
as an atomic operation) on a 64-bit field, but gets an alignment error because
the field is not 8-byte aligned. With the current struct layout rules (based on
the current type alignment rules), a developer must often add explicit padding
in order to make sure that such a 64-bit field is on a 8-byte boundary. As shown
by repeated mentions in issue <a class="reference external" href="https://github.com/golang/go/issues/599">#599</a>
(18 in 2019 alone), developers still often run into this problem. They may only
run into it late in the development cycle as they are testing on 32-bit
architectures, or when they execute an uncommon code path that requires the
alignment.</p>
<p>As an example, the struct for ticks in <code class="docutils literal notranslate"><span class="pre">runtime/runtime.go</span></code> is declared as</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">ticks</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lock</span> <span class="nx">mutex</span>
	<span class="nx">pad</span>  <span class="kt">uint32</span> <span class="c1">// ensure 8-byte alignment of val on 386</span>
	<span class="nx">val</span>  <span class="kt">uint64</span>
<span class="p">}</span>
</pre></div>
</div>
<p>so that the <code class="docutils literal notranslate"><span class="pre">val</span></code> field is properly aligned on 32-bit architectures.</p>
<p>Note that there can also be alignment issues with stack variables which have
64-bit base types, but it seems less likely that a program would be using a local
variable for 64-bit operations such as atomic operations.</p>
<p>There are related reasons why a developer might want to explicitly control the
alignment of a specific type (possibly to an alignment even great than 8 bytes),
as detailed in issue <a class="reference external" href="https://github.com/golang/go/issues/19057">#19057</a>. As
mentioned in that issue, “on x86 there are vector instructions that require
alignment to 16 bytes, and there are even some instructions (e.g., vmovaps with
VEC.256), that require 32 byte alignment.” It is also possible that a developer
might want to force alignment of a type to be on a cache line boundary, to
improve locality and avoid false sharing (e.g. see <code class="docutils literal notranslate"><span class="pre">cpu.CacheLinePad</span></code> in the
<code class="docutils literal notranslate"><span class="pre">runtime</span></code> package sources). Cache line sizes typically range from
32 to 128 bytes.</p>
</div>
<div class="section" id="proposal">
<h2>Proposal<a class="headerlink" href="#proposal" title="Permalink to this headline">¶</a></h2>
<p>This proposal consists of a proposed change to the default alignment rules on 32-bit systems,
a new <code class="docutils literal notranslate"><span class="pre">//go:packed</span></code> directive, and a new <code class="docutils literal notranslate"><span class="pre">//go:align</span></code> directive.  We describe each in a
separate sub-section.</p>
<div class="section" id="alignment-changes">
<h3>Alignment changes<a class="headerlink" href="#alignment-changes" title="Permalink to this headline">¶</a></h3>
<p>The main part of our proposal is the following:</p>
<ul class="simple">
<li><p>We change the default alignment of 64-bit fields in structs on 32-bit systems
from 4 bytes to 8 bytes</p></li>
<li><p>We do not change the alignment of 64-bit base types otherwise (i.e. for stack
variables, global variables, or heap allocations)</p></li>
</ul>
<p>Since the alignment of a struct is based on the maximum alignment of any field
in the struct, this change will also change the overall alignment of certain
structs on 32-bit systems from 4 to 8 bytes.</p>
<p>It is important that we do not change the alignment of stack variables
(particular arguments and return values), since changing their alignment would
directly change the Go calling ABI.  (As we’ll note below, we are still
changing the ABI in a minor way, since we are changing the layout and possibly
the size of some structs that could be passed as arguments and return values.)</p>
<p>As mentioned above, 64-bit basic types are already aligned to 8 bytes
(based on other rules) for global variables or heap allocations.  Therefore, we
do not usually run into alignment problems for 64-bit basic types on 32-bit
systems when they are simple global variables or heap allocations.</p>
<p>One way to think about this change is that each type has two alignment
properties, analogous to the <code class="docutils literal notranslate"><span class="pre">Type.FieldAlign()</span></code> and <code class="docutils literal notranslate"><span class="pre">Type.Align()</span></code>
methods in the <code class="docutils literal notranslate"><span class="pre">reflect</span></code> package. The first property specifies
the alignment when that type
occurs as a field in a struct. The second property specifies the
alignment when that type is used in any other situation, including stack
variables, global variables, and heap allocations. For almost all types, the
field alignment and the “other” alignment of each type will be equal to each
other and the same as it is today. However, in this proposal, 64-bit basic types
(<code class="docutils literal notranslate"><span class="pre">int64</span></code>, <code class="docutils literal notranslate"><span class="pre">uint64</span></code>, and <code class="docutils literal notranslate"><span class="pre">float64</span></code>) on 32-bit system will have a field alignment of 8
bytes, but keep an “other” alignment of 4 bytes.  As we mentioned, structs that
contain 64-bit basic types on 32-bit systems may have 8-byte alignment now where
previously they had 4-byte alignment; however, both their field alignment and
their “other” alignment would have this new value.</p>
</div>
<div class="section" id="addition-of-a-go-packed-directive">
<h3>Addition of a <code class="docutils literal notranslate"><span class="pre">//go:packed</span></code> directive<a class="headerlink" href="#addition-of-a-go-packed-directive" title="Permalink to this headline">¶</a></h3>
<p>We make the above proposed change in order to reduce the kind of bugs detailed in issue
<a class="reference external" href="https://github.com/golang/go/issues/599">#599</a>. However, we need to maintain
explicit compatibility for struct layout in some important situations.
Therefore, we also propose the following:</p>
<ul class="simple">
<li><p>We add a new Go directive <code class="docutils literal notranslate"><span class="pre">//go:packed</span></code> which applies to the immediately
following struct type. That struct type will have a fully-packed layout,
where fields are placed in order with no padding between them and hence no
alignment based on types.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">//go:packed</span></code> property will become part of the following struct type
that it applies to.  In particular, we will not allow assignment/conversion from
a struct type to the equivalent packed struct type, and vice versa.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">//go:packed</span></code> property only applies to the struct type being defined.  It does
not apply to any struct type that is embedded in the type being defined.  Any
embedded struct type must similarly be defined with the <code class="docutils literal notranslate"><span class="pre">//go:packed</span></code> property if
it is to be packed either on its own or inside another struct definition.
<code class="docutils literal notranslate"><span class="pre">//go:packed</span></code> will be ignored if it appears anywhere
else besides immediately preceding a struct type definition.</p>
<p>The idea with the <code class="docutils literal notranslate"><span class="pre">//go:packed</span></code> directive is to give the developer complete
control over the layout of a struct.  In particular, the developer (or a
code-generating program) can add padding so that the fields of a packed struct are laid
out in exactly the same way as they were in Go 1.15 (i.e. without the above
proposed alignment change).  Matching the exact layout as in Go 1.15 is needed
in some specific situations:</p>
<ol class="simple">
<li><p>Matching the layout of some Syscall structs, such as <code class="docutils literal notranslate"><span class="pre">Stat_t</span></code> and <code class="docutils literal notranslate"><span class="pre">Flock_t</span></code> on linux/386.
On 32-bit systems, these two structs actually have 64-bit fields that are
not aligned on 8-byte boundaries.  Since these structs are the exact
struct used to interface with Linux syscalls, they must have exactly the
specified layout.  With this proposal, any structs passed to syscall.Syscall
should be laid out exactly using <code class="docutils literal notranslate"><span class="pre">//go:packed</span></code>.</p></li>
<li><p>Some cgo structs (which are used to match declared C structs) may also
have 64-bit fields that are not aligned on 8-byte boundaries.  So, with this
proposal, cgo should use <code class="docutils literal notranslate"><span class="pre">//go:packed</span></code> for generated Go structs that must
exactly match the layout of C structs.  In fact, there are currently C
structs that cannot be matched exactly by Go structs, because of the current
(Go 1.15) alignment rules.  With the use of <code class="docutils literal notranslate"><span class="pre">//go:packed</span></code>, cgo will now be able
to match exactly the layout of any C struct (unless the struct uses bitfields).</p></li>
</ol>
<p>Note that there is possibly assembly language code in some Go programs or
libraries that directly accesses the fields of a struct using hard-wired
offsets, rather than offsets obtained from a <code class="docutils literal notranslate"><span class="pre">go_asm.h</span></code> file. If that struct has
64-bit fields, then the offsets of those fields may change on 32-bit systems
with this proposal. In that case, then the assembly code may break. In that
case, we strongly recommend rewriting the assembly language code to use offsets
from <code class="docutils literal notranslate"><span class="pre">go_asm.h</span></code> (or using values obtained from from Go code via
<code class="docutils literal notranslate"><span class="pre">unsafe.Offsetof</span></code>). We would not recommend forcing the layout of the struct to
remain the same by using <code class="docutils literal notranslate"><span class="pre">//go:packed</span></code> and appropriate padding.</p>
</div>
<div class="section" id="addition-of-a-go-align-directive">
<h3>Addition of a <code class="docutils literal notranslate"><span class="pre">//go:align</span></code> directive<a class="headerlink" href="#addition-of-a-go-align-directive" title="Permalink to this headline">¶</a></h3>
<p>One issue with the <code class="docutils literal notranslate"><span class="pre">//go:packed</span></code> idea is determining the overall alignment of
a packed struct.  Currently, the overall alignment of a struct is computed as
the maximum alignment of any of its fields.  In the case of <code class="docutils literal notranslate"><span class="pre">//go:packed</span></code>, the
alignment of each field is essentially 1.  Therefore, conceptually, the overall
alignment of a packed struct is 1.  We could therefore consider that we need to
explicitly specify the alignment of a packed struct.</p>
<p>As we mentioned above, there are other reasons why developers would like to
specify an explicit alignment for a Go type.  For both of these reasons, we
therefore propose a method to specify the alignment of a Go type:</p>
<ul class="simple">
<li><p>We add a new Go directive <code class="docutils literal notranslate"><span class="pre">//go:align</span></code> N, which applies to the immediately
following type, where N can be any positive power of 2. The following
type will have the specified required alignment, or the natural alignment
of the type, whichever is larger.  It will be a compile-time
error if N is missing or is not a positive power of 2.  <code class="docutils literal notranslate"><span class="pre">//go:packed</span></code> and <code class="docutils literal notranslate"><span class="pre">//go:align</span></code>
can appear in either order if they are both specified preceding a struct type.</p></li>
</ul>
<p>In order to work well with memory allocators, etc., we only allow alignments
that are powers of 2.  There will probably have to be some practical upper limit on
the possible value of N.  Even for the purposes of aligning to cache lines, we would
likely only need alignment up to 128 bytes.</p>
<p>One issue with allowing otherwise identical types to have different alignments
is the question of when pointers to these types can be converted.  Consider the
following example:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">A</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">,</span> <span class="nx">w</span> <span class="kt">int32</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">B</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">,</span> <span class="nx">w</span> <span class="kt">int32</span>
<span class="p">}</span>

<span class="c1">//go:align 8</span>
<span class="kd">type</span> <span class="nx">C</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">,</span> <span class="nx">w</span> <span class="kt">int32</span>
<span class="p">}</span>

<span class="nx">a</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">A</span><span class="p">{}</span>
<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">B</span><span class="p">)(</span><span class="nx">a</span><span class="p">)</span>     <span class="c1">// conversion 1</span>
<span class="nx">c</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">C</span><span class="p">)(</span><span class="nx">a</span><span class="p">)</span>    <span class="c1">// conversion 2</span>
</pre></div>
</div>
<p>As in current Go, conversion 1 should certainly be allowed.  However, it is not
clear that conversion 2 should be allowed, since object <code class="docutils literal notranslate"><span class="pre">a</span></code> may not be
aligned to 8 bytes, so it may not satisfy the alignment property of <code class="docutils literal notranslate"><span class="pre">C</span></code> if <code class="docutils literal notranslate"><span class="pre">a</span></code>
is assigned to <code class="docutils literal notranslate"><span class="pre">c</span></code>.  Although this issue of convertability applies only to pointers of aligned
structs, it seems simplest and most consistent to include alignment as part of the base
type that it applies to.  We would therefore disallow converting from <code class="docutils literal notranslate"><span class="pre">A</span></code> to <code class="docutils literal notranslate"><span class="pre">C</span></code> and vice versa.
We propose the following:</p>
<ul class="simple">
<li><p>An alignment directive becomes part of the type that it applies to, and makes that type
distinct from an otherwise identical type with a different (or no) alignment.</p></li>
</ul>
<p>With this proposal, types <code class="docutils literal notranslate"><span class="pre">(*C)</span></code> and <code class="docutils literal notranslate"><span class="pre">(*A)</span></code> are not convertible, despite pointing to
structs that look identical, because the alignment of the structs to which they
point are different.  Therefore, conversion 2 would cause a compile-time error.  Similarly,
conversion between <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">C</span></code> would be disallowed.</p>
</div>
<div class="section" id="vet-and-compiler-checks">
<h3>Vet and compiler checks<a class="headerlink" href="#vet-and-compiler-checks" title="Permalink to this headline">¶</a></h3>
<p>Finally, we would like to help ensure that <code class="docutils literal notranslate"><span class="pre">//go:packed</span></code> is used in
cases where struct layout must maintain strict compatibility with Go 1.15. As
mentioned above, the important cases where compatibility must be maintained are structs
passed to syscalls and structs used with
Cgo.  Therefore, we propose the addition of the following vet check:</p>
<ul class="simple">
<li><p>New ‘go vet’ pass that requires the usage of <code class="docutils literal notranslate"><span class="pre">//go:packed</span></code> on a struct if a
pointer to that struct type is passed to syscall.Syscall (or its variants) or to cgo.</p></li>
</ul>
<p>The syscall check should cover most of the supported OSes (including Windows and
Windows DLLs), but we may have to extend the vet check if there are other ways
to call native OS functions. For example, in Windows, we may also want to cover
the <code class="docutils literal notranslate"><span class="pre">(*LazyProc).Call</span></code> API for calling DLL functions.</p>
<p>We could similarly have an error if a pointer to a non-packed struct type is
passed to an assembly language function, though that warning might have a lot of
false positives. Possibly we would limit warnings to such assembly language
functions that clearly do not make use of <code class="docutils literal notranslate"><span class="pre">go_asm.h</span></code> definitions.</p>
<p>We intend that <code class="docutils literal notranslate"><span class="pre">//go:packed</span></code> should only be used in limited situations, such as
controlling exact layout of structs used in syscalls or in cgo.  It is possible
to cause bugs or performance problems if it is not used correctly.  In
particular, there could be problems with garbage collection if fields containing
pointers are not aligned to the standard pointer alignment.  Therefore,
we propose the following compiler and vet checks:</p>
<ul class="simple">
<li><p>The compiler will give a compile-time error if the fields of a packed struct are aligned
incorrectly for garbage collection or hardware-specific needs.  In particular, it will be
an error if a pointer field is not aligned to a 4-byte boundary.  It may also be an error,
depending on the hardware, if 16-bit fields are not aligned to 2-byte boundaries or
32-bit fields are not aligned to 4-byte boundaries.</p></li>
</ul>
<p>Some processors can successfully load 32-bit quantities that are not aligned to
4 bytes, but the unaligned load is much slower than an aligned load.  So, the idea
of compiler check for the alignment of 16-bit and 32-bit quantities is to protect
against this case where certain loads are “silently” much slower because they
are accessing unaligned fields.</p>
</div>
</div>
<div class="section" id="alternate-proposals">
<h2>Alternate proposals<a class="headerlink" href="#alternate-proposals" title="Permalink to this headline">¶</a></h2>
<p>The above proposal contains a coherent set of proposed changes that address the
main issue <a class="reference external" href="https://github.com/golang/go/issues/599">#599</a>,
while also including some functionality (packed structs, aligned
types) that are useful for other purposes as well.</p>
<p>However, there are a number of alternatives, both to the set of features in the
proposal, and also in the details of individual items in the proposal.</p>
<p>The above proposal has quite a number of
individual items, each of which adds complexity and may have unforeseen issues.
One alternative is to reduce the scope of the proposal, by removing
<code class="docutils literal notranslate"><span class="pre">//go:align</span></code>. With this alternative, we would propose a separate rule for the
alignment of a packed struct. Instead of having a default alignment of 1, a
packed struct would have as its alignment the max alignment of all the types
that make up its individual fields. That is, a packed struct would automatically
have the same overall alignment as the equivalent unpacked struct.  With this
definition, we don’t need to include <code class="docutils literal notranslate"><span class="pre">//go:align</span></code> in this proposal.</p>
<p>Another alternative (which actually increases the scope of the proposal) would
be to allow <code class="docutils literal notranslate"><span class="pre">//go:align</span></code> to apply not just to type declarations, but also to
field declarations within a packed struct.  This would allow explicit alignment of
fields within a packed struct, which would make it easier for developers to get field
alignment correct without using padding.  However, we probably do not want to
encourage broad use of <code class="docutils literal notranslate"><span class="pre">//go:align</span></code>, and this ability of <code class="docutils literal notranslate"><span class="pre">//go:align</span></code> to set the
alignment of fields might become greatly overused.</p>
</div>
<div class="section" id="alternate-syntax">
<h2>Alternate syntax<a class="headerlink" href="#alternate-syntax" title="Permalink to this headline">¶</a></h2>
<p>There is also an alternative design that has the same set of features, but expresses the
alignment of types differently.  Instead of using <code class="docutils literal notranslate"><span class="pre">//go:align</span></code>, this alternative
follows the proposal in issue <a class="reference external" href="https://github.com/golang/go/issues/19057">#19057</a> and
expresses alignment via new runtime types
included in structs.  In this proposal, there are runtime types
<code class="docutils literal notranslate"><span class="pre">runtime.Aligned8</span></code>, <code class="docutils literal notranslate"><span class="pre">runtime.Aligned16</span></code>, etc.  If, for example, a field with
type <code class="docutils literal notranslate"><span class="pre">runtime.Aligned16</span></code> is included in a struct type definition, then that
struct type will have an alignment of 16 bytes, as in:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">vector</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">_</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">Aligned16</span>
    <span class="nx">vals</span> <span class="p">[</span><span class="mi">16</span><span class="p">]</span><span class="kt">byte</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It is possible that using <code class="docutils literal notranslate"><span class="pre">runtime.AlignedN</span></code> could directly apply to the following field in
the struct as well.  Hence, <code class="docutils literal notranslate"><span class="pre">runtime.AlignedN</span></code> could appear multiple times in a struct in order
to set the alignment of various fields, as well as affecting the overall alignment of the struct.</p>
<p>Similarly, the packed attribute of a struct is expressed by including a field with type
<code class="docutils literal notranslate"><span class="pre">runtime.Packed</span></code>.  These fields are zero-length and can either have a name or not.  If they
have a name, it is possible to take a pointer to them.  It would be an error to use these types
in any situation other than as a type for a field in a struct.</p>
<p>There are a number of positives and negatives to this proposal, as compared to the use
of <code class="docutils literal notranslate"><span class="pre">//go:packed</span></code> and <code class="docutils literal notranslate"><span class="pre">//go:aligned</span></code>, as listed below.</p>
<p>Advantages of special field types / disadvantages of directives:</p>
<ol class="simple">
<li><p>Most importantly, using <code class="docutils literal notranslate"><span class="pre">runtime.AlignedN</span></code> and <code class="docutils literal notranslate"><span class="pre">runtime.Packed</span></code> types in a struct makes it
obvious that these constructs affect the type of the containing struct.  The inclusion of these
extra fields means that Go  doesn’t require any special added constraints for type
equivalence, assignability, or convertibility.  The use of directives <code class="docutils literal notranslate"><span class="pre">//go:packed</span></code> and
<code class="docutils literal notranslate"><span class="pre">//go:aligned</span></code> don’t make it as obvious that they actually change the following type.  This
may cause more changes in other Go tools, since they must be changed to notice these
directives and realize their effect on the following type.  There is no current <code class="docutils literal notranslate"><span class="pre">//go:</span></code> directive
that affects the following type.  (<code class="docutils literal notranslate"><span class="pre">//go:notinheap</span></code> relates to the following type, but does not
change the declared type, and is only available in the runtime package.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">runtime.AlignedN</span></code> could just be a zero-width type with alignment N that also affects the
alignment of the following field.  This is easy to describe and understand, and provides a
natural way to control both field and struct alignment.  [<code class="docutils literal notranslate"><span class="pre">runtime.AlignedN</span></code> may or may not
disable field re-ordering – to be determined.]</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">runtime.AlignedN</span></code> applies to the following field, users can easily control padding and
alignment within a struct. This is particularly useful in conjunction with <code class="docutils literal notranslate"><span class="pre">runtime.Packed</span></code>, as it
provides a mechanism to add back desired field alignment where packing removed it.  It
potentially seems much more unusual to have a directive <code class="docutils literal notranslate"><span class="pre">//go:align</span></code> be specified inside a
struct declaration and applying specifically to the next field.</p></li>
<li><p>Some folks prefer to not add any more pragma-like <code class="docutils literal notranslate"><span class="pre">//go:</span></code>  comments in the language.</p></li>
</ol>
<p>Advantages of directives / disadvantages of special field types:</p>
<ol class="simple">
<li><p>We have established <code class="docutils literal notranslate"><span class="pre">//go:</span></code> as the prefix for these kinds of build/compiler directives, and it’s
unfortunate to add a second one in the type system instead.</p></li>
<li><p>With <code class="docutils literal notranslate"><span class="pre">runtime.AlignedN</span></code>, a simple non-struct type (such as <code class="docutils literal notranslate"><span class="pre">[16]byte</span></code>) can only be aligned by
embedding it in a struct, whereas <code class="docutils literal notranslate"><span class="pre">//go:align</span></code> can apply directly to a non-struct type. It doesn’t
seem very Go-like to force people to create structs like the ‘vector’ type when plain types like
<code class="docutils literal notranslate"><span class="pre">[16]byte</span></code> will do.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">runtime.Packed</span></code> and <code class="docutils literal notranslate"><span class="pre">runtime.AlignedN</span></code> both appear to apply to the following field in the
struct.  In the case of runtime.Packed, this doesn’t make any sense – <code class="docutils literal notranslate"><span class="pre">runtime.Packed</span></code>
applies to the whole struct only, not to any particular field.</p></li>
<li><p>Adding an alignment/packing field forces the use of key:value literals, which is annoying
and non-orthogonal. Directives have no effect on literals, so unkeyed literals would continue
to work.</p></li>
<li><p>With <code class="docutils literal notranslate"><span class="pre">runtime.Packed</span></code>, there is a hard break at some Go version, where you can’t write a
single struct that works for both older and newer Go versions. That will necessitate separate
files and build tags during any conversion. With the comments you can write one piece of
code that has the same meaning to both older and newer versions of Go (because the explicit
padding is old-version compatible and the old version ignores the <code class="docutils literal notranslate"><span class="pre">//go:packed</span></code> comment).</p></li>
</ol>
</div>
<div class="section" id="compatibility">
<h2>Compatibility<a class="headerlink" href="#compatibility" title="Permalink to this headline">¶</a></h2>
<p>We are not changing the alignment of arguments, return variables, or local
variables. Since we would be changing the default layout of structs, we could
affect some programs running on 32-bit systems that depend on the layout of
structs. However, the layout of structs is not explicitly defined in the Go
language spec, except for the minimum alignment, and we are maintaining the
previous minimum alignments. So, we don’t believe this change breaks the Go 1
compatibility promise. If assembly code is accessing struct fields, it should be
using the symbolic constants (giving the offset of each field in a struct) that
are available in <code class="docutils literal notranslate"><span class="pre">go_asm.h</span></code>. <code class="docutils literal notranslate"><span class="pre">go_asm.h</span></code> is automatically generated and available for
each package that contains an assembler file, or can be explicitly generated for
use elsewhere via <code class="docutils literal notranslate"><span class="pre">go</span> <span class="pre">tool</span> <span class="pre">compile</span> <span class="pre">-asmhdr</span> <span class="pre">go_asm.h</span></code>.</p>
</div>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>We have a developed some prototype code that changes the default alignment of
64-bit fields on 32-bit systems from 4 bytes to 8 bytes. Since it does not
include an implementation of <code class="docutils literal notranslate"><span class="pre">//go:packed</span></code>, it does not yet try to deal with the
compatibility issues associated with syscall structs <code class="docutils literal notranslate"><span class="pre">Stat_t</span></code> and <code class="docutils literal notranslate"><span class="pre">Flock_t</span></code> or
cgo-generated structs in a complete way. The change is
<a class="reference external" href="https://go-review.googlesource.com/c/go/+/210637">CL 210637</a>. Comments on the design
or implementation are very welcome.</p>
</div>
<div class="section" id="open-issues">
<h2>Open Issues<a class="headerlink" href="#open-issues" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="37112-unstable-runtime-metrics.html" class="btn btn-neutral float-right" title="Proposal: API for unstable runtime metrics" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="36460-lazy-module-loading.html" class="btn btn-neutral float-left" title="Proposal: Lazy Module Loading" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>