

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Type Parameters - Draft Design &mdash; Go Design Proposal  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Generics — Problem Overview" href="go2draft-generics-overview.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Go Design Proposal
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="11502-securitypolicy.html">Proposal: Security Policy for Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="11970-decentralized-gc.html">Proposal: Decentralized GC coordination</a></li>
<li class="toctree-l1"><a class="reference internal" href="12166-subtests.html">Proposal: testing: programmatic sub-test and sub-benchmark support</a></li>
<li class="toctree-l1"><a class="reference internal" href="12302-release-proposal.html">Proposal: A minimal release process for Go repositories</a></li>
<li class="toctree-l1"><a class="reference internal" href="12416-cgo-pointers.html">Proposal: Rules for passing pointers between Go and C</a></li>
<li class="toctree-l1"><a class="reference internal" href="12750-localization.html">Proposal: Localization support in Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="12800-sweep-free-alloc.html">Proposal: Dense mark bits and sweep-free allocation</a></li>
<li class="toctree-l1"><a class="reference internal" href="12914-monotonic.html">Proposal: Monotonic Elapsed Time Measurements in Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="12914-monotonic.html#appendix-time-now-usage">Appendix: time.Now usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="13073-code-of-conduct.html">Proposal: A Code of Conduct for the Go community</a></li>
<li class="toctree-l1"><a class="reference internal" href="13432-mobile-audio.html">Proposal: Audio for Mobile</a></li>
<li class="toctree-l1"><a class="reference internal" href="13504-natural-xml.html">Proposal: Natural XML</a></li>
<li class="toctree-l1"><a class="reference internal" href="14313-benchmark-format.html">Proposal: Go Benchmark Data Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="14386-zip-package-archives.html">Proposal: Zip-based Go package archives</a></li>
<li class="toctree-l1"><a class="reference internal" href="14951-soft-heap-limit.html">Proposal: Separate soft and hard heap size goal</a></li>
<li class="toctree-l1"><a class="reference internal" href="15292-generics.html">Proposal: Go should have generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="16085-conversions-ignore-tags.html">Proposal: Ignore tags in struct type conversions</a></li>
<li class="toctree-l1"><a class="reference internal" href="16339-alias-decls.html">Proposal: Alias declarations for Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="16339-alias-decls.html#appendix">Appendix</a></li>
<li class="toctree-l1"><a class="reference internal" href="16410-heap-viewer.html">Proposal: Go Heap Dump Viewer</a></li>
<li class="toctree-l1"><a class="reference internal" href="16704-cidr-notation-no-proxy.html">Proposal: Add support for CIDR notation in no_proxy variable</a></li>
<li class="toctree-l1"><a class="reference internal" href="17280-profile-labels.html">Proposal: Support for pprof profiler labels</a></li>
<li class="toctree-l1"><a class="reference internal" href="17503-eliminate-rescan.html">Proposal: Eliminate STW stack re-scanning</a></li>
<li class="toctree-l1"><a class="reference internal" href="17505-concurrent-rescan.html">Proposal: Concurrent stack re-scanning</a></li>
<li class="toctree-l1"><a class="reference internal" href="18130-type-alias.html">Proposal: Type Aliases</a></li>
<li class="toctree-l1"><a class="reference internal" href="18802-percpu-sharded.html">Proposal: percpu.Sharded, an API for reducing cache contention</a></li>
<li class="toctree-l1"><a class="reference internal" href="18802-percpu-sharded.html#discussion">Discussion</a></li>
<li class="toctree-l1"><a class="reference internal" href="18802-percpu-sharded.html#backwards-compatibility">Backwards compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="19113-signed-shift-counts.html">Proposal: Permit Signed Integers as Shift Counts for Go 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="19308-number-literals.html">Proposal: Go 2 Number Literal Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html">Proposal: Mid-stack inlining in the Go compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#abstract">Abstract</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#background">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#proposal">Proposal</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#rationale">Rationale</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#compatibility">Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#implementation">Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#prerequisite-changes">Prerequisite Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#preliminary-results">Preliminary Results</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#open-issues">Open issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="19480-xml-stream.html">Proposal: XML Stream</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html">Proposal: emit DWARF inlining info in the Go compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#abstract">Abstract</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#background">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#example">Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#how-the-generated-dwarf-should-look">How the generated DWARF should look</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#outline-of-proposed-changes">Outline of proposed changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#compatibility">Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#implementation">Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#prerequisite-changes">Prerequisite Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#preliminary-results">Preliminary Results</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#open-issues">Open issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="24301-versioned-go.html">Proposal: Versioned Go Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="24543-non-cooperative-preemption.html">Proposal: Non-cooperative goroutine preemption</a></li>
<li class="toctree-l1"><a class="reference internal" href="25530-sumdb.html">Proposal: Secure the Public Go Module Ecosystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="25719-go15vendor.html">Go 1.5 Vendor Experiment</a></li>
<li class="toctree-l1"><a class="reference internal" href="26160-dns-based-vanity-imports.html">Proposal: DNS Based Vanity Imports</a></li>
<li class="toctree-l1"><a class="reference internal" href="26756-rawxml-token.html">Proposal: Raw XML Token</a></li>
<li class="toctree-l1"><a class="reference internal" href="26903-simplify-mark-termination.html">Proposal: Simplify mark termination and eliminate mark 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="27539-internal-abi.html">Proposal: Create an undefined internal calling convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="2775-binary-only-packages.html">Proposal: Binary-Only Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="27935-unbounded-queue-package.html">Proposal: Built in support for high performance unbounded queue</a></li>
<li class="toctree-l1"><a class="reference internal" href="28221-go2-transitions.html">Proposal: Go 2 transition</a></li>
<li class="toctree-l1"><a class="reference internal" href="2981-go-test-json.html">Proposal: <code class="docutils literal notranslate"><span class="pre">-json</span></code> flag in <code class="docutils literal notranslate"><span class="pre">go</span> <span class="pre">test</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="29934-error-values.html">Proposal: Go 2 Error Inspection</a></li>
<li class="toctree-l1"><a class="reference internal" href="30333-smarter-scavenging.html">Proposal: Smarter Scavenging</a></li>
<li class="toctree-l1"><a class="reference internal" href="30411-env.html">Proposal: <code class="docutils literal notranslate"><span class="pre">go</span></code> command configuration file</a></li>
<li class="toctree-l1"><a class="reference internal" href="32437-try-builtin.html">Proposal: A built-in Go error check function, <code class="docutils literal notranslate"><span class="pre">try</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="33974-add-public-lockedfile-pkg.html">Proposal: make the internal lockedfile package public</a></li>
<li class="toctree-l1"><a class="reference internal" href="34481-opencoded-defers.html">Proposal: Low-cost defers through inline code, and extra funcdata to manage the panic case</a></li>
<li class="toctree-l1"><a class="reference internal" href="35112-scaling-the-page-allocator.html">Proposal: Scaling the Go page allocator</a></li>
<li class="toctree-l1"><a class="reference internal" href="36460-lazy-module-loading.html">Proposal: Lazy Module Loading</a></li>
<li class="toctree-l1"><a class="reference internal" href="36606-64-bit-field-alignment.html">Proposal: Make 64-bit fields be 64-bit aligned on 32-bit systems, add //go:packed, //go:align directives</a></li>
<li class="toctree-l1"><a class="reference internal" href="37112-unstable-runtime-metrics.html">Proposal: API for unstable runtime metrics</a></li>
<li class="toctree-l1"><a class="reference internal" href="37720-gopls-workspaces.html">Proposal: Multi-project gopls workspaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="4899-testing-helper.html">Proposal: testing: better support test helper functions with TB.Helper</a></li>
<li class="toctree-l1"><a class="reference internal" href="6282-table-data.html">Proposal: Multi-dimensional slices</a></li>
<li class="toctree-l1"><a class="reference internal" href="6977-overlapping-interfaces.html">Proposal: Permit embedding of interfaces with overlapping method sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="TEMPLATE.html">Proposal: [Title]</a></li>
<li class="toctree-l1"><a class="reference internal" href="cryptography-principles.html">Cryptography Principles</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft.html">Go 2 Draft Designs</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-contracts.html">Contracts — Draft Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-handling.html">Error Handling — Draft Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-handling-overview.html">Error Handling — Problem Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-inspection.html">Error Inspection — Draft Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-printing.html">Error Printing — Draft Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-values-overview.html">Error Values — Problem Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-generics-overview.html">Generics — Problem Overview</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Type Parameters - Draft Design</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#abstract">Abstract</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-read-this-design-draft">How to read this design draft</a></li>
<li class="toctree-l2"><a class="reference internal" href="#very-high-level-overview">Very high level overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#background">Background</a></li>
<li class="toctree-l2"><a class="reference internal" href="#design">Design</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#type-parameters">Type parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#constraints">Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="#operations-permitted-for-any-type">Operations permitted for any type</a></li>
<li class="toctree-l3"><a class="reference internal" href="#defining-constraints">Defining constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-a-constraint">Using a constraint</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multiple-type-parameters">Multiple type parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#generic-types">Generic types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#methods-may-not-take-additional-type-arguments">Methods may not take additional type arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#operators">Operators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#type-lists-in-constraints">Type lists in constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#comparable-types-in-constraints">Comparable types in constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#type-lists-in-interface-types">Type lists in interface types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#function-argument-type-inference">Function argument type inference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-types-that-refer-to-themselves-in-constraints">Using types that refer to themselves in constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mutually-referencing-type-parameters">Mutually referencing type parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pointer-methods">Pointer methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-generic-types-as-unnamed-function-parameter-types">Using generic types as unnamed function parameter types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#values-of-type-parameters-are-not-boxed">Values of type parameters are not boxed</a></li>
<li class="toctree-l3"><a class="reference internal" href="#more-on-type-lists">More on type lists</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#both-type-lists-and-methods-in-constraints">Both type lists and methods in constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#composite-types-in-constraints">Composite types in constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#type-parameters-in-type-lists">Type parameters in type lists</a></li>
<li class="toctree-l4"><a class="reference internal" href="#type-conversions">Type conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#untyped-constants">Untyped constants</a></li>
<li class="toctree-l4"><a class="reference internal" href="#notes-on-composite-types-in-type-lists">Notes on composite types in type lists</a></li>
<li class="toctree-l4"><a class="reference internal" href="#type-lists-in-embedded-constraints">Type lists in embedded constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#general-notes-on-type-lists">General notes on type lists</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#reflection">Reflection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implementation">Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#summary">Summary</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#complexity">Complexity</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pervasiveness">Pervasiveness</a></li>
<li class="toctree-l4"><a class="reference internal" href="#efficiency">Efficiency</a></li>
<li class="toctree-l4"><a class="reference internal" href="#omissions">Omissions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#issues">Issues</a></li>
<li class="toctree-l4"><a class="reference internal" href="#discarded-ideas">Discarded ideas</a></li>
<li class="toctree-l4"><a class="reference internal" href="#comparison-with-java">Comparison with Java</a></li>
<li class="toctree-l4"><a class="reference internal" href="#comparison-with-c">Comparison with C++</a></li>
<li class="toctree-l4"><a class="reference internal" href="#comparison-with-rust">Comparison with Rust</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#map-reduce-filter">Map/Reduce/Filter</a></li>
<li class="toctree-l3"><a class="reference internal" href="#map-keys">Map keys</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sets">Sets</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sort">Sort</a></li>
<li class="toctree-l3"><a class="reference internal" href="#channels">Channels</a></li>
<li class="toctree-l3"><a class="reference internal" href="#containers">Containers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#append">Append</a></li>
<li class="toctree-l3"><a class="reference internal" href="#metrics">Metrics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#list-transform">List transform</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dot-product">Dot product</a></li>
<li class="toctree-l3"><a class="reference internal" href="#absolute-difference">Absolute difference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#acknowledgements">Acknowledgements</a></li>
<li class="toctree-l2"><a class="reference internal" href="#appendix">Appendix</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#generic-type-aliases">Generic type aliases</a></li>
<li class="toctree-l3"><a class="reference internal" href="#instantiating-a-function">Instantiating a function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#embedded-type-parameter">Embedded type parameter</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inline-constraints">Inline constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-inference-for-composite-literals">Type inference for composite literals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-inference-for-generic-function-arguments">Type inference for generic function arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reflection-on-type-arguments">Reflection on type arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#instantiating-types-in-type-literals">Instantiating types in type literals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#embedding-an-instantiated-interface-type">Embedding an instantiated interface type</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Go Design Proposal</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Type Parameters - Draft Design</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/go2draft-type-parameters.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="type-parameters-draft-design">
<h1>Type Parameters - Draft Design<a class="headerlink" href="#type-parameters-draft-design" title="Permalink to this headline">¶</a></h1>
<p>Ian Lance Taylor<br />Robert Griesemer<br />June 16, 2020</p>
<div class="section" id="abstract">
<h2>Abstract<a class="headerlink" href="#abstract" title="Permalink to this headline">¶</a></h2>
<p>We suggest extending the Go language to add optional type parameters
to types and functions.
Type parameters may be constrained by interface types.
We also suggest extending interface types, when used as type
constraints, to permit listing the set of types that may be assigned
to them.
Type inference via a unification algorithm is supported to permit
omitting type arguments from function calls in many cases.
The design is fully backward compatible with Go 1.</p>
</div>
<div class="section" id="how-to-read-this-design-draft">
<h2>How to read this design draft<a class="headerlink" href="#how-to-read-this-design-draft" title="Permalink to this headline">¶</a></h2>
<p>This document is long.
Here is some guidance on how to read it.</p>
<ul class="simple">
<li><p>We start with a high level overview, describing the concepts very
briefly.</p></li>
<li><p>We then explain the full design starting from scratch, introducing
the details as we need them, with simple examples.</p></li>
<li><p>After the design is completely described, we discuss implementation,
some issues with the design, and a comparison with other approaches
to generics.</p></li>
<li><p>We then present several complete examples of how this design would
be used in practice.</p></li>
<li><p>Following the examples some minor details are discussed in an
appendix.</p></li>
</ul>
</div>
<div class="section" id="very-high-level-overview">
<h2>Very high level overview<a class="headerlink" href="#very-high-level-overview" title="Permalink to this headline">¶</a></h2>
<p>This section explains the changes suggested by the design draft very
briefly.
This section is intended for people who are already familiar with how
generics would work in a language like Go.
These concepts will be explained in detail in the following sections.</p>
<ul class="simple">
<li><p>Functions can have an additional type parameter list introduced by
the keyword <code class="docutils literal notranslate"><span class="pre">type</span></code>: <code class="docutils literal notranslate"><span class="pre">func</span> <span class="pre">F(type</span> <span class="pre">T)(p</span> <span class="pre">T)</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code>.</p></li>
<li><p>These type parameters can be used by the regular parameters and in
the function body.</p></li>
<li><p>Types can also have a type parameter list: <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">M(type</span> <span class="pre">T)</span> <span class="pre">[]T</span></code>.</p></li>
<li><p>Each type parameter can have an optional type constraint: <code class="docutils literal notranslate"><span class="pre">func</span> <span class="pre">F(type</span> <span class="pre">T</span> <span class="pre">Constraint)(p</span> <span class="pre">T)</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code></p></li>
<li><p>Type constraints are interface types.</p></li>
<li><p>Interface types used as type constraints can have a list of
predeclared types; only types whose underlying type is one of those
types can implement the interface.</p></li>
<li><p>Using a generic function or type requires passing type arguments.</p></li>
<li><p>Type inference permits omitting the type arguments in common cases.</p></li>
<li><p>If a type parameter has a type constraint its type argument must
implement the interface.</p></li>
<li><p>Generic functions may only use operations permitted by the type
constraint.</p></li>
</ul>
<p>In the following sections we work through each of these language
changes in great detail.
You may prefer to skip ahead to the <a class="reference external" href="#Examples">examples</a> to see what
generic code written to this design draft will look like in practice.</p>
</div>
<div class="section" id="background">
<h2>Background<a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h2>
<p>This version of the design draft has many similarities to the one
presented on July 31, 2019, but contracts have been removed and
replaced by interface types.</p>
<p>There have been many <a class="reference external" href="https://github.com/golang/go/wiki/ExperienceReports#generics">requests to add additional support for generic
programming</a>
in Go.
There has been extensive discussion on
<a class="reference external" href="https://golang.org/issue/15292">the issue tracker</a> and on
<a class="reference external" href="https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/view">a living document</a>.</p>
<p>There have been several proposals for adding type parameters, which
can be found through the links above.
Many of the ideas presented here have appeared before.
The main new features described here are the syntax and the careful
examination of interface types as constraints.</p>
<p>This design draft suggests extending the Go language to add a form of
parametric polymorphism, where the type parameters are bounded not by
a declared subtyping relationship (as in some object oriented
languages) but by explicitly defined structural constraints.</p>
<p>This design does not support template metaprogramming or any other
form of compile time programming.</p>
<p>As the term <em>generic</em> is widely used in the Go community, we will
use it below as a shorthand to mean a function or type that takes type
parameters.
Don’t confuse the term generic as used in this design with the same
term in other languages like C++, C#, Java, or Rust; they have
similarities but are not the same.</p>
</div>
<div class="section" id="design">
<h2>Design<a class="headerlink" href="#design" title="Permalink to this headline">¶</a></h2>
<p>We will describe the complete design in stages based on simple
examples.</p>
<div class="section" id="type-parameters">
<h3>Type parameters<a class="headerlink" href="#type-parameters" title="Permalink to this headline">¶</a></h3>
<p>Generic code is code that is written using types that will be
specified later.
An unspecified type is called a <em>type parameter</em>.
When running the generic code, the type parameter will be set to a
<em>type argument</em>.</p>
<p>Here is a function that prints out each element of a slice, where the
element type of the slice, here called <code class="docutils literal notranslate"><span class="pre">T</span></code>, is unknown.
This is a trivial example of the kind of function we want to permit in
order to support generic programming.
(Later we’ll also discuss <a class="reference external" href="#Generic-types">generic types</a>).</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Print prints the elements of a slice.</span>
<span class="c1">// It should be possible to call this with any slice value.</span>
<span class="kd">func</span> <span class="nx">Print</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Just an example, not the suggested syntax.</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With this approach, the first decision to make is: how should the type
parameter <code class="docutils literal notranslate"><span class="pre">T</span></code> be declared?
In a language like Go, we expect every identifier to be declared in
some way.</p>
<p>Here we make a design decision: type parameters are similar to
ordinary non-type function parameters, and as such should be listed
along with other parameters.
However, type parameters are not the same as non-type parameters, so
although they appear in the list of parameters we want to distinguish
them.
That leads to our next design decision: we define an additional,
optional, parameter list, describing type parameters.
This parameter list appears before the regular parameters.
It starts with the keyword <code class="docutils literal notranslate"><span class="pre">type</span></code>, and lists type parameters.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Print prints the elements of any slice.</span>
<span class="c1">// Print has a type parameter T, and has a single (non-type)</span>
<span class="c1">// parameter s which is a slice of that type parameter.</span>
<span class="kd">func</span> <span class="nx">Print</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// same as above</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This says that within the function <code class="docutils literal notranslate"><span class="pre">Print</span></code> the identifier <code class="docutils literal notranslate"><span class="pre">T</span></code> is a
type parameter, a type that is currently unknown but that will be
known when the function is called.
As seen above, the type parameter may be used as a type when
describing the ordinary non-type parameters.
It may also be used within the body of the function.</p>
<p>Since <code class="docutils literal notranslate"><span class="pre">Print</span></code> has a type parameter, any call of <code class="docutils literal notranslate"><span class="pre">Print</span></code> must provide a
type argument.
Later we will see how this type argument can usually be deduced from
the non-type argument, by using <a class="reference external" href="#Function-argument-type-inference">function argument type
inference</a>.
For now, we’ll pass the type argument explicitly.
Type arguments are passed much like type parameters are declared: as a
separate list of arguments.
At the call site, the <code class="docutils literal notranslate"><span class="pre">type</span></code> keyword is not used.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span>	<span class="c1">// Call Print with a []int.</span>
	<span class="c1">// Print has a type parameter T, and we want to pass a []int,</span>
	<span class="c1">// so we pass a type argument of int by writing Print(int).</span>
	<span class="c1">// The function Print(int) expects a []int as an argument.</span>

	<span class="nx">Print</span><span class="p">(</span><span class="kt">int</span><span class="p">)([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">})</span>

	<span class="c1">// This will print:</span>
	<span class="c1">// 1</span>
	<span class="c1">// 2</span>
	<span class="c1">// 3</span>
</pre></div>
</div>
</div>
<div class="section" id="constraints">
<h3>Constraints<a class="headerlink" href="#constraints" title="Permalink to this headline">¶</a></h3>
<p>Let’s make our example slightly more complicated.
Let’s turn it into a function that converts a slice of any type into a
<code class="docutils literal notranslate"><span class="pre">[]string</span></code> by calling a <code class="docutils literal notranslate"><span class="pre">String</span></code> method on each element.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// This function is INVALID.</span>
<span class="kd">func</span> <span class="nx">Stringify</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">(</span><span class="nx">ret</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">ret</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ret</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span> <span class="c1">// INVALID</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This might seem OK at first glance, but in this example <code class="docutils literal notranslate"><span class="pre">v</span></code> has type
<code class="docutils literal notranslate"><span class="pre">T</span></code>, and we don’t know anything about <code class="docutils literal notranslate"><span class="pre">T</span></code>.
In particular, we don’t know that <code class="docutils literal notranslate"><span class="pre">T</span></code> has a <code class="docutils literal notranslate"><span class="pre">String</span></code> method.
So the call to <code class="docutils literal notranslate"><span class="pre">v.String()</span></code> is invalid.</p>
<p>Naturally, the same issue arises in other languages that support
generic programming.
In C++, for example, a generic function (in C++ terms, a function
template) can call any method on a value of generic type.
That is, in the C++ approach, calling <code class="docutils literal notranslate"><span class="pre">v.String()</span></code> is fine.
If the function is called with a type argument that does not have a
<code class="docutils literal notranslate"><span class="pre">String</span></code> method, the error is reported when compiling the call to
<code class="docutils literal notranslate"><span class="pre">v.String</span></code> with that type argument.
These errors can be lengthy, as there may be several layers of generic
function calls before the error occurs, all of which must be reported
to understand what went wrong.</p>
<p>The C++ approach would be a poor choice for Go.
One reason is the style of the language.
In Go we don’t refer to names, such as, in this case, <code class="docutils literal notranslate"><span class="pre">String</span></code>, and
hope that they exist.
Go resolves all names to their declarations when they are seen.</p>
<p>Another reason is that Go is designed to support programming at
scale.
We must consider the case in which the generic function definition
(<code class="docutils literal notranslate"><span class="pre">Stringify</span></code>, above) and the call to the generic function (not shown,
but perhaps in some other package) are far apart.
In general, all generic code expects the type arguments to meet
certain requirements.
We refer to these requirements as <em>constraints</em> (other languages have
similar ideas known as type bounds or trait bounds or concepts).
In this case, the constraint is pretty obvious: the type has to have a
<code class="docutils literal notranslate"><span class="pre">String()</span> <span class="pre">string</span></code> method.
In other cases it may be much less obvious.</p>
<p>We don’t want to derive the constraints from whatever <code class="docutils literal notranslate"><span class="pre">Stringify</span></code>
happens to do (in this case, call the <code class="docutils literal notranslate"><span class="pre">String</span></code> method).
If we did, a minor change to <code class="docutils literal notranslate"><span class="pre">Stringify</span></code> might change the
constraints.
That would mean that a minor change could cause code far away, that
calls the function, to unexpectedly break.
It’s fine for <code class="docutils literal notranslate"><span class="pre">Stringify</span></code> to deliberately change its constraints, and
force users to change.
What we want to avoid is <code class="docutils literal notranslate"><span class="pre">Stringify</span></code> changing its constraints
accidentally.</p>
<p>This means that the constraints must set limits on both the type
arguments passed by the caller and the code in the generic function.
The caller may only pass type arguments that satisfy the constraints.
The generic function may only use those values in ways that are
permitted by the constraints.
This is an important rule that we believe should apply to any attempt
to define generic programming in Go: generic code can only use
operations that its type arguments are known to implement.</p>
</div>
<div class="section" id="operations-permitted-for-any-type">
<h3>Operations permitted for any type<a class="headerlink" href="#operations-permitted-for-any-type" title="Permalink to this headline">¶</a></h3>
<p>Before we discuss constraints further, let’s briefly note what happens
in their absence.
If a generic function does not specify a constraint for a type
parameter, as is the case for the <code class="docutils literal notranslate"><span class="pre">Print</span></code> method above, then any type
argument is permitted for that parameter.
The only operations that the generic function can use with values of
that type parameter are those operations that are permitted for values
of any type.
In the example above, the <code class="docutils literal notranslate"><span class="pre">Print</span></code> function declares a variable <code class="docutils literal notranslate"><span class="pre">v</span></code>
whose type is the type parameter <code class="docutils literal notranslate"><span class="pre">T</span></code>, and it passes that variable to a
function.</p>
<p>The operations permitted for any type are:</p>
<ul class="simple">
<li><p>declare variables of those types</p></li>
<li><p>assign other values of the same type to those variables</p></li>
<li><p>pass those variables to functions or return them from functions</p></li>
<li><p>take the address of those variables</p></li>
<li><p>convert or assign values of those types to the type <code class="docutils literal notranslate"><span class="pre">interface{}</span></code></p></li>
<li><p>convert a value of type <code class="docutils literal notranslate"><span class="pre">T</span></code> to type <code class="docutils literal notranslate"><span class="pre">T</span></code> (permitted but useless)</p></li>
<li><p>use a type assertion to convert an interface value to the type</p></li>
<li><p>use the type as a case in a type switch</p></li>
<li><p>define and use composite types that use those types, such as a slice
of that type</p></li>
<li><p>pass the type to some builtin functions such as <code class="docutils literal notranslate"><span class="pre">new</span></code></p></li>
</ul>
<p>It’s possible that future language changes will add other such
operations, though none are currently anticipated.</p>
</div>
<div class="section" id="defining-constraints">
<h3>Defining constraints<a class="headerlink" href="#defining-constraints" title="Permalink to this headline">¶</a></h3>
<p>Go already has a construct that is close to what we need for a
constraint: an interface type.
An interface type is a set of methods.
The only values that can be assigned to a variable of interface type
are those whose types implement the same methods.
The only operations that can be done with a value of interface type,
other than operations permitted for any type, are to call the
methods.</p>
<p>Calling a generic function with a type argument is similar to
assigning to a variable of interface type: the type argument must
implement the constraints of the type parameter.
Writing a generic function is like using values of interface type: the
generic code can only use the operations permitted by the constraint
(or operations that are permitted for any type).</p>
<p>In this design, constraints are simply interface types.
Implementing a constraint is simply implementing the interface type.
(Later we’ll see how to define constraints for operations other than
method calls, such as <a class="reference external" href="#Operators">binary operators</a>).</p>
<p>For the <code class="docutils literal notranslate"><span class="pre">Stringify</span></code> example, we need an interface type with a <code class="docutils literal notranslate"><span class="pre">String</span></code>
method that takes no arguments and returns a value of type <code class="docutils literal notranslate"><span class="pre">string</span></code>.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Stringer is a type constraint that requires the type argument to have</span>
<span class="c1">// a String method and permits the generic function to call String.</span>
<span class="c1">// The String method should return a string representation of the value.</span>
<span class="kd">type</span> <span class="nx">Stringer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</pre></div>
</div>
<p>(It doesn’t matter for this discussion, but this defines the same
interface as the standard library’s <code class="docutils literal notranslate"><span class="pre">fmt.Stringer</span></code> type, and  real
code would likely simply use <code class="docutils literal notranslate"><span class="pre">fmt.Stringer</span></code>.)</p>
</div>
<div class="section" id="using-a-constraint">
<h3>Using a constraint<a class="headerlink" href="#using-a-constraint" title="Permalink to this headline">¶</a></h3>
<p>For a generic function, a constraint can be thought of as the type of
the type argument: a meta-type.
So, although generic functions are not required to use constraints,
when they do they are listed in the type parameter list as the
meta-type of a type parameter.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Stringify calls the String method on each element of s,</span>
<span class="c1">// and returns the results.</span>
<span class="kd">func</span> <span class="nx">Stringify</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">Stringer</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">(</span><span class="nx">ret</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">ret</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ret</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The single type parameter <code class="docutils literal notranslate"><span class="pre">T</span></code> is followed by the constraint that
applies to <code class="docutils literal notranslate"><span class="pre">T</span></code>, in this case <code class="docutils literal notranslate"><span class="pre">Stringer</span></code>.</p>
</div>
<div class="section" id="multiple-type-parameters">
<h3>Multiple type parameters<a class="headerlink" href="#multiple-type-parameters" title="Permalink to this headline">¶</a></h3>
<p>Although the <code class="docutils literal notranslate"><span class="pre">Stringify</span></code> example uses only a single type parameter,
functions may have multiple type parameters.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Print2 has two type parameters and two non-type parameters.</span>
<span class="kd">func</span> <span class="nx">Print2</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">)(</span><span class="nx">s1</span> <span class="p">[]</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">s2</span> <span class="p">[]</span><span class="nx">T2</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>Compare this to</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Print2Same has one type parameter and two non-type parameters.</span>
<span class="kd">func</span> <span class="nx">Print2Same</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)(</span><span class="nx">s1</span> <span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">s2</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>In <code class="docutils literal notranslate"><span class="pre">Print2</span></code> <code class="docutils literal notranslate"><span class="pre">s1</span></code> and <code class="docutils literal notranslate"><span class="pre">s2</span></code> may be slices of different types.
In <code class="docutils literal notranslate"><span class="pre">Print2Same</span></code> <code class="docutils literal notranslate"><span class="pre">s1</span></code> and <code class="docutils literal notranslate"><span class="pre">s2</span></code> must be slices of the same element
type.</p>
<p>Each type parameter may have its own constraint.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Stringer is a type constraint that requires a String method.</span>
<span class="c1">// The String method should return a string representation of the value.</span>
<span class="kd">type</span> <span class="nx">Stringer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// Plusser is a type constraint that requires a Plus method.</span>
<span class="c1">// The Plus method is expected to add the argument to an internal</span>
<span class="c1">// string and return the result.</span>
<span class="kd">type</span> <span class="nx">Plusser</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Plus</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// ConcatTo takes a slice of elements with a String method and a slice</span>
<span class="c1">// of elements with a Plus method. The slices should have the same</span>
<span class="c1">// number of elements. This will convert each element of s to a string,</span>
<span class="c1">// pass it to the Plus method of the corresponding element of p,</span>
<span class="c1">// and return a slice of the resulting strings.</span>
<span class="kd">func</span> <span class="nx">ConcatTo</span><span class="p">(</span><span class="kd">type</span> <span class="nx">S</span> <span class="nx">Stringer</span><span class="p">,</span> <span class="nx">P</span> <span class="nx">Plusser</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">S</span><span class="p">,</span> <span class="nx">p</span> <span class="p">[]</span><span class="nx">P</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">p</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Plus</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If a constraint is specified for any type parameter, every type
parameter must have a constraint.
If some type parameters need a constraint and some do not, those that
do not should have a constraint of <code class="docutils literal notranslate"><span class="pre">interface{}</span></code>.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// StrAndPrint takes a slice of labels, which can be any type,</span>
<span class="c1">// and a slice of values, which must have a String method,</span>
<span class="c1">// converts the values to strings, and prints the labelled strings.</span>
<span class="kd">func</span> <span class="nx">StrAndPrint</span><span class="p">(</span><span class="kd">type</span> <span class="nx">L</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">T</span> <span class="nx">Stringer</span><span class="p">)(</span><span class="nx">labels</span> <span class="p">[]</span><span class="nx">L</span><span class="p">,</span> <span class="nx">vals</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Stringify was defined above. It returns a []string.</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">s</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">Stringify</span><span class="p">(</span><span class="nx">vals</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">labels</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">s</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A single constraint can be used for multiple type parameters, just as
a single type can be used for multiple non-type function parameters.
The constraint applies to each type parameter separately.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Stringify2 converts two slices of different types to strings,</span>
<span class="c1">// and returns the concatenation of all the strings.</span>
<span class="kd">func</span> <span class="nx">Stringify2</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span> <span class="nx">Stringer</span><span class="p">)(</span><span class="nx">s1</span> <span class="p">[]</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">s2</span> <span class="p">[]</span><span class="nx">T2</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="s">&quot;&quot;</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v1</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s1</span> <span class="p">{</span>
		<span class="nx">r</span> <span class="o">+=</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v2</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s2</span> <span class="p">{</span>
		<span class="nx">r</span> <span class="o">+=</span> <span class="nx">v2</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="generic-types">
<h3>Generic types<a class="headerlink" href="#generic-types" title="Permalink to this headline">¶</a></h3>
<p>We want more than just generic functions: we also want generic types.
We suggest that types be extended to take type parameters.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Vector is a name for a slice of any element type.</span>
<span class="kd">type</span> <span class="nx">Vector</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="p">[]</span><span class="nx">T</span>
</pre></div>
</div>
<p>A type’s parameters are just like a function’s type parameters.</p>
<p>Within the type definition, the type parameters may be used like any
other type.</p>
<p>To use a generic type, you must supply type arguments.
This looks like a function call, except that the function in this case
is actually a type.
This is called <em>instantiation</em>.
When we instantiate a type by supplying type arguments for the type
parameters, we produce a type in which each use of a type parameter in
the type definition is replaced by the corresponding type argument.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// v is a Vector of int values.</span>
<span class="c1">//</span>
<span class="c1">// This is similar to pretending that &quot;Vector(int)&quot; is a valid identifier,</span>
<span class="c1">// and writing</span>
<span class="c1">//   type &quot;Vector(int)&quot; []int</span>
<span class="c1">//   var v &quot;Vector(int)&quot;</span>
<span class="c1">// All uses of Vector(int) will refer to the same &quot;Vector(int)&quot; type.</span>
<span class="c1">//</span>
<span class="kd">var</span> <span class="nx">v</span> <span class="nx">Vector</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
</pre></div>
</div>
<p>Generic types can have methods.
The receiver type of a method must declare the same number of type
parameters as are declared in the receiver type’s definition.
They are declared without the <code class="docutils literal notranslate"><span class="pre">type</span></code> keyword or any constraint.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Push adds a value to the end of a vector.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Vector</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Push</span><span class="p">(</span><span class="nx">x</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span> <span class="o">*</span><span class="nx">v</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">v</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>The type parameters listed in a method declaration need not have the
same names as the type parameters in the type declaration.
In particular, if they are not used by the method, they can be <code class="docutils literal notranslate"><span class="pre">_</span></code>.</p>
<p>A generic type can refer to itself in cases where a type can
ordinarily refer to itself, but when it does so the type arguments
must be the type parameters, listed in the same order.
This restriction prevents infinite recursion of type instantiation.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// List is a linked list of values of type T.</span>
<span class="kd">type</span> <span class="nx">List</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">next</span> <span class="o">*</span><span class="nx">List</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="c1">// this reference to List(T) is OK</span>
	<span class="nx">val</span>  <span class="nx">T</span>
<span class="p">}</span>

<span class="c1">// This type is INVALID.</span>
<span class="kd">type</span> <span class="nx">P</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">F</span> <span class="o">*</span><span class="nx">P</span><span class="p">(</span><span class="nx">T2</span><span class="p">,</span> <span class="nx">T1</span><span class="p">)</span> <span class="c1">// INVALID; must be (T1, T2)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This restriction applies to both direct and indirect references.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// ListHead is the head of a linked list.</span>
<span class="kd">type</span> <span class="nx">ListHead</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">head</span> <span class="o">*</span><span class="nx">ListElement</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// ListElement is an element in a linked list with a head.</span>
<span class="c1">// Each element points back to the head.</span>
<span class="kd">type</span> <span class="nx">ListElement</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">next</span> <span class="o">*</span><span class="nx">ListElement</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span>
	<span class="nx">val</span>  <span class="nx">T</span>
	<span class="c1">// Using ListHead(T) here is OK.</span>
	<span class="c1">// ListHead(T) refers to ListElement(T) refers to ListHead(T).</span>
	<span class="c1">// Using ListHead(int) would not be OK, as ListHead(T)</span>
	<span class="c1">// would have an indirect reference to ListHead(int).</span>
	<span class="nx">head</span> <span class="o">*</span><span class="nx">ListHead</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>(Note: with more understanding of how people want to write code, it
may be possible to relax this rule to permit some cases that use
different type arguments.)</p>
<p>The type parameter of a generic type may have constraints.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// StringableVector is a slice of some type, where the type</span>
<span class="c1">// must have a String method.</span>
<span class="kd">type</span> <span class="nx">StringableVector</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">Stringer</span><span class="p">)</span> <span class="p">[]</span><span class="nx">T</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">StringableVector</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">sb</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Builder</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">sb</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// It&#39;s OK to call v.String here because v is of type T</span>
		<span class="c1">// and T&#39;s constraint is Stringer.</span>
		<span class="nx">sb</span><span class="p">.</span><span class="nx">WriteString</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">sb</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="methods-may-not-take-additional-type-arguments">
<h3>Methods may not take additional type arguments<a class="headerlink" href="#methods-may-not-take-additional-type-arguments" title="Permalink to this headline">¶</a></h3>
<p>Although methods of a generic type may use the type’s parameters,
methods may not themselves have additional type parameters.
Where it would be useful to add type arguments to a method, people
will have to write a suitably parameterized top-level function.</p>
<p>This is not a fundamental restriction but it complicates the language
specification and the implementation.</p>
<p>(Note: this is a feature that can perhaps be added later if it proves
necessary.)</p>
</div>
<div class="section" id="operators">
<h3>Operators<a class="headerlink" href="#operators" title="Permalink to this headline">¶</a></h3>
<p>As we’ve seen, we are using interface types as constraints.
Interface types provide a set of methods, and nothing else.
This means that with what we’ve seen so far, the only thing that
generic functions can do with values of type parameters, other than
operations that are permitted for any type, is call methods.</p>
<p>However, method calls are not sufficient for everything we want to
express.
Consider this simple function that returns the smallest element of a
slice of values, where the slice is assumed to be non-empty.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// This function is INVALID.</span>
<span class="kd">func</span> <span class="nx">Smallest</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">// panic if slice is empty</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">v</span> <span class="p">&lt;</span> <span class="nx">r</span> <span class="p">{</span> <span class="c1">// INVALID</span>
			<span class="nx">r</span> <span class="p">=</span> <span class="nx">v</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Any reasonable generics implementation should let you write this
function.
The problem is the expression <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">&lt;</span> <span class="pre">r</span></code>.
This assumes that <code class="docutils literal notranslate"><span class="pre">T</span></code> supports the <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> operator, but <code class="docutils literal notranslate"><span class="pre">T</span></code> has no
constraint.
Without a constraint the function <code class="docutils literal notranslate"><span class="pre">Smallest</span></code> can only use operations
that are available for all types, but not all Go types support <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>.
Unfortunately, since <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> is not a method, there is no obvious way to
write a constraint—an interface type—that permits <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>.</p>
<p>We need a way to write a constraint that accepts only types that
support <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>.
In order to do that, we observe that, aside from two exceptions that
we will discuss later, all the arithmetic, comparison, and logical
operators defined by the language may only be used with types that are
predeclared by the language, or with defined types whose underlying
type is one of those predeclared types.
That is, the operator <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> can only be used with a predeclared type
such as <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">float64</span></code>, or a defined type whose underlying type is
one of those types.
Go does not permit using <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> with a composite type or with an
arbitrary defined type.</p>
<p>This means that rather than try to write a constraint for <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, we can
approach this the other way around: instead of saying which operators
a constraint should support, we can say which (underlying) types a
constraint should accept.</p>
<div class="section" id="type-lists-in-constraints">
<h4>Type lists in constraints<a class="headerlink" href="#type-lists-in-constraints" title="Permalink to this headline">¶</a></h4>
<p>An interface type used as a constraint may list explicit types that
may be used as type arguments.
This is done using the <code class="docutils literal notranslate"><span class="pre">type</span></code> keyword followed by a comma-separated
list of types.</p>
<p>For example:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// SignedInteger is a type constraint that permits any</span>
<span class="c1">// signed integer type.</span>
<span class="kd">type</span> <span class="nx">SignedInteger</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="kd">type</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int8</span><span class="p">,</span> <span class="kt">int16</span><span class="p">,</span> <span class="kt">int32</span><span class="p">,</span> <span class="kt">int64</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">SignedInteger</span></code> constraint specifies that the type argument
must be one of the listed types.
More precisely, the underlying type of the type argument must be
identical to the underlying type of one of the types in the type
list.
This means that <code class="docutils literal notranslate"><span class="pre">SignedInteger</span></code> will accept the listed integer types,
and will also accept any type that is defined as one of those types.</p>
<p>When a generic function uses a type parameter with one of these
constraints, it may use any operation that is permitted by all of the
listed types.
This can be an operation like <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">range</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;-</span></code>, and so forth.
If the function can be compiled successfully using each type listed in
the constraint, then the operation is permitted.</p>
<p>A constraint may only have one type list.</p>
<p>For the <code class="docutils literal notranslate"><span class="pre">Smallest</span></code> example shown earlier, we could use a constraint
like this:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">constraints</span>

<span class="c1">// Ordered is a type constraint that matches any ordered type.</span>
<span class="c1">// An ordered type is one that supports the &lt;, &lt;=, &gt;, and &gt;= operators.</span>
<span class="kd">type</span> <span class="nx">Ordered</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="kd">type</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int8</span><span class="p">,</span> <span class="kt">int16</span><span class="p">,</span> <span class="kt">int32</span><span class="p">,</span> <span class="kt">int64</span><span class="p">,</span>
		<span class="kt">uint</span><span class="p">,</span> <span class="kt">uint8</span><span class="p">,</span> <span class="kt">uint16</span><span class="p">,</span> <span class="kt">uint32</span><span class="p">,</span> <span class="kt">uint64</span><span class="p">,</span> <span class="kt">uintptr</span><span class="p">,</span>
		<span class="kt">float32</span><span class="p">,</span> <span class="kt">float64</span><span class="p">,</span>
		<span class="kt">string</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In practice this constraint would likely be defined and exported in a
new standard library package, <code class="docutils literal notranslate"><span class="pre">constraints</span></code>, so that it could be used
by function and type definitions.</p>
<p>Given that constraint, we can write this function, now valid:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Smallest returns the smallest element in a slice.</span>
<span class="c1">// It panics if the slice is empty.</span>
<span class="kd">func</span> <span class="nx">Smallest</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">constraints</span><span class="p">.</span><span class="nx">Ordered</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">// panics if slice is empty</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">v</span> <span class="p">&lt;</span> <span class="nx">r</span> <span class="p">{</span>
			<span class="nx">r</span> <span class="p">=</span> <span class="nx">v</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="comparable-types-in-constraints">
<h4>Comparable types in constraints<a class="headerlink" href="#comparable-types-in-constraints" title="Permalink to this headline">¶</a></h4>
<p>Earlier we mentioned that there are two exceptions to the rule that
operators may only be used with types that are predeclared by the
language.
The exceptions are <code class="docutils literal notranslate"><span class="pre">==</span></code> and <code class="docutils literal notranslate"><span class="pre">!=</span></code>, which are permitted for struct,
array, and interface types.
These are useful enough that we want to be able to write a constraint
that accepts any comparable type.</p>
<p>To do this we introduce a new predeclared type constraint:
<code class="docutils literal notranslate"><span class="pre">comparable</span></code>.
A type parameter with the <code class="docutils literal notranslate"><span class="pre">comparable</span></code> constraint accepts as a type
argument any comparable type.
It permits the use of <code class="docutils literal notranslate"><span class="pre">==</span></code> and <code class="docutils literal notranslate"><span class="pre">!=</span></code> with values of that type parameter.</p>
<p>For example, this function may be instantiated with any comparable
type:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Index returns the index of x in s, or -1 if not found.</span>
<span class="kd">func</span> <span class="nx">Index</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">comparable</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">x</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="c1">// v and x are type T, which has the comparable</span>
		<span class="c1">// constraint, so we can use == here.</span>
		<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="nx">x</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">i</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">comparable</span></code>, like all constraints, is an interface type, it can
be embedded in another interface type used as a constraint:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// ComparableHasher is a type constraint that matches all</span>
<span class="c1">// comparable types with a Hash method.</span>
<span class="kd">type</span> <span class="nx">ComparableHasher</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">comparable</span>
	<span class="nx">Hash</span><span class="p">()</span> <span class="kt">uintptr</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The constraint <code class="docutils literal notranslate"><span class="pre">ComparableHasher</span></code> is implemented by any type that is
comparable and also has a <code class="docutils literal notranslate"><span class="pre">Hash()</span> <span class="pre">uintptr</span></code> method.
A generic function that uses <code class="docutils literal notranslate"><span class="pre">ComparableHasher</span></code> as a constraint can
compare values of that type and can call the <code class="docutils literal notranslate"><span class="pre">Hash</span></code> method.</p>
</div>
<div class="section" id="type-lists-in-interface-types">
<h4>Type lists in interface types<a class="headerlink" href="#type-lists-in-interface-types" title="Permalink to this headline">¶</a></h4>
<p>Interface types with type lists may only be used as constraints on
type parameters.
They may not be used as ordinary interface types.
The same is true of the predeclared interface type <code class="docutils literal notranslate"><span class="pre">comparable</span></code>.</p>
<p>This restriction may be lifted in future language versions.
An interface type with a type list may be useful as a form of sum
type, albeit one that can have the value <code class="docutils literal notranslate"><span class="pre">nil</span></code>.
Some alternative syntax would likely be required to match on identical
types rather than on underlying types; perhaps <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">==</span></code>.
For now, this is not permitted.</p>
</div>
</div>
<div class="section" id="function-argument-type-inference">
<h3>Function argument type inference<a class="headerlink" href="#function-argument-type-inference" title="Permalink to this headline">¶</a></h3>
<p>In many cases, when calling a function with type parameters, we can
use type inference to avoid having to explicitly write out the type
arguments.</p>
<p>Go back to <a class="reference external" href="#Type-parameters">the example</a> of a call to the simple
<code class="docutils literal notranslate"><span class="pre">Print</span></code> function:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span>	<span class="nx">Print</span><span class="p">(</span><span class="kt">int</span><span class="p">)([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">})</span>
</pre></div>
</div>
<p>The type argument <code class="docutils literal notranslate"><span class="pre">int</span></code> in the function call can be inferred from the
type of the non-type argument.</p>
<p>This can only be done when all the function’s type parameters are used
for the types of the function’s (non-type) input parameters.
If there are some type parameters that are used only for the
function’s result parameter types, or only in the body of the
function, then our algorithm does not infer the type arguments for the
function, since there is no value from which to infer the types.</p>
<p>When the function’s type arguments can be inferred, the language uses
type unification.
On the caller side we have the list of types of the actual (non-type)
arguments, which for the <code class="docutils literal notranslate"><span class="pre">Print</span></code> example is simply <code class="docutils literal notranslate"><span class="pre">[]int</span></code>.
On the function side is the list of the types of the function’s
non-type parameters, which for <code class="docutils literal notranslate"><span class="pre">Print</span></code> is <code class="docutils literal notranslate"><span class="pre">[]T</span></code>.
In the lists, we discard respective arguments for which the function
side does not use a type parameter.
We must then unify the remaining argument types.</p>
<p>Type unification is a two-pass algorithm.
In the first pass, we ignore untyped constants on the caller side and
their corresponding types in the function definition.</p>
<p>We compare corresponding types in the lists.
Their structure must be identical, except that type parameters on the
function side match the type that appears on the caller side at the
point where the type parameter occurs.
If the same type parameter appears more than once on the function
side, it will match multiple argument types on the caller side.
Those caller types must be identical, or type unification fails, and
we report an error.</p>
<p>After the first pass, we check any untyped constants on the caller
side.
If there are no untyped constants, or if the type parameters in the
corresponding function types have matched other input types, then
type unification is complete.</p>
<p>Otherwise, for the second pass, for any untyped constants whose
corresponding function types are not yet set, we determine the default
type of the untyped constant in <a class="reference external" href="https://golang.org/ref/spec#Constants">the usual
way</a>.
Then we run the type unification algorithm again, this time with no
untyped constants.</p>
<p>In this example</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span>	<span class="nx">s1</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
	<span class="nx">Print</span><span class="p">(</span><span class="nx">s1</span><span class="p">)</span>
</pre></div>
</div>
<p>we compare <code class="docutils literal notranslate"><span class="pre">[]int</span></code> with <code class="docutils literal notranslate"><span class="pre">[]T</span></code>, match <code class="docutils literal notranslate"><span class="pre">T</span></code> with <code class="docutils literal notranslate"><span class="pre">int</span></code>, and we are done.
The single type parameter <code class="docutils literal notranslate"><span class="pre">T</span></code> is <code class="docutils literal notranslate"><span class="pre">int</span></code>, so we infer that the call to
<code class="docutils literal notranslate"><span class="pre">Print</span></code> is really a call to <code class="docutils literal notranslate"><span class="pre">Print(int)</span></code>.</p>
<p>For a more complex example, consider</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Map calls the function f on every element of the slice s,</span>
<span class="c1">// returning a new slice of the results.</span>
<span class="kd">func</span> <span class="nx">Map</span><span class="p">(</span><span class="kd">type</span> <span class="nx">F</span><span class="p">,</span> <span class="nx">T</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">F</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">F</span><span class="p">)</span> <span class="nx">T</span><span class="p">)</span> <span class="p">[]</span><span class="nx">T</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The two type parameters <code class="docutils literal notranslate"><span class="pre">F</span></code> and <code class="docutils literal notranslate"><span class="pre">T</span></code> are both used for input
parameters, so type inference is possible.
In the call</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span>	<span class="nx">strs</span> <span class="o">:=</span> <span class="nx">Map</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Itoa</span><span class="p">)</span>
</pre></div>
</div>
<p>we unify <code class="docutils literal notranslate"><span class="pre">[]int</span></code> with <code class="docutils literal notranslate"><span class="pre">[]F</span></code>, matching <code class="docutils literal notranslate"><span class="pre">F</span></code> with <code class="docutils literal notranslate"><span class="pre">int</span></code>.
We unify the type of <code class="docutils literal notranslate"><span class="pre">strconv.Itoa</span></code>, which is <code class="docutils literal notranslate"><span class="pre">func(int)</span> <span class="pre">string</span></code>,
with <code class="docutils literal notranslate"><span class="pre">func(F)</span> <span class="pre">T</span></code>, matching <code class="docutils literal notranslate"><span class="pre">F</span></code> with <code class="docutils literal notranslate"><span class="pre">int</span></code> and <code class="docutils literal notranslate"><span class="pre">T</span></code> with <code class="docutils literal notranslate"><span class="pre">string</span></code>.
The type parameter <code class="docutils literal notranslate"><span class="pre">F</span></code> is matched twice, both times with <code class="docutils literal notranslate"><span class="pre">int</span></code>.
Unification succeeds, so the call written as <code class="docutils literal notranslate"><span class="pre">Map</span></code> is a call of
<code class="docutils literal notranslate"><span class="pre">Map(int,</span> <span class="pre">string)</span></code>.</p>
<p>To see the untyped constant rule in effect, consider:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// NewPair returns a pair of values of the same type.</span>
<span class="kd">func</span> <span class="nx">NewPair</span><span class="p">(</span><span class="kd">type</span> <span class="nx">F</span><span class="p">)(</span><span class="nx">f1</span><span class="p">,</span> <span class="nx">f2</span> <span class="nx">F</span><span class="p">)</span> <span class="o">*</span><span class="nx">Pair</span><span class="p">(</span><span class="nx">F</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>In the call <code class="docutils literal notranslate"><span class="pre">NewPair(1,</span> <span class="pre">2)</span></code> both arguments are untyped constants, so
both are ignored in the first pass.
There is nothing to unify.
We still have two untyped constants after the first pass.
Both are set to their default type, <code class="docutils literal notranslate"><span class="pre">int</span></code>.
The second run of the type unification pass unifies <code class="docutils literal notranslate"><span class="pre">F</span></code> with
<code class="docutils literal notranslate"><span class="pre">int</span></code>, so the final call is <code class="docutils literal notranslate"><span class="pre">NewPair(int)(1,</span> <span class="pre">2)</span></code>.</p>
<p>In the call <code class="docutils literal notranslate"><span class="pre">NewPair(1,</span> <span class="pre">int64(2))</span></code> the first argument is an untyped
constant, so we ignore it in the first pass.
We then unify <code class="docutils literal notranslate"><span class="pre">int64</span></code> with <code class="docutils literal notranslate"><span class="pre">F</span></code>.
At this point the type parameter corresponding to the untyped constant
is fully determined, so the final call is <code class="docutils literal notranslate"><span class="pre">NewPair(int64)(1,</span> <span class="pre">int64(2))</span></code>.</p>
<p>In the call <code class="docutils literal notranslate"><span class="pre">NewPair(1,</span> <span class="pre">2.5)</span></code> both arguments are untyped constants,
so we move on the second pass.
This time we set the first constant to <code class="docutils literal notranslate"><span class="pre">int</span></code> and the second to
<code class="docutils literal notranslate"><span class="pre">float64</span></code>.
We then try to unify <code class="docutils literal notranslate"><span class="pre">F</span></code> with both <code class="docutils literal notranslate"><span class="pre">int</span></code> and <code class="docutils literal notranslate"><span class="pre">float64</span></code>, so unification
fails, and we report a compilation error.</p>
<p>Note that type inference is done without regard to constraints.
First we use type inference to determine the type arguments to use for
the function, and then, if that succeeds, we check whether those type
arguments implement the constraints (if any).</p>
<p>Note that after successful type inference, the compiler must still
check that the arguments can be assigned to the parameters, as for any
function call.</p>
<p>(Note: type inference is a convenience feature.
Although we think it is an important feature, it does not add any
functionality to the design, only convenience in using it.
It would be possible to omit it from the initial implementation, and
see whether it seems to be needed.
That said, this feature doesn’t require additional syntax, and
produces more readable code.)</p>
</div>
<div class="section" id="using-types-that-refer-to-themselves-in-constraints">
<h3>Using types that refer to themselves in constraints<a class="headerlink" href="#using-types-that-refer-to-themselves-in-constraints" title="Permalink to this headline">¶</a></h3>
<p>It can be useful for a generic function to require a type argument
with a method whose argument is the type itself.
For example, this arises naturally in comparison methods.
(Note that we are talking about methods here, not operators.)
Suppose we want to write an <code class="docutils literal notranslate"><span class="pre">Index</span></code> method that uses an <code class="docutils literal notranslate"><span class="pre">Equal</span></code> method
to check whether it has found the desired value.
We would like to write that like this:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Index returns the index of e in s, or -1 if not found.</span>
<span class="kd">func</span> <span class="nx">Index</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">Equaler</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">e</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Equal</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">i</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In order to write the <code class="docutils literal notranslate"><span class="pre">Equaler</span></code> constraint, we have to write a
constraint that can refer to the type argument being passed in.
There is no way to do that directly, but what we can do is write an
interface type that use a type parameter.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Equaler is a type constraint for types with an Equal method.</span>
<span class="kd">type</span> <span class="nx">Equaler</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Equal</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To make this work, <code class="docutils literal notranslate"><span class="pre">Index</span></code> will pass <code class="docutils literal notranslate"><span class="pre">T</span></code> as the type argument to
<code class="docutils literal notranslate"><span class="pre">Equaler</span></code>.
The rule is that if a type contraint has a single type parameter, and
it is used in a function’s type parameter list without an explicit
type argument, then the type argument is the type parameter being
constrained.
In other words, in the definition of <code class="docutils literal notranslate"><span class="pre">Index</span></code> above, the constraint
<code class="docutils literal notranslate"><span class="pre">Equaler</span></code> is treated as <code class="docutils literal notranslate"><span class="pre">Equaler(T)</span></code>.</p>
<p>This version of <code class="docutils literal notranslate"><span class="pre">Index</span></code> would be used with a type like <code class="docutils literal notranslate"><span class="pre">equalInt</span></code>
defined here:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// equalInt is a version of int that implements Equaler.</span>
<span class="kd">type</span> <span class="nx">equalInt</span> <span class="kt">int</span>

<span class="c1">// The Equal method lets equalInt implement the Equaler constraint.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="nx">equalInt</span><span class="p">)</span> <span class="nx">Equal</span><span class="p">(</span><span class="nx">b</span> <span class="nx">equalInt</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">a</span> <span class="o">==</span> <span class="nx">b</span> <span class="p">}</span>

<span class="c1">// indexEqualInts returns the index of e in s, or -1 if not found.</span>
<span class="kd">func</span> <span class="nx">indexEqualInt</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">equalInt</span><span class="p">,</span> <span class="nx">e</span> <span class="nx">equalInt</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">Index</span><span class="p">(</span><span class="nx">equalInt</span><span class="p">)(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example, when we pass <code class="docutils literal notranslate"><span class="pre">equalInt</span></code> to <code class="docutils literal notranslate"><span class="pre">Index</span></code>, we check whether
<code class="docutils literal notranslate"><span class="pre">equalInt</span></code> implements the constraint <code class="docutils literal notranslate"><span class="pre">Equaler</span></code>.
Since <code class="docutils literal notranslate"><span class="pre">Equaler</span></code> has a type parameter, we pass the type argument of
<code class="docutils literal notranslate"><span class="pre">Index</span></code>, which is <code class="docutils literal notranslate"><span class="pre">equalInt</span></code>, as the type argument to <code class="docutils literal notranslate"><span class="pre">Equaler</span></code>.
The constraint is, then, <code class="docutils literal notranslate"><span class="pre">Equaler(equalInt)</span></code>, which is satisfied
by any type with a method <code class="docutils literal notranslate"><span class="pre">Equal(equalInt)</span> <span class="pre">bool</span></code>.
The <code class="docutils literal notranslate"><span class="pre">equalInt</span></code> type has a method <code class="docutils literal notranslate"><span class="pre">Equal</span></code> that accepts a parameter of
type <code class="docutils literal notranslate"><span class="pre">equalInt</span></code>, so all is well, and the compilation succeeds.</p>
</div>
<div class="section" id="mutually-referencing-type-parameters">
<h3>Mutually referencing type parameters<a class="headerlink" href="#mutually-referencing-type-parameters" title="Permalink to this headline">¶</a></h3>
<p>Within a single type parameter list, constraints may refer to any of
the other type parameters, even ones that are declared later in the
same list.
(The scope of a type parameter starts at the <code class="docutils literal notranslate"><span class="pre">type</span></code> keyword of the
parameter list and extends to the end of the enclosing function or
type declaration.)</p>
<p>For example, consider a generic graph package that contains generic
algorithms that work with graphs.
The algorithms use two types, <code class="docutils literal notranslate"><span class="pre">Node</span></code> and <code class="docutils literal notranslate"><span class="pre">Edge</span></code>.
<code class="docutils literal notranslate"><span class="pre">Node</span></code> is expected to have a method <code class="docutils literal notranslate"><span class="pre">Edges()</span> <span class="pre">[]Edge</span></code>.
<code class="docutils literal notranslate"><span class="pre">Edge</span></code> is expected to have a method <code class="docutils literal notranslate"><span class="pre">Nodes()</span> <span class="pre">(Node,</span> <span class="pre">Node)</span></code>.
A graph can be represented as a <code class="docutils literal notranslate"><span class="pre">[]Node</span></code>.</p>
<p>This simple representation is enough to implement graph algorithms
like finding the shortest path.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">graph</span>

<span class="c1">// NodeConstraint is the type constraint for graph nodes:</span>
<span class="c1">// they must have an Edges method that returns the Edge&#39;s</span>
<span class="c1">// that connect to this Node.</span>
<span class="kd">type</span> <span class="nx">NodeConstraint</span><span class="p">(</span><span class="kd">type</span> <span class="nx">Edge</span><span class="p">)</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Edges</span><span class="p">()</span> <span class="p">[]</span><span class="nx">Edge</span>
<span class="p">}</span>

<span class="c1">// EdgeConstraint is the type constraint for graph edges:</span>
<span class="c1">// they must have a Nodes method that returns the two Nodes</span>
<span class="c1">// that this edge connects.</span>
<span class="kd">type</span> <span class="nx">EdgeConstraint</span><span class="p">(</span><span class="kd">type</span> <span class="nx">Node</span><span class="p">)</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Nodes</span><span class="p">()</span> <span class="p">(</span><span class="nx">from</span><span class="p">,</span> <span class="nx">to</span> <span class="nx">Node</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Graph is a graph composed of nodes and edges.</span>
<span class="kd">type</span> <span class="nx">Graph</span><span class="p">(</span><span class="kd">type</span> <span class="nx">Node</span> <span class="nx">NodeConstraint</span><span class="p">(</span><span class="nx">Edge</span><span class="p">),</span> <span class="nx">Edge</span> <span class="nx">EdgeConstraint</span><span class="p">(</span><span class="nx">Node</span><span class="p">))</span> <span class="kd">struct</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="c1">// New returns a new graph given a list of nodes.</span>
<span class="kd">func</span> <span class="nx">New</span><span class="p">(</span>
	<span class="kd">type</span> <span class="nx">Node</span> <span class="nx">NodeConstraint</span><span class="p">(</span><span class="nx">Edge</span><span class="p">),</span> <span class="nx">Edge</span> <span class="nx">EdgeConstraint</span><span class="p">(</span><span class="nx">Node</span><span class="p">))</span> <span class="p">(</span>
	<span class="nx">nodes</span> <span class="p">[]</span><span class="nx">Node</span><span class="p">)</span> <span class="o">*</span><span class="nx">Graph</span><span class="p">(</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">Edge</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
<span class="p">}</span>

<span class="c1">// ShortestPath returns the shortest path between two nodes,</span>
<span class="c1">// as a list of edges.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">Graph</span><span class="p">(</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">Edge</span><span class="p">))</span> <span class="nx">ShortestPath</span><span class="p">(</span><span class="nx">from</span><span class="p">,</span> <span class="nx">to</span> <span class="nx">Node</span><span class="p">)</span> <span class="p">[]</span><span class="nx">Edge</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>There are a lot of type arguments and instantiations here.
In the constraint on <code class="docutils literal notranslate"><span class="pre">Node</span></code> in <code class="docutils literal notranslate"><span class="pre">Graph</span></code>, the <code class="docutils literal notranslate"><span class="pre">Edge</span></code> being passed to the
type constraint <code class="docutils literal notranslate"><span class="pre">NodeConstraint</span></code> is the second type parameter of
<code class="docutils literal notranslate"><span class="pre">Graph</span></code>.
This instantiates <code class="docutils literal notranslate"><span class="pre">NodeConstraint</span></code> with the type parameter <code class="docutils literal notranslate"><span class="pre">Edge</span></code>, so
we see that <code class="docutils literal notranslate"><span class="pre">Node</span></code> must have a method <code class="docutils literal notranslate"><span class="pre">Edges</span></code> that returns a slice of
<code class="docutils literal notranslate"><span class="pre">Edge</span></code>, which is what we want.
The same applies to the constraint on <code class="docutils literal notranslate"><span class="pre">Edge</span></code>, and the same type
parameters and constraints are repeated for the function <code class="docutils literal notranslate"><span class="pre">New</span></code>.
We aren’t claiming that this is simple, but we are claiming that it is
possible.</p>
<p>It’s worth noting that while at first glance this may look like a
typical use of interface types, <code class="docutils literal notranslate"><span class="pre">Node</span></code> and <code class="docutils literal notranslate"><span class="pre">Edge</span></code> are non-interface
types with specific methods.
In order to use <code class="docutils literal notranslate"><span class="pre">graph.Graph</span></code>, the type arguments used for <code class="docutils literal notranslate"><span class="pre">Node</span></code> and
<code class="docutils literal notranslate"><span class="pre">Edge</span></code> have to define methods that follow a certain pattern, but they
don’t have to actually use interface types to do so.
In particular, the methods do not return interface types.</p>
<p>For example, consider these type definitions in some other package:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Vertex is a node in a graph.</span>
<span class="kd">type</span> <span class="nx">Vertex</span> <span class="kd">struct</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="c1">// Edges returns the edges connected to v.</span>
<span class="kd">type</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Vertex</span><span class="p">)</span> <span class="nx">Edges</span><span class="p">()</span> <span class="p">[]</span><span class="o">*</span><span class="nx">FromTo</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="c1">// FromTo is an edge in a graph.</span>
<span class="kd">type</span> <span class="nx">FromTo</span> <span class="kd">struct</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="c1">// Nodes returns the nodes that ft connects.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">ft</span> <span class="o">*</span><span class="nx">FromTo</span><span class="p">)</span> <span class="nx">Nodes</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">Vertex</span><span class="p">,</span> <span class="o">*</span><span class="nx">Vertex</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>There are no interface types here, but we can instantiate
<code class="docutils literal notranslate"><span class="pre">graph.Graph</span></code> using the type arguments <code class="docutils literal notranslate"><span class="pre">*Vertex</span></code> and <code class="docutils literal notranslate"><span class="pre">*FromTo</span></code>.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">g</span> <span class="p">=</span> <span class="nx">graph</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="o">*</span><span class="nx">Vertex</span><span class="p">,</span> <span class="o">*</span><span class="nx">FromTo</span><span class="p">)([]</span><span class="o">*</span><span class="nx">Vertex</span><span class="p">{</span> <span class="o">...</span> <span class="p">})</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">*Vertex</span></code> and <code class="docutils literal notranslate"><span class="pre">*FromTo</span></code> are not interface types, but when used
together they define methods that implement the constraints of
<code class="docutils literal notranslate"><span class="pre">graph.Graph</span></code>.
Note that we couldn’t pass plain <code class="docutils literal notranslate"><span class="pre">Vertex</span></code> or <code class="docutils literal notranslate"><span class="pre">FromTo</span></code> to <code class="docutils literal notranslate"><span class="pre">graph.New</span></code>,
since <code class="docutils literal notranslate"><span class="pre">Vertex</span></code> and <code class="docutils literal notranslate"><span class="pre">FromTo</span></code> do not implement the constraints.
The <code class="docutils literal notranslate"><span class="pre">Edges</span></code> and <code class="docutils literal notranslate"><span class="pre">Nodes</span></code> methods are defined on the pointer types
<code class="docutils literal notranslate"><span class="pre">*Vertex</span></code> and <code class="docutils literal notranslate"><span class="pre">*FromTo</span></code>; the types <code class="docutils literal notranslate"><span class="pre">Vertex</span></code> and <code class="docutils literal notranslate"><span class="pre">FromTo</span></code> do not have
any methods.</p>
<p>When we use a generic interface type as a constraint, we first
instantiate the type with the type argument(s) supplied in the type
parameter list, and then compare the corresponding type argument
against the instantiated constraint.
In this example, the <code class="docutils literal notranslate"><span class="pre">Node</span></code> type argument to <code class="docutils literal notranslate"><span class="pre">graph.New</span></code> has a
constraint <code class="docutils literal notranslate"><span class="pre">NodeConstraint(Edge)</span></code>.
When we call <code class="docutils literal notranslate"><span class="pre">graph.New</span></code> with a <code class="docutils literal notranslate"><span class="pre">Node</span></code> type argument of <code class="docutils literal notranslate"><span class="pre">*Vertex</span></code> and
a <code class="docutils literal notranslate"><span class="pre">Edge</span></code> type argument of <code class="docutils literal notranslate"><span class="pre">*FromTo</span></code>, in order to check the constraint
on <code class="docutils literal notranslate"><span class="pre">Node</span></code> the compiler instantiates <code class="docutils literal notranslate"><span class="pre">NodeConstraint</span></code> with the type
argument <code class="docutils literal notranslate"><span class="pre">*FromTo</span></code>.
That produces an instantiated constraint, in this case a requirement
that <code class="docutils literal notranslate"><span class="pre">Node</span></code> have a method <code class="docutils literal notranslate"><span class="pre">Edges()</span> <span class="pre">[]*FromTo</span></code>, and the compiler
verifies that <code class="docutils literal notranslate"><span class="pre">*Vertex</span></code> satisfies that constraint.</p>
<p>Although <code class="docutils literal notranslate"><span class="pre">Node</span></code> and <code class="docutils literal notranslate"><span class="pre">Edge</span></code> do not have to be instantiated with
interface types, it is also OK to use interface types if you like.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">NodeInterface</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nx">Edges</span><span class="p">()</span> <span class="p">[]</span><span class="nx">EdgeInterface</span> <span class="p">}</span>
<span class="kd">type</span> <span class="nx">EdgeInterface</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nx">Nodes</span><span class="p">()</span> <span class="p">(</span><span class="nx">NodeInterface</span><span class="p">,</span> <span class="nx">NodeInterface</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>We could instantiate <code class="docutils literal notranslate"><span class="pre">graph.Graph</span></code> with the types <code class="docutils literal notranslate"><span class="pre">NodeInterface</span></code> and
<code class="docutils literal notranslate"><span class="pre">EdgeInterface</span></code>, since they implement the type constraints.
There isn’t much reason to instantiate a type this way, but it is
permitted.</p>
<p>This ability for type parameters to refer to other type parameters
illustrates an important point: it should be a requirement for any
attempt to add generics to Go that it be possible to instantiate
generic code with multiple type arguments that refer to each other in
ways that the compiler can check.</p>
</div>
<div class="section" id="pointer-methods">
<h3>Pointer methods<a class="headerlink" href="#pointer-methods" title="Permalink to this headline">¶</a></h3>
<p>There are cases where a generic function will only work as expected if
a type argument <code class="docutils literal notranslate"><span class="pre">A</span></code> has methods defined on the pointer type <code class="docutils literal notranslate"><span class="pre">*A</span></code>.
This happens when writing a generic function that expects to call a
method that modifies a value.</p>
<p>Consider this example of a function that expects a type <code class="docutils literal notranslate"><span class="pre">T</span></code> that has a
<code class="docutils literal notranslate"><span class="pre">Set(string)</span></code> method that initializes the value based on a string.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Setter is a type constraint that requires that the type</span>
<span class="c1">// implement a Set method that sets the value from a string.</span>
<span class="kd">type</span> <span class="nx">Setter</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Set</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// FromStrings takes a slice of strings and returns a slice of T,</span>
<span class="c1">// calling the Set method to set each returned value.</span>
<span class="c1">//</span>
<span class="c1">// Note that because T is only used for a result parameter,</span>
<span class="c1">// type inference does not work when calling this function.</span>
<span class="c1">// The type argument must be passed explicitly at the call site.</span>
<span class="c1">//</span>
<span class="c1">// This example compiles but is unlikely to work as desired.</span>
<span class="kd">func</span> <span class="nx">FromStrings</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">Setter</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="nx">T</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Set</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now let’s see some code in a different package (this example is
invalid).</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Settable is a integer type that can be set from a string.</span>
<span class="kd">type</span> <span class="nx">Settable</span> <span class="kt">int</span>

<span class="c1">// Set sets the value of *p from a string.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Settable</span><span class="p">)</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Atoi</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// real code should not ignore the error</span>
	<span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="nx">Settable</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">F</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// INVALID</span>
	<span class="nx">nums</span> <span class="o">:=</span> <span class="nx">FromStrings</span><span class="p">(</span><span class="nx">Settable</span><span class="p">)([]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">})</span>
	<span class="c1">// Here we want nums to be []Settable{1, 2}.</span>
	<span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The goal is to use <code class="docutils literal notranslate"><span class="pre">FromStrings</span></code> to get a slice of type <code class="docutils literal notranslate"><span class="pre">[]Settable</span></code>.
Unfortunately, this example is not valid and will not compile.</p>
<p>The problem is that <code class="docutils literal notranslate"><span class="pre">FromStrings</span></code> requires a type that has a
<code class="docutils literal notranslate"><span class="pre">Set(string)</span></code> method.
The function <code class="docutils literal notranslate"><span class="pre">F</span></code> is trying to instantiate <code class="docutils literal notranslate"><span class="pre">FromStrings</span></code> with
<code class="docutils literal notranslate"><span class="pre">Settable</span></code>, but <code class="docutils literal notranslate"><span class="pre">Settable</span></code> does not have a <code class="docutils literal notranslate"><span class="pre">Set</span></code> method.
The type that has a <code class="docutils literal notranslate"><span class="pre">Set</span></code> method is <code class="docutils literal notranslate"><span class="pre">*Settable</span></code>.</p>
<p>So let’s rewrite <code class="docutils literal notranslate"><span class="pre">F</span></code> to use <code class="docutils literal notranslate"><span class="pre">*Settable</span></code> instead.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">F</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Compiles but does not work as desired.</span>
	<span class="c1">// This will panic at run time when calling the Set method.</span>
	<span class="nx">nums</span> <span class="o">:=</span> <span class="nx">FromStrings</span><span class="p">(</span><span class="o">*</span><span class="nx">Settable</span><span class="p">)([]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">})</span>
	<span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This compiles but unfortunately it will panic at run time.
The problem is that <code class="docutils literal notranslate"><span class="pre">FromStrings</span></code> creates a slice of type <code class="docutils literal notranslate"><span class="pre">[]T</span></code>.
When instantiated with <code class="docutils literal notranslate"><span class="pre">*Settable</span></code>, that means a slice of type
<code class="docutils literal notranslate"><span class="pre">[]*Settable</span></code>.
When <code class="docutils literal notranslate"><span class="pre">FromStrings</span></code> calls <code class="docutils literal notranslate"><span class="pre">result[i].Set(v)</span></code>, that passes the pointer
stored in <code class="docutils literal notranslate"><span class="pre">result[i]</span></code> to the <code class="docutils literal notranslate"><span class="pre">Set</span></code> method.
That pointer is <code class="docutils literal notranslate"><span class="pre">nil</span></code>.
The <code class="docutils literal notranslate"><span class="pre">Settable.Set</span></code> method will be invoked with a <code class="docutils literal notranslate"><span class="pre">nil</span></code> receiver,
and will raise a panic due to a <code class="docutils literal notranslate"><span class="pre">nil</span></code> dereference error.</p>
<p>What we need is a way to write <code class="docutils literal notranslate"><span class="pre">FromStrings</span></code> such that it can take
the type <code class="docutils literal notranslate"><span class="pre">Settable</span></code> as an argument but invoke a pointer method.
To repeat, we can’t use <code class="docutils literal notranslate"><span class="pre">Settable</span></code> because it doesn’t have a <code class="docutils literal notranslate"><span class="pre">Set</span></code>
method, and we can’t use <code class="docutils literal notranslate"><span class="pre">*Settable</span></code> because then we can’t create a
slice of type <code class="docutils literal notranslate"><span class="pre">Settable</span></code>.</p>
<p>One approach that could work would be to use two different type
parameters: both <code class="docutils literal notranslate"><span class="pre">Settable</span></code> and <code class="docutils literal notranslate"><span class="pre">*Settable</span></code>.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">from</span>

<span class="c1">// Setter2 is a type constraint that requires that the type</span>
<span class="c1">// implement a Set method that sets the value from a string,</span>
<span class="c1">// and also requires that the type be a pointer to its type parameter.</span>
<span class="kd">type</span> <span class="nx">Setter2</span><span class="p">(</span><span class="kd">type</span> <span class="nx">B</span><span class="p">)</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Set</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>
	<span class="kd">type</span> <span class="o">*</span><span class="nx">B</span>
<span class="p">}</span>

<span class="c1">// FromStrings2 takes a slice of strings and returns a slice of T,</span>
<span class="c1">// calling the Set method to set each returned value.</span>
<span class="c1">//</span>
<span class="c1">// We use two different type parameters so that we can return</span>
<span class="c1">// a slice of type T but call methods on *T.</span>
<span class="c1">// The Setter2 constraint ensures that PT is a pointer to T.</span>
<span class="kd">func</span> <span class="nx">FromStrings2</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">PT</span> <span class="nx">Setter2</span><span class="p">(</span><span class="nx">T</span><span class="p">))(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="nx">T</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="c1">// The type of &amp;result[i] is *T which is in the type list</span>
		<span class="c1">// of Setter2, so we can convert it to PT.</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">PT</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="c1">// PT has a Set method.</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We would call <code class="docutils literal notranslate"><span class="pre">FromStrings2</span></code> like this:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">F2</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// FromStrings2 takes two type parameters.</span>
	<span class="c1">// The second parameter must be a pointer to the first.</span>
	<span class="c1">// Settable is as above.</span>
	<span class="nx">nums</span> <span class="o">:=</span> <span class="nx">FromStrings2</span><span class="p">(</span><span class="nx">Settable</span><span class="p">,</span> <span class="o">*</span><span class="nx">Settable</span><span class="p">)([]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">})</span>
	<span class="c1">// Now nums is []Settable{1, 2}.</span>
	<span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This approach works as expected, but it is awkward.
It forces <code class="docutils literal notranslate"><span class="pre">F2</span></code> to work around a problem in <code class="docutils literal notranslate"><span class="pre">FromStrings2</span></code> by passing
two type arguments.
The second type argument is required to be a pointer to the first type
argument.
This is a complex requirement for what seems like it ought to be a
reasonably simple case.</p>
<p>Another approach would be to pass in a function rather than calling a
method.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// FromStrings3 takes a slice of strings and returns a slice of T,</span>
<span class="c1">// calling the set function to set each returned value.</span>
<span class="kd">func</span> <span class="nx">FromStrings3</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">set</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">T</span><span class="p">,</span> <span class="kt">string</span><span class="p">))</span> <span class="p">[]</span><span class="nx">T</span> <span class="p">{</span>
	<span class="nx">results</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">set</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">results</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">results</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We would call <code class="docutils literal notranslate"><span class="pre">Strings3</span></code> like this:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">F3</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// FromStrings3 takes a function to set the value.</span>
	<span class="c1">// Settable is as above.</span>
	<span class="nx">nums</span> <span class="o">:=</span> <span class="nx">FromStrings3</span><span class="p">(</span><span class="nx">Settable</span><span class="p">)([]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">},</span>
		<span class="kd">func</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Settable</span><span class="p">,</span> <span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">})</span>
	<span class="c1">// Now nums is []Settable{1, 2}.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This approach also works as expected, but it is also awkward.
The caller has to pass in a function just to call the <code class="docutils literal notranslate"><span class="pre">Set</span></code> method.
This is the kind of boilerplate code that we would hope to avoid when
using generics.</p>
<p>Although these approaches are awkward, they do work.
That said, we suggest another feature to address this kind of issue: a
way to express constraints on the pointer to the type parameter,
rather than on the type parameter itself.
The way to do this is to write the type parameter as though it were a
pointer type: <code class="docutils literal notranslate"><span class="pre">(type</span> <span class="pre">*T</span> <span class="pre">Constraint)</span></code>.</p>
<p>Writing <code class="docutils literal notranslate"><span class="pre">*T</span></code> instead of <code class="docutils literal notranslate"><span class="pre">T</span></code> in a type parameter list changes two
things.
Let’s assume that the type argument at the call site is <code class="docutils literal notranslate"><span class="pre">A</span></code>, and the
constraint is <code class="docutils literal notranslate"><span class="pre">Constraint</span></code> (this syntax may be used without a
constraint, but there is no reason to do so).</p>
<p>The first thing that changes is that <code class="docutils literal notranslate"><span class="pre">Constraint</span></code> is applied to <code class="docutils literal notranslate"><span class="pre">*A</span></code>
rather than <code class="docutils literal notranslate"><span class="pre">A</span></code>.
That is, <code class="docutils literal notranslate"><span class="pre">*A</span></code> must implement <code class="docutils literal notranslate"><span class="pre">Constraint</span></code>.
It’s OK if <code class="docutils literal notranslate"><span class="pre">A</span></code> implements <code class="docutils literal notranslate"><span class="pre">Constraint</span></code>, but the requirement is that
<code class="docutils literal notranslate"><span class="pre">*A</span></code> implement it.
Note that if <code class="docutils literal notranslate"><span class="pre">Constraint</span></code> has any methods, this implies that <code class="docutils literal notranslate"><span class="pre">A</span></code> must
not be a pointer type: if <code class="docutils literal notranslate"><span class="pre">A</span></code> is a pointer type, then <code class="docutils literal notranslate"><span class="pre">*A</span></code> is a
pointer to a pointer, and such types never have any methods.</p>
<p>The second thing that changes is that within the body of the function,
any methods in <code class="docutils literal notranslate"><span class="pre">Constraint</span></code> are treated as though they were pointer
methods.
They may only be invoked on values of type <code class="docutils literal notranslate"><span class="pre">*T</span></code> or addressable values
of type <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// FromStrings takes a slice of strings and returns a slice of T,</span>
<span class="c1">// calling the Set method to set each returned value.</span>
<span class="c1">//</span>
<span class="c1">// We write *T, meaning that given a type argument A,</span>
<span class="c1">// the pointer type *A must implement Setter.</span>
<span class="c1">//</span>
<span class="c1">// Note that because T is only used for a result parameter,</span>
<span class="c1">// type inference does not work when calling this function.</span>
<span class="c1">// The type argument must be passed explicitly at the call site.</span>
<span class="kd">func</span> <span class="nx">FromStrings</span><span class="p">(</span><span class="kd">type</span> <span class="o">*</span><span class="nx">T</span> <span class="nx">Setter</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="nx">T</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="c1">// result[i] is an addressable value of type T,</span>
		<span class="c1">// so it&#39;s OK to call Set.</span>
		<span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Set</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Again, using <code class="docutils literal notranslate"><span class="pre">*T</span></code> here means that given a type argument <code class="docutils literal notranslate"><span class="pre">A</span></code>, the type
<code class="docutils literal notranslate"><span class="pre">*A</span></code> must implement the constraint <code class="docutils literal notranslate"><span class="pre">Setter</span></code>.
In this case, <code class="docutils literal notranslate"><span class="pre">Set</span></code> must be in the method set of <code class="docutils literal notranslate"><span class="pre">*A</span></code>.
Within <code class="docutils literal notranslate"><span class="pre">FromStrings</span></code>, using <code class="docutils literal notranslate"><span class="pre">*T</span></code> means that the <code class="docutils literal notranslate"><span class="pre">Set</span></code> method may only
be called on an addressable value of type <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<p>We can now use this as</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">F</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// With the rewritten FromStrings, this is now OK.</span>
	<span class="c1">// *Settable implements Setter.</span>
	<span class="nx">nums</span> <span class="o">:=</span> <span class="nx">from</span><span class="p">.</span><span class="nx">Strings</span><span class="p">(</span><span class="nx">Settable</span><span class="p">)([]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">})</span>
	<span class="c1">// Here nums is []Settable{1, 2}.</span>
	<span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To be clear, using <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">*T</span> <span class="pre">Setter</span></code> does not mean that the <code class="docutils literal notranslate"><span class="pre">Set</span></code>
method must only be a pointer method.
<code class="docutils literal notranslate"><span class="pre">Set</span></code> could still be a value method.
That would be OK because all value methods are also in the pointer
type’s method set.
In this example that only makes sense if <code class="docutils literal notranslate"><span class="pre">Set</span></code> can be written as a
value method, which might be the case when defining the method on a
struct that contains pointer fields.</p>
</div>
<div class="section" id="using-generic-types-as-unnamed-function-parameter-types">
<h3>Using generic types as unnamed function parameter types<a class="headerlink" href="#using-generic-types-as-unnamed-function-parameter-types" title="Permalink to this headline">¶</a></h3>
<p>When parsing an instantiated type as an unnamed function parameter
type, there is a parsing ambiguity.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">x</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span>
</pre></div>
</div>
<p>In this example we don’t know whether the function has a single
unnamed parameter of the instantiated type <code class="docutils literal notranslate"><span class="pre">x(T)</span></code>, or whether this is
a named parameter <code class="docutils literal notranslate"><span class="pre">x</span></code> of the type <code class="docutils literal notranslate"><span class="pre">(T)</span></code> (written with parentheses).</p>
<p>We would prefer that this mean the former: an unnamed parameter of the
instantiated type <code class="docutils literal notranslate"><span class="pre">x(T)</span></code>.
This is not actually backward compatible with the current language,
where it means the latter.
However, the gofmt program currently rewrites <code class="docutils literal notranslate"><span class="pre">func(x(T))</span></code> to <code class="docutils literal notranslate"><span class="pre">func(x</span> <span class="pre">T)</span></code>, so <code class="docutils literal notranslate"><span class="pre">func(x(T))</span></code> is very unusual in plain Go code.</p>
<p>Therefore, we propose that the language change so that <code class="docutils literal notranslate"><span class="pre">func(x(T))</span></code>
now means a single parameter of type <code class="docutils literal notranslate"><span class="pre">x(T)</span></code>.
This will potentially break some existing programs, but the fix will
be to simply run gofmt.
This will potentially change the meaning of programs that write
<code class="docutils literal notranslate"><span class="pre">func(x(T))</span></code>, that don’t use gofmt, and that choose to introduce a
generic type <code class="docutils literal notranslate"><span class="pre">x</span></code> with the same name as a function parameter with a
parenthesized type.
We believe that such programs will be exceedingly rare.</p>
<p>Still, this is a risk, and if the risk seems too large we can avoid
making this change.</p>
</div>
<div class="section" id="values-of-type-parameters-are-not-boxed">
<h3>Values of type parameters are not boxed<a class="headerlink" href="#values-of-type-parameters-are-not-boxed" title="Permalink to this headline">¶</a></h3>
<p>In the current implementations of Go, interface values always hold
pointers.
Putting a non-pointer value in an interface variable causes the value
to be <em>boxed</em>.
That means that the actual value is stored somewhere else, on the heap
or stack, and the interface value holds a pointer to that location.</p>
<p>In this design, values of generic types are not boxed.
For example, let’s look back at our earlier example of
<code class="docutils literal notranslate"><span class="pre">from.Strings</span></code>.
When it is instantiated with type <code class="docutils literal notranslate"><span class="pre">Settable</span></code>, it returns a value of
type <code class="docutils literal notranslate"><span class="pre">[]Settable</span></code>.
For example, we can write</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Settable is an integer type that can be set from a string.</span>
<span class="kd">type</span> <span class="nx">Settable</span> <span class="kt">int</span>

<span class="c1">// Set sets the value of *p from a string.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Settable</span><span class="p">)</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// same as above</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">F</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// The type of nums is []Settable.</span>
	<span class="nx">nums</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">from</span><span class="p">.</span><span class="nx">Strings</span><span class="p">(</span><span class="nx">Settable</span><span class="p">)([]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
	<span class="c1">// Settable can be converted directly to int.</span>
	<span class="c1">// This will set first to 1.</span>
	<span class="nx">first</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When we call <code class="docutils literal notranslate"><span class="pre">from.Strings</span></code> with the type <code class="docutils literal notranslate"><span class="pre">Settable</span></code> we get back a
<code class="docutils literal notranslate"><span class="pre">[]Settable</span></code> (and an error).
The elements of that slice will be <code class="docutils literal notranslate"><span class="pre">Settable</span></code> values, which is to say,
they will be integers.
They will not be boxed, even though they were created and set by a
generic function.</p>
<p>Similarly, when a generic type is instantiated it will have the
expected types as components.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Pair</span><span class="p">(</span><span class="kd">type</span> <span class="nx">F1</span><span class="p">,</span> <span class="nx">F2</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">first</span>  <span class="nx">F1</span>
	<span class="nx">second</span> <span class="nx">F2</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When this is instantiated, the fields will not be boxed, and no
unexpected memory allocations will occur.
The type <code class="docutils literal notranslate"><span class="pre">Pair(int,</span> <span class="pre">string)</span></code> is convertible to <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">{</span> <span class="pre">first</span> <span class="pre">int;</span> <span class="pre">second</span> <span class="pre">string</span> <span class="pre">}</span></code>.</p>
</div>
<div class="section" id="more-on-type-lists">
<h3>More on type lists<a class="headerlink" href="#more-on-type-lists" title="Permalink to this headline">¶</a></h3>
<p>Let’s return now to type lists to cover some less important details
that are still worth noting.
These are not additional rules or concepts, but are consequences of
how type lists work.</p>
<div class="section" id="both-type-lists-and-methods-in-constraints">
<h4>Both type lists and methods in constraints<a class="headerlink" href="#both-type-lists-and-methods-in-constraints" title="Permalink to this headline">¶</a></h4>
<p>A constraint may use both type lists and methods.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// StringableSignedInteger is a type constraint that matches any</span>
<span class="c1">// type that is both 1) defined as a signed integer type;</span>
<span class="c1">// 2) has a String method.</span>
<span class="kd">type</span> <span class="nx">StringableSignedInteger</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="kd">type</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int8</span><span class="p">,</span> <span class="kt">int16</span><span class="p">,</span> <span class="kt">int32</span><span class="p">,</span> <span class="kt">int64</span>
	<span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This constraint permits any type whose underlying type is one of the
listed types, provided it also has a <code class="docutils literal notranslate"><span class="pre">String()</span> <span class="pre">string</span></code> method.
It’s worth noting that although the <code class="docutils literal notranslate"><span class="pre">StringableSignedInteger</span></code>
constraint explicitly lists <code class="docutils literal notranslate"><span class="pre">int</span></code>, the type <code class="docutils literal notranslate"><span class="pre">int</span></code> will not itself be
permitted as a type argument, since <code class="docutils literal notranslate"><span class="pre">int</span></code> does not have a <code class="docutils literal notranslate"><span class="pre">String</span></code>
method.
An example of a type argument that would be permitted is <code class="docutils literal notranslate"><span class="pre">MyInt</span></code>,
defined as:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// MyInt is a stringable int.</span>
<span class="kd">type</span> <span class="nx">MyInt</span> <span class="kt">int</span>

<span class="c1">// The String method returns a string representation of mi.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">mi</span> <span class="nx">MyInt</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;MyInt(%d)&quot;</span><span class="p">,</span> <span class="nx">mi</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="composite-types-in-constraints">
<h4>Composite types in constraints<a class="headerlink" href="#composite-types-in-constraints" title="Permalink to this headline">¶</a></h4>
<p>A type in a constraint may be a type literal.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">byteseq</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="kd">type</span> <span class="kt">string</span><span class="p">,</span> <span class="p">[]</span><span class="kt">byte</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The usual rules apply: the type argument for this constraint may be
<code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">[]byte</span></code> or a type defined as one of those types; a
generic function with this constraint may use any operation permitted
by both <code class="docutils literal notranslate"><span class="pre">string</span></code> and <code class="docutils literal notranslate"><span class="pre">[]byte</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">byteseq</span></code> constraint permits writing generic functions that work
for either <code class="docutils literal notranslate"><span class="pre">string</span></code> or <code class="docutils literal notranslate"><span class="pre">[]byte</span></code> types.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Join concatenates the elements of its first argument to create a</span>
<span class="c1">// single value. sep is placed between elements in the result.</span>
<span class="c1">// Join works for string and []byte types.</span>
<span class="kd">func</span> <span class="nx">Join</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">byteseq</span><span class="p">)(</span><span class="nx">a</span> <span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">sep</span> <span class="nx">T</span><span class="p">)</span> <span class="p">(</span><span class="nx">ret</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Use the result parameter as a zero value;</span>
		<span class="c1">// see discussion of zero value in the Issues section.</span>
		<span class="k">return</span> <span class="nx">ret</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="c1">// We know that a[0] is either a string or a []byte.</span>
		<span class="c1">// We can append either a string or a []byte to a []byte,</span>
		<span class="c1">// producing a []byte. We can convert that []byte to</span>
		<span class="c1">// either a []byte (a no-op conversion) or a string.</span>
		<span class="k">return</span> <span class="nx">T</span><span class="p">(</span><span class="nb">append</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="kc">nil</span><span class="p">),</span> <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">...</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="c1">// We can call len on sep because we can call len</span>
	<span class="c1">// on both string and []byte.</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">sep</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span> <span class="p">{</span>
		<span class="c1">// Another case where we call len on string or []byte.</span>
		<span class="nx">n</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">b</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
	<span class="c1">// We can call copy to a []byte with an argument of</span>
	<span class="c1">// either string or []byte.</span>
	<span class="nx">bp</span> <span class="o">:=</span> <span class="nb">copy</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">s</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">{</span>
		<span class="nx">bp</span> <span class="o">+=</span> <span class="nb">copy</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="nx">bp</span><span class="p">:],</span> <span class="nx">sep</span><span class="p">)</span>
		<span class="nx">bp</span> <span class="o">+=</span> <span class="nb">copy</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="nx">bp</span><span class="p">:],</span> <span class="nx">s</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// As above, we can convert b to either []byte or string.</span>
	<span class="k">return</span> <span class="nx">T</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="type-parameters-in-type-lists">
<h4>Type parameters in type lists<a class="headerlink" href="#type-parameters-in-type-lists" title="Permalink to this headline">¶</a></h4>
<p>A type literal in a constraint can refer to type parameters of the
constraint.
In this example, the generic function <code class="docutils literal notranslate"><span class="pre">Map</span></code> takes two type parameters.
The first type parameter is required to have an underlying type that
is a slice of the second type parameter.
There are no constraints on the second slice parameter.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// SliceConstraint is a type constraint that matches a slice of</span>
<span class="c1">// the type parameter.</span>
<span class="kd">type</span> <span class="nx">SliceConstraint</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="kd">type</span> <span class="p">[]</span><span class="nx">T</span>
<span class="p">}</span>

<span class="c1">// Map takes a slice of some element type and a transformation function,</span>
<span class="c1">// and returns a slice of the function applied to each element.</span>
<span class="c1">// Map returns a slice that is the same type as its slice argument,</span>
<span class="c1">// even if that is a defined type.</span>
<span class="kd">func</span> <span class="nx">Map</span><span class="p">(</span><span class="kd">type</span> <span class="nx">S</span> <span class="nx">SliceConstraint</span><span class="p">(</span><span class="nx">E</span><span class="p">),</span> <span class="nx">E</span> <span class="kd">interface</span><span class="p">{})(</span><span class="nx">s</span> <span class="nx">S</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">E</span><span class="p">)</span> <span class="nx">E</span><span class="p">)</span> <span class="nx">S</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">S</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>

<span class="c1">// MySlice is a simple defined type.</span>
<span class="kd">type</span> <span class="nx">MySlice</span> <span class="p">[]</span><span class="kt">int</span>

<span class="c1">// DoubleMySlice takes a value of type MySlice and returns a new</span>
<span class="c1">// MySlice value with each element doubled in value.</span>
<span class="kd">func</span> <span class="nx">DoubleMySlice</span><span class="p">(</span><span class="nx">s</span> <span class="nx">MySlice</span><span class="p">)</span> <span class="nx">MySlice</span> <span class="p">{</span>
	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">Map</span><span class="p">(</span><span class="nx">MySlice</span><span class="p">,</span> <span class="kt">int</span><span class="p">)(</span><span class="nx">s</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">e</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">e</span> <span class="p">})</span>
	<span class="c1">// Here v has type MySlice, not type []int.</span>
	<span class="k">return</span> <span class="nx">v</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="type-conversions">
<h4>Type conversions<a class="headerlink" href="#type-conversions" title="Permalink to this headline">¶</a></h4>
<p>In a function with two type parameters <code class="docutils literal notranslate"><span class="pre">From</span></code> and <code class="docutils literal notranslate"><span class="pre">To</span></code>, a value of
type <code class="docutils literal notranslate"><span class="pre">From</span></code> may be converted to a value of type <code class="docutils literal notranslate"><span class="pre">To</span></code> if all the
types accepted by <code class="docutils literal notranslate"><span class="pre">From</span></code>’s constraint can be converted to all the
types accepted by <code class="docutils literal notranslate"><span class="pre">To</span></code>’s constraint.
If either type parameter does not accept types, then type conversions
are not permitted.</p>
<p>This is a consequence of the general rule that a generic function may
use any operation that is permitted by all types listed in the type
list.</p>
<p>For example:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">integer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="kd">type</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int8</span><span class="p">,</span> <span class="kt">int16</span><span class="p">,</span> <span class="kt">int32</span><span class="p">,</span> <span class="kt">int64</span><span class="p">,</span>
		<span class="kt">uint</span><span class="p">,</span> <span class="kt">uint8</span><span class="p">,</span> <span class="kt">uint16</span><span class="p">,</span> <span class="kt">uint32</span><span class="p">,</span> <span class="kt">uint64</span><span class="p">,</span> <span class="kt">uintptr</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Convert</span><span class="p">(</span><span class="kd">type</span> <span class="nx">To</span><span class="p">,</span> <span class="nx">From</span> <span class="nx">integer</span><span class="p">)(</span><span class="nx">from</span> <span class="nx">From</span><span class="p">)</span> <span class="nx">To</span> <span class="p">{</span>
	<span class="nx">to</span> <span class="o">:=</span> <span class="nx">To</span><span class="p">(</span><span class="nx">from</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">From</span><span class="p">(</span><span class="nx">to</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">from</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&quot;conversion out of range&quot;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">to</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The type conversions in <code class="docutils literal notranslate"><span class="pre">Convert</span></code> are permitted because Go permits
every integer type to be converted to every other integer type.</p>
</div>
<div class="section" id="untyped-constants">
<h4>Untyped constants<a class="headerlink" href="#untyped-constants" title="Permalink to this headline">¶</a></h4>
<p>Some functions use untyped constants.
An untyped constant is permitted with a value of some type parameter
if it is permitted with every type accepted by the type parameter’s
constraint.</p>
<p>As with type conversions, this is a consequence of the general rule
that a generic function may use any operation that is permitted by all
types listed in the type list.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">integer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="kd">type</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int8</span><span class="p">,</span> <span class="kt">int16</span><span class="p">,</span> <span class="kt">int32</span><span class="p">,</span> <span class="kt">int64</span><span class="p">,</span>
		<span class="kt">uint</span><span class="p">,</span> <span class="kt">uint8</span><span class="p">,</span> <span class="kt">uint16</span><span class="p">,</span> <span class="kt">uint32</span><span class="p">,</span> <span class="kt">uint64</span><span class="p">,</span> <span class="kt">uintptr</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Add10</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">integer</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v</span> <span class="o">+</span> <span class="mi">10</span> <span class="c1">// OK: 10 can convert to any integer type</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// This function is INVALID.</span>
<span class="kd">func</span> <span class="nx">Add1024</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">integer</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v</span> <span class="o">+</span> <span class="mi">1024</span> <span class="c1">// INVALID: 1024 not permitted by int8/uint8</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="notes-on-composite-types-in-type-lists">
<h4>Notes on composite types in type lists<a class="headerlink" href="#notes-on-composite-types-in-type-lists" title="Permalink to this headline">¶</a></h4>
<p>It’s not clear that we fully understand the use of composite types in
type lists.
For example, consider</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">structField</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="kd">type</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">a</span> <span class="kt">int</span><span class="p">;</span> <span class="nx">x</span> <span class="kt">int</span> <span class="p">},</span>
		<span class="kd">struct</span> <span class="p">{</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">;</span> <span class="nx">x</span> <span class="kt">float64</span> <span class="p">},</span>
		<span class="kd">struct</span> <span class="p">{</span> <span class="nx">c</span> <span class="kt">int</span><span class="p">;</span> <span class="nx">x</span> <span class="kt">uint64</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">IncrementX</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">structField</span><span class="p">)(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">x</span>
	<span class="nx">v</span><span class="o">++</span>
	<span class="nx">p</span><span class="p">.</span><span class="nx">x</span> <span class="p">=</span> <span class="nx">v</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This constraint on the type parameter of <code class="docutils literal notranslate"><span class="pre">IncrementX</span></code> is such that
every valid type argument is a struct with a field <code class="docutils literal notranslate"><span class="pre">x</span></code> of some numeric
type.
Therefore, it is tempting to say that <code class="docutils literal notranslate"><span class="pre">IncrementX</span></code> is a valid
function.
This would mean that the type of <code class="docutils literal notranslate"><span class="pre">v</span></code> is a type based on a type
parameter, with an implicit constraint of <code class="docutils literal notranslate"><span class="pre">interface</span> <span class="pre">{</span> <span class="pre">type</span> <span class="pre">int,</span> <span class="pre">float64,</span> <span class="pre">uint64</span> <span class="pre">}</span></code>.
This could get fairly complex, and there may be details here that we
don’t understand.</p>
<p>The initial implementation may not support composite types in type
lists at all, although that would make the <code class="docutils literal notranslate"><span class="pre">Join</span></code> example shown
earlier invalid.</p>
</div>
<div class="section" id="type-lists-in-embedded-constraints">
<h4>Type lists in embedded constraints<a class="headerlink" href="#type-lists-in-embedded-constraints" title="Permalink to this headline">¶</a></h4>
<p>When a constraint embeds another constraint, the type list of the
final constraint is the intersection of all the type lists involved.
If there are multiple embedded types, intersection preserves the
property that any  type argument must satisfy the requirements of all
embedded types.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Addable is types that support the + operator.</span>
<span class="kd">type</span> <span class="nx">Addable</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="kd">type</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int8</span><span class="p">,</span> <span class="kt">int16</span><span class="p">,</span> <span class="kt">int32</span><span class="p">,</span> <span class="kt">int64</span><span class="p">,</span>
		<span class="kt">uint</span><span class="p">,</span> <span class="kt">uint8</span><span class="p">,</span> <span class="kt">uint16</span><span class="p">,</span> <span class="kt">uint32</span><span class="p">,</span> <span class="kt">uint64</span><span class="p">,</span> <span class="kt">uintptr</span><span class="p">,</span>
		<span class="kt">float32</span><span class="p">,</span> <span class="kt">float64</span><span class="p">,</span> <span class="kt">complex64</span><span class="p">,</span> <span class="kt">complex128</span><span class="p">,</span>
		<span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// Byteseq is a byte sequence: either string or []byte.</span>
<span class="kd">type</span> <span class="nx">Byteseq</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="kd">type</span> <span class="kt">string</span><span class="p">,</span> <span class="p">[]</span><span class="kt">byte</span>
<span class="p">}</span>

<span class="c1">// AddableByteseq is a byte sequence that supports +.</span>
<span class="c1">// This is every type is that is both Addable and Byteseq.</span>
<span class="c1">// In other words, just the type string.</span>
<span class="kd">type</span> <span class="nx">AddableByteseq</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Addable</span>
	<span class="nx">Byteseq</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="general-notes-on-type-lists">
<h4>General notes on type lists<a class="headerlink" href="#general-notes-on-type-lists" title="Permalink to this headline">¶</a></h4>
<p>It may seem awkward to explicitly list types in a constraint, but it
is clear both as to which type arguments are permitted at the call
site, and which operations are permitted by the generic function.</p>
<p>If the language later changes to support operator methods (there are
no such plans at present), then constraints will handle them as they
do any other kind of method.</p>
<p>There will always be a limited number of predeclared types, and a
limited number of operators that those types support.
Future language changes will not fundamentally change those facts, so
this approach will continue to be useful.</p>
<p>This approach does not attempt to handle every possible operator.
It’s not clear that it works well for composite types.
The expectation is that those will be handled using composite types in
generic function and type declarations, rather than requiring
composite types as a type argument.
For example, we expect functions that want to index into a slice to be
parameterized on the slice element type <code class="docutils literal notranslate"><span class="pre">T</span></code>, and to use parameters or
variables of type <code class="docutils literal notranslate"><span class="pre">[]T</span></code>.</p>
<p>As shown in the <code class="docutils literal notranslate"><span class="pre">DoubleMySlice</span></code> example above, this approach makes it
awkward to declare generic functions that accept and return a
composite type and want to return the same result type as their
argument type.
Defined composite types are not common, but they do arise.
This awkwardness is a weakness of this approach.</p>
</div>
</div>
<div class="section" id="reflection">
<h3>Reflection<a class="headerlink" href="#reflection" title="Permalink to this headline">¶</a></h3>
<p>We do not propose to change the reflect package in any way.
When a type or function is instantiated, all of the type parameters
will become ordinary non-generic types.
The <code class="docutils literal notranslate"><span class="pre">String</span></code> method of a <code class="docutils literal notranslate"><span class="pre">reflect.Type</span></code> value of an instantiated type
will return the name with the type arguments in parentheses.
For example, <code class="docutils literal notranslate"><span class="pre">List(int)</span></code>.</p>
<p>It’s impossible for non-generic code to refer to generic code without
instantiating it, so there is no reflection information for
uninstantiated generic types or functions.</p>
</div>
<div class="section" id="implementation">
<h3>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h3>
<p>Russ Cox <a class="reference external" href="https://research.swtch.com/generic">famously observed</a> that
generics require choosing among slow programmers, slow compilers, or
slow execution times.</p>
<p>We believe that this design permits different implementation choices.
Code may be compiled separately for each set of type arguments, or it
may be compiled as though each type argument is handled similarly to
an interface type with method calls, or there may be some combination
of the two.</p>
<p>In other words, this design permits people to stop choosing slow
programmers, and permits the implementation to decide between slow
compilers (compile each set of type arguments separately) or slow
execution times (use method calls for each operation on a value of a
type argument).</p>
</div>
<div class="section" id="summary">
<h3>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h3>
<p>While this document is long and detailed, the actual design reduces to
a few major points.</p>
<ul class="simple">
<li><p>Functions and types can have type parameters, which are defined
using optional constraints, which are interface types.</p></li>
<li><p>Constraints describe the methods required and the types permitted
for a type argument.</p></li>
<li><p>Constraints describe the methods and operations permitted for a type
parameter.</p></li>
<li><p>Type inference will often permit omitting type arguments when
calling functions with type parameters.</p></li>
</ul>
<p>This design is completely backward compatible, except for a suggested
change in the meaning of <code class="docutils literal notranslate"><span class="pre">func</span> <span class="pre">F(x(T))</span></code>.</p>
<p>We believe that this design addresses people’s needs for generic
programming in Go, without making the language any more complex than
necessary.</p>
<p>We can’t truly know the impact on the language without years of
experience with this design.
That said, here are some speculations.</p>
<div class="section" id="complexity">
<h4>Complexity<a class="headerlink" href="#complexity" title="Permalink to this headline">¶</a></h4>
<p>One of the great aspects of Go is its simplicity.
Clearly this design makes the language more complex.</p>
<p>We believe that the increased complexity is small for people reading
well written generic code, rather than writing it.
Naturally people must learn the new syntax for declaring type
parameters.
This new syntax, and the new support for type lists in interfaces, are
the only new syntactic constructs in this design.
The code within a generic function reads like ordinary Go code, as can
be seen in the examples below.
It is an easy shift to go from <code class="docutils literal notranslate"><span class="pre">[]int</span></code> to <code class="docutils literal notranslate"><span class="pre">[]T</span></code>.
Type parameter constraints serve effectively as documentation,
describing the type.</p>
<p>We expect that most packages will not define generic types or
functions, but many packages are likely to use generic types or
functions defined elsewhere.
In the common case, generic functions work exactly like non-generic
functions: you simply call them.
Type inference means that you do not have to write out the type
arguments explicitly.
The type inference rules are designed to be unsurprising: either the
type arguments are deduced correctly, or the call fails and requires
explicit type parameters.
Type inference uses type identity, with no attempt to resolve two
types that are similar but not identical, which removes significant
complexity.</p>
<p>Packages using generic types will have to pass explicit type
arguments.
The syntax for this is familiar.
The only change is passing arguments to types rather than only to
functions.</p>
<p>In general, we have tried to avoid surprises in the design.
Only time will tell whether we succeeded.</p>
</div>
<div class="section" id="pervasiveness">
<h4>Pervasiveness<a class="headerlink" href="#pervasiveness" title="Permalink to this headline">¶</a></h4>
<p>We expect that a few new packages will be added to the standard
library.
A new <code class="docutils literal notranslate"><span class="pre">slices</span></code> packages will be similar to the existing bytes and
strings packages, operating on slices of any element type.
New <code class="docutils literal notranslate"><span class="pre">maps</span></code> and <code class="docutils literal notranslate"><span class="pre">chans</span></code> packages will provide simple algorithms that
are currently duplicated for each element type.
A <code class="docutils literal notranslate"><span class="pre">set</span></code> package may be added.</p>
<p>A new <code class="docutils literal notranslate"><span class="pre">constraints</span></code> package will provide standard constraints, such as
constraints that permit all integer types or all numeric types.</p>
<p>Packages like <code class="docutils literal notranslate"><span class="pre">container/list</span></code> and <code class="docutils literal notranslate"><span class="pre">container/ring</span></code>, and types like
<code class="docutils literal notranslate"><span class="pre">sync.Map</span></code> and <code class="docutils literal notranslate"><span class="pre">sync/atomic.Value</span></code>, will be updated to be compile-time
type-safe, either using new names or new versions of the packages.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">math</span></code> package will be extended to provide a set of simple
standard algorithms for all numeric types, such as the ever popular
<code class="docutils literal notranslate"><span class="pre">Min</span></code> and <code class="docutils literal notranslate"><span class="pre">Max</span></code> functions.</p>
<p>We may add generic variants to the <code class="docutils literal notranslate"><span class="pre">sort</span></code> package.</p>
<p>It is likely that new special purpose compile-time type-safe container
types will be developed.</p>
<p>We do not expect approaches like the C++ STL iterator types to become
widely used.
In Go that sort of idea is more naturally expressed using an interface
type.
In C++ terms, using an interface type for an iterator can be seen as
carrying an abstraction penalty, in that run-time efficiency will be
less than C++ approaches that in effect inline all code; we believe
that Go programmers will continue to find that sort of penalty to be
acceptable.</p>
<p>As we get more container types, we may develop a standard <code class="docutils literal notranslate"><span class="pre">Iterator</span></code>
interface.
That may in turn lead to pressure to modify the language to add some
mechanism for using an <code class="docutils literal notranslate"><span class="pre">Iterator</span></code> with the <code class="docutils literal notranslate"><span class="pre">range</span></code> clause.
That is very speculative, though.</p>
</div>
<div class="section" id="efficiency">
<h4>Efficiency<a class="headerlink" href="#efficiency" title="Permalink to this headline">¶</a></h4>
<p>It is not clear what sort of efficiency people expect from generic
code.</p>
<p>Generic functions, rather than generic types, can probably be compiled
using an interface-based approach.
That will optimize compile time, in that the function is only compiled
once, but there will be some run time cost.</p>
<p>Generic types may most naturally be compiled multiple times for each
set of type arguments.
This will clearly carry a compile time cost, but there shouldn’t be
any run time cost.
Compilers can also choose to implement generic types similarly to
interface types, using special purpose methods to access each element
that depends on a type parameter.</p>
<p>Only experience will show what people expect in this area.</p>
</div>
<div class="section" id="omissions">
<h4>Omissions<a class="headerlink" href="#omissions" title="Permalink to this headline">¶</a></h4>
<p>We believe that this design covers the basic requirements for
generic programming.
However, there are a number of programming constructs that are not
supported.</p>
<ul class="simple">
<li><p>No specialization.
There is no way to write multiple versions of a generic function
that are designed to work with specific type arguments.</p></li>
<li><p>No metaprogramming.
There is no way to write code that is executed at compile time to
generate code to be executed at run time.</p></li>
<li><p>No higher level abstraction.
There is no way to speak about a function with type arguments other
than to call it or instantiate it.
There is no way to speak about a generic type other than to
instantiate it.</p></li>
<li><p>No general type description.
In order to use operators in a generic function, constraints list
specific types, rather than describing the characteristics that a
type must have.
This is easy to understand but may be limiting at times.</p></li>
<li><p>No covariance or contravariance of function parameters.</p></li>
<li><p>No operator methods.
You can write a generic container that is compile-time type-safe,
but you can only access it with ordinary methods, not with syntax
like <code class="docutils literal notranslate"><span class="pre">c[k]</span></code>.</p></li>
<li><p>No currying.
There is no way to specify only some of the type arguments, other
than by using a helper function or a wrapper type.</p></li>
<li><p>No variadic type parameters.
There is no support for variadic type parameters, which would permit
writing a single generic function that takes different numbers of
both type parameters and regular parameters.</p></li>
<li><p>No adaptors.
There is no way for a constraint to define adaptors that could be
used to support type arguments that do not already implement the
constraint, such as, for example, defining an <code class="docutils literal notranslate"><span class="pre">==</span></code> operator in terms
of an <code class="docutils literal notranslate"><span class="pre">Equal</span></code> method, or vice-versa.</p></li>
<li><p>No parameterization on non-type values such as constants.
This arises most obviously for arrays, where it might sometimes be
convenient to write <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">Matrix(type</span> <span class="pre">n</span> <span class="pre">int)</span> <span class="pre">[n][n]float64</span></code>.
It might also sometimes be useful to specify significant values for
a container type, such as a default value for elements.</p></li>
</ul>
</div>
<div class="section" id="issues">
<h4>Issues<a class="headerlink" href="#issues" title="Permalink to this headline">¶</a></h4>
<p>There are some issues with this design that deserve a more detailed
discussion.
We think these issues are relatively minor compared to the design as a
whole, but they still deserve a complete hearing and discussion.</p>
<div class="section" id="the-zero-value">
<h5>The zero value<a class="headerlink" href="#the-zero-value" title="Permalink to this headline">¶</a></h5>
<p>This design has no simple expression for the zero value of a type
parameter.
For example, consider this implementation of optional values that uses
pointers:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Optional</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">p</span> <span class="o">*</span><span class="nx">T</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="nx">Optional</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Val</span><span class="p">()</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">o</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">*</span><span class="nx">o</span><span class="p">.</span><span class="nx">p</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">zero</span> <span class="nx">T</span>
	<span class="k">return</span> <span class="nx">zero</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the case where <code class="docutils literal notranslate"><span class="pre">o.p</span> <span class="pre">==</span> <span class="pre">nil</span></code>, we want to return the zero value of
<code class="docutils literal notranslate"><span class="pre">T</span></code>, but we have no way to write that.
It would be nice to be able to write <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">nil</span></code>, but that wouldn’t
work if <code class="docutils literal notranslate"><span class="pre">T</span></code> is, say, <code class="docutils literal notranslate"><span class="pre">int</span></code>; in that case we would have to write
<code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">0</span></code>.
And, of course, there is no way to write a constraint to support
either <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">nil</span></code> or <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">0</span></code>.</p>
<p>Some approaches to this are:</p>
<ul class="simple">
<li><p>Use <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">zero</span> <span class="pre">T</span></code>, as above, which works with the existing design
but requires an extra statement.</p></li>
<li><p>Use <code class="docutils literal notranslate"><span class="pre">*new(T)</span></code>, which is cryptic but works with the existing
design.</p></li>
<li><p>For results only, name the result parameter <code class="docutils literal notranslate"><span class="pre">_</span></code>, and use a naked
<code class="docutils literal notranslate"><span class="pre">return</span></code> statement to return the zero value.</p></li>
<li><p>Extend the design to permit using <code class="docutils literal notranslate"><span class="pre">nil</span></code> as the zero value of any
generic type (but see <a class="reference external" href="https://golang.org/issue/22729">issue 22729</a>).</p></li>
<li><p>Extend the design to permit using <code class="docutils literal notranslate"><span class="pre">T{}</span></code>, where <code class="docutils literal notranslate"><span class="pre">T</span></code> is a type
parameter, to indicate the zero value of the type.</p></li>
<li><p>Change the language to permit using <code class="docutils literal notranslate"><span class="pre">_</span></code> on the right hand of an
assignment (including <code class="docutils literal notranslate"><span class="pre">return</span></code> or a function call) as proposed in
<a class="reference external" href="https://golang.org/issue/19642">issue 19642</a>.</p></li>
<li><p>Change the language to permit <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">...</span></code> to return zero values of
the result types, as proposed in
<a class="reference external" href="https://golang.org/issue/21182">issue 21182</a>.</p></li>
</ul>
<p>We feel that more experience with this design is needed before
deciding what, if anything, to do here.</p>
</div>
<div class="section" id="lots-of-irritating-silly-parentheses">
<h5>Lots of Irritating Silly Parentheses<a class="headerlink" href="#lots-of-irritating-silly-parentheses" title="Permalink to this headline">¶</a></h5>
<p>Calling a function with type parameters requires an additional list of
type arguments if the type arguments can not be inferred.
If the function returns a function, and we call that, we get still
more parentheses.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span>	<span class="nx">F</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float64</span><span class="p">)(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)(</span><span class="nx">s</span><span class="p">)</span>
</pre></div>
</div>
<p>We experimented with other syntaxes, such as using a colon to separate
the type arguments from the regular arguments.
The current design seems to us to be the nicest, but perhaps something
better is possible.</p>
</div>
<div class="section" id="defined-composite-types">
<h5>Defined composite types<a class="headerlink" href="#defined-composite-types" title="Permalink to this headline">¶</a></h5>
<p>As <a class="reference external" href="#Type-parameters-in-type-lists">discussed above</a>, an extra type
parameter is required for a function to take, as an argument, a
defined type whose underlying type is a composite type, and to return
the same defined type as a result.</p>
<p>For example, this function will map a function across a slice.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Map applies f to each element of s, returning a new slice</span>
<span class="c1">// holding the results.</span>
<span class="kd">func</span> <span class="nx">Map</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="nx">T</span><span class="p">)</span> <span class="p">[]</span><span class="nx">T</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</pre></div>
</div>
<p>However, when called on a defined type, it will return a slice of the
element type of that type, rather than the defined type itself.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// MySlice is a defined type.</span>
<span class="kd">type</span> <span class="nx">MySlice</span> <span class="p">[]</span><span class="kt">int</span>

<span class="c1">// DoubleMySlice returns a new MySlice whose elements are twice</span>
<span class="c1">// that of the corresponding elements of s.</span>
<span class="kd">func</span> <span class="nx">DoubleMySlice</span><span class="p">(</span><span class="nx">s</span> <span class="nx">MySlice</span><span class="p">)</span> <span class="nx">MySlice</span> <span class="p">{</span>
	<span class="nx">s2</span> <span class="o">:=</span> <span class="nx">Map</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">e</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">e</span> <span class="p">})</span>
	<span class="c1">// Here s2 is type []int, not type MySlice.</span>
	<span class="k">return</span> <span class="nx">MySlice</span><span class="p">(</span><span class="nx">s2</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As <a class="reference external" href="#Type-parameters-in-type-lists">discussed above</a>, this can be
avoided by using an extra type parameter for <code class="docutils literal notranslate"><span class="pre">Map</span></code>, and using
constraints that describe the required relationship between the slice
and element types.
This works but is awkward.</p>
</div>
<div class="section" id="identifying-the-matched-predeclared-type">
<h5>Identifying the matched predeclared type<a class="headerlink" href="#identifying-the-matched-predeclared-type" title="Permalink to this headline">¶</a></h5>
<p>The design doesn’t provide any way to test the underlying type matched
by a type argument.
Code can test the actual type argument through the somewhat awkward
approach of converting to an empty interface type and using a type
assertion or a type switch.
But that lets code test the actual type argument, which is not the
same as the underlying type.</p>
<p>Here is an example that shows the difference.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Float</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="kd">type</span> <span class="kt">float32</span><span class="p">,</span> <span class="kt">float64</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">NewtonSqrt</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">Float</span><span class="p">)(</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">iterations</span> <span class="kt">int</span>
	<span class="k">switch</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{})(</span><span class="nx">v</span><span class="p">).(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="kt">float32</span><span class="p">:</span>
		<span class="nx">iterations</span> <span class="p">=</span> <span class="mi">4</span>
	<span class="k">case</span> <span class="kt">float64</span><span class="p">:</span>
		<span class="nx">iterations</span> <span class="p">=</span> <span class="mi">5</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;unexpected type %T&quot;</span><span class="p">,</span> <span class="nx">v</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="c1">// Code omitted.</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MyFloat</span> <span class="kt">float32</span>

<span class="kd">var</span> <span class="nx">G</span> <span class="p">=</span> <span class="nx">NewtonSqrt</span><span class="p">(</span><span class="nx">MyFloat</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span>
</pre></div>
</div>
<p>This code will panic when initializing <code class="docutils literal notranslate"><span class="pre">G</span></code>, because the type of <code class="docutils literal notranslate"><span class="pre">v</span></code> in
the <code class="docutils literal notranslate"><span class="pre">NewtonSqrt</span></code> function will be <code class="docutils literal notranslate"><span class="pre">MyFloat</span></code>, not <code class="docutils literal notranslate"><span class="pre">float32</span></code> or
<code class="docutils literal notranslate"><span class="pre">float64</span></code>.
What this function actually wants to test is not the type of <code class="docutils literal notranslate"><span class="pre">v</span></code>, but
the type that <code class="docutils literal notranslate"><span class="pre">v</span></code> matched in the constraint.</p>
<p>One way to handle this would be to permit type switches on the type
<code class="docutils literal notranslate"><span class="pre">T</span></code>, with the proviso that the type <code class="docutils literal notranslate"><span class="pre">T</span></code> would always match a type
defined in the constraint.
This kind of type switch would only be permitted if the constraint
lists explicit types, and only types listed in the constraint would be
permitted as cases.</p>
</div>
<div class="section" id="no-way-to-express-convertibility">
<h5>No way to express convertibility<a class="headerlink" href="#no-way-to-express-convertibility" title="Permalink to this headline">¶</a></h5>
<p>The design has no way to express convertibility between two different
type parameters.
For example, there is no way to write this function:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Copy copies values from src to dst, converting them as they go.</span>
<span class="c1">// It returns the number of items copied, which is the minimum of</span>
<span class="c1">// the lengths of dst and src.</span>
<span class="c1">// This implementation is INVALID.</span>
<span class="kd">func</span> <span class="nx">Copy</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">)(</span><span class="nx">dst</span> <span class="p">[]</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">src</span> <span class="p">[]</span><span class="nx">T2</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">src</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">dst</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">i</span>
		<span class="p">}</span>
		<span class="nx">dst</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">T1</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// INVALID</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The conversion from type <code class="docutils literal notranslate"><span class="pre">T2</span></code> to type <code class="docutils literal notranslate"><span class="pre">T1</span></code> is invalid, as there is no
constraint on either type that permits the conversion.
Worse, there is no way to write such a constraint in general.
In the particular case that both <code class="docutils literal notranslate"><span class="pre">T1</span></code> and <code class="docutils literal notranslate"><span class="pre">T2</span></code> can require some type
list, then this function can be written as described earlier when
discussing <a class="reference external" href="#Type-conversions">type conversions using type lists</a>.
But, for example, there is no way to write a constraint for the case
in which <code class="docutils literal notranslate"><span class="pre">T1</span></code> is an interface type and <code class="docutils literal notranslate"><span class="pre">T2</span></code> is a type that implements
that interface.</p>
<p>It’s worth noting that if <code class="docutils literal notranslate"><span class="pre">T1</span></code> is an interface type then this can be
written using a conversion to the empty interface type and a type
assertion, but this is, of course, not compile-time type-safe.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Copy copies values from src to dst, converting them as they go.</span>
<span class="c1">// It returns the number of items copied, which is the minimum of</span>
<span class="c1">// the lengths of dst and src.</span>
<span class="kd">func</span> <span class="nx">Copy</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">)(</span><span class="nx">dst</span> <span class="p">[]</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">src</span> <span class="p">[]</span><span class="nx">T2</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">src</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">dst</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">i</span>
		<span class="p">}</span>
		<span class="nx">dst</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{})(</span><span class="nx">x</span><span class="p">).(</span><span class="nx">T1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="discarded-ideas">
<h4>Discarded ideas<a class="headerlink" href="#discarded-ideas" title="Permalink to this headline">¶</a></h4>
<p>This design is not perfect, and it will be further refined as we gain
experience with it.
That said, there are many ideas that we’ve already considered in
detail.
This section lists some of those ideas in the hopes that it will help
to reduce repetitive discussion.
The ideas are presented in the form of a FAQ.</p>
<div class="section" id="what-happened-to-contracts">
<h5>What happened to contracts?<a class="headerlink" href="#what-happened-to-contracts" title="Permalink to this headline">¶</a></h5>
<p>An earlier draft design of generics implemented constraints using a
new language construct called contracts.
Type lists appeared only in contracts, rather than on interface
types.
However, many people had a hard time understanding the difference
between contracts and interface types.
It also turned out that contracts could be represented as a set of
corresponding interfaces; thus there was no loss in expressive power
without contracts.
We decided to simplify the approach to use only interface types.</p>
</div>
<div class="section" id="why-not-use-methods-instead-of-type-lists">
<h5>Why not use methods instead of type lists?<a class="headerlink" href="#why-not-use-methods-instead-of-type-lists" title="Permalink to this headline">¶</a></h5>
<p><em>Type lists are weird.</em>
<em>Why not write methods for all operators?</em></p>
<p>It is possible to permit operator tokens as method names, leading to
methods such as <code class="docutils literal notranslate"><span class="pre">+(T)</span> <span class="pre">T</span></code>.
Unfortunately, that is not sufficient.
We would need some mechanism to describe a type that matches any
integer type, for operations such as shifts <code class="docutils literal notranslate"><span class="pre">&lt;&lt;(integer)</span> <span class="pre">T</span></code> and
indexing <code class="docutils literal notranslate"><span class="pre">[](integer)</span> <span class="pre">T</span></code> which are not restricted to a single int
type.
We would need an untyped boolean type for operations such as <code class="docutils literal notranslate"><span class="pre">==(T)</span> <span class="pre">untyped</span> <span class="pre">bool</span></code>.
We would need to introduce new notation for operations such as
conversions, or to express that one may range over a type, which would
likely require some new syntax.
We would need some mechanism to describe valid values of untyped
constants.
We would have to consider whether support for <code class="docutils literal notranslate"><span class="pre">&lt;(T)</span> <span class="pre">bool</span></code> means that a
generic function can also use <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, and similarly whether support for
<code class="docutils literal notranslate"><span class="pre">+(T)</span> <span class="pre">T</span></code> means that a function can also use <code class="docutils literal notranslate"><span class="pre">++</span></code>.
It might be possible to make this approach work but it’s not
straightforward.
The approach used in this design seems simpler and relies on only one
new syntactic construct (type lists) and one new name (<code class="docutils literal notranslate"><span class="pre">comparable</span></code>).</p>
</div>
<div class="section" id="why-not-put-type-parameters-on-packages">
<h5>Why not put type parameters on packages?<a class="headerlink" href="#why-not-put-type-parameters-on-packages" title="Permalink to this headline">¶</a></h5>
<p>We investigated this extensively.
It becomes problematic when you want to write a <code class="docutils literal notranslate"><span class="pre">list</span></code> package, and
you want that package to include a <code class="docutils literal notranslate"><span class="pre">Transform</span></code> function that converts
a <code class="docutils literal notranslate"><span class="pre">List</span></code> of one element type to a <code class="docutils literal notranslate"><span class="pre">List</span></code> of another element type.
It’s very awkward for a function in one instantiation of a package to
return a type that requires a different instantiation of the same
package.</p>
<p>It also confuses package boundaries with type definitions.
There is no particular reason to think that the uses of generic types
will break down neatly into packages.
Sometimes they will, sometimes they won’t.</p>
</div>
<div class="section" id="why-not-use-the-syntax-f-t-like-c-and-java">
<h5>Why not use the syntax <code class="docutils literal notranslate"><span class="pre">F&lt;T&gt;</span></code> like C++ and Java?<a class="headerlink" href="#why-not-use-the-syntax-f-t-like-c-and-java" title="Permalink to this headline">¶</a></h5>
<p>When parsing code within a function, such as <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">:=</span> <span class="pre">F&lt;T&gt;</span></code>, at the point
of seeing the <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> it’s ambiguous whether we are seeing a type
instantiation or an expression using the <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> operator.
Resolving that requires effectively unbounded lookahead.
In general we strive to keep the Go parser efficient.</p>
</div>
<div class="section" id="why-not-use-the-syntax-f-t">
<h5>Why not use the syntax <code class="docutils literal notranslate"><span class="pre">F[T]</span></code>?<a class="headerlink" href="#why-not-use-the-syntax-f-t" title="Permalink to this headline">¶</a></h5>
<p>When parsing a type declaration <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">A</span> <span class="pre">[T]</span> <span class="pre">int</span></code> it’s ambiguous
whether this is a generic type defined (uselessly) as <code class="docutils literal notranslate"><span class="pre">int</span></code> or whether
it is an array type with <code class="docutils literal notranslate"><span class="pre">T</span></code> elements.
However, this could be addressed by requiring <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">A</span> <span class="pre">[type</span> <span class="pre">T]</span> <span class="pre">int</span></code>
for a generic type.</p>
<p>Parsing declarations like <code class="docutils literal notranslate"><span class="pre">func</span> <span class="pre">f(A[T]int)</span></code> (a single parameter of
type <code class="docutils literal notranslate"><span class="pre">[T]int</span></code>) and <code class="docutils literal notranslate"><span class="pre">func</span> <span class="pre">f(A[T],</span> <span class="pre">int)</span></code> (two parameters, one of type
<code class="docutils literal notranslate"><span class="pre">A[T]</span></code> and one of type <code class="docutils literal notranslate"><span class="pre">int</span></code>) show that some additional parsing
lookahead is required.
This is solvable but adds parsing complexity.</p>
<p>The language generally permits a trailing comma in a comma-separated
list, so <code class="docutils literal notranslate"><span class="pre">A[T,]</span></code> should be permitted if <code class="docutils literal notranslate"><span class="pre">A</span></code> is a generic type, but
normally would not be permitted for an index expression.
However, the parser can’t know whether <code class="docutils literal notranslate"><span class="pre">A</span></code> is a generic type or a
value of slice, array, or map type, so this parse error can not be
reported until after type checking is complete.
Again, solvable but complicated.</p>
<p>More generally, we felt that the square brackets were too intrusive on
the page and that parentheses were more Go like.
We will reevaluate this decision as we gain more experience.</p>
</div>
<div class="section" id="why-not-use-ft">
<h5>Why not use <code class="docutils literal notranslate"><span class="pre">F«T»</span></code>?<a class="headerlink" href="#why-not-use-ft" title="Permalink to this headline">¶</a></h5>
<p>We considered it but we couldn’t bring ourselves to require
non-ASCII.</p>
</div>
<div class="section" id="why-not-define-constraints-in-a-builtin-package">
<h5>Why not define constraints in a builtin package?<a class="headerlink" href="#why-not-define-constraints-in-a-builtin-package" title="Permalink to this headline">¶</a></h5>
<p><em>Instead of writing out type lists, use names like</em>
<em><code class="docutils literal notranslate"><span class="pre">constraints.Arithmetic</span></code> and <code class="docutils literal notranslate"><span class="pre">constraints.Comparable</span></code>.</em></p>
<p>Listing all the possible combinations of types gets rather lengthy.
It also introduces a new set of names that not only the writer of
generic code, but, more importantly, the reader, must remember.
One of the driving goals of this design is to introduce as few new
names as possible.
In this design we introduce only one new predeclared name.</p>
<p>We expect that if people find such names useful, we can introduce a
package <code class="docutils literal notranslate"><span class="pre">constraints</span></code> that defines the useful names in the form of
constraints that can be used by other types and functions and embedded
in other constraints.
That will define the most useful names in the standard library while
giving programmers the flexibility to use other combinations of types
where appropriate.</p>
</div>
<div class="section" id="why-not-permit-type-assertions-on-values-whose-type-is-a-type-parameter">
<h5>Why not permit type assertions on values whose type is a type parameter?<a class="headerlink" href="#why-not-permit-type-assertions-on-values-whose-type-is-a-type-parameter" title="Permalink to this headline">¶</a></h5>
<p>In an earlier version of this design, we permitted using type
assertions and type switches on variables whose type was a type
parameter, or whose type was based on a type parameter.
We removed this facility because it is always possible to convert a
value of any type to the empty interface type, and then use a type
assertion or type switch on that.
Also, it was sometimes confusing that in a constraint with a type
list, a type assertion or type switch would use the actual type
argument, not the underlying type of the type argument (the difference
is explained in the section on <a class="reference external" href="#Identifying-the-matched-predeclared-type">identifying the matched predeclared
type</a>).</p>
</div>
</div>
<div class="section" id="comparison-with-java">
<h4>Comparison with Java<a class="headerlink" href="#comparison-with-java" title="Permalink to this headline">¶</a></h4>
<p>Most complaints about Java generics center around type erasure.
This design does not have type erasure.
The reflection information for a generic type will include the full
compile-time type information.</p>
<p>In Java type wildcards (<code class="docutils literal notranslate"><span class="pre">List&lt;?</span> <span class="pre">extends</span> <span class="pre">Number&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">List&lt;?</span> <span class="pre">super</span> <span class="pre">Number&gt;</span></code>) implement covariance and contravariance.
These concepts are missing from Go, which makes generic types much
simpler.</p>
</div>
<div class="section" id="comparison-with-c">
<h4>Comparison with C++<a class="headerlink" href="#comparison-with-c" title="Permalink to this headline">¶</a></h4>
<p>C++ templates do not enforce any constraints on the type arguments
(unless the concept proposal is adopted).
This means that changing template code can accidentally break far-off
instantiations.
It also means that error messages are reported only at instantiation
time, and can be deeply nested and difficult to understand.
This design avoids these problems through explicit required
constraints.</p>
<p>C++ supports template metaprogramming, which can be thought of as
ordinary programming done at compile time using a syntax that is
completely different than that of non-template C++.
This design has no similar feature.
This saves considerable complexity while losing some power and run
time efficiency.</p>
<p>C++ uses two-phase name lookup, in which some names are looked up in
the context of the template definition, and some names are looked up
in the context of the template instantiation.
In this design all names are looked up at the point where they are
written.</p>
<p>In practice, all C++ compilers compile each template at the point
where it is instantiated.
This can slow down compilation time.
This design offers flexibility as to how to handle the compilation of
generic functions.</p>
</div>
<div class="section" id="comparison-with-rust">
<h4>Comparison with Rust<a class="headerlink" href="#comparison-with-rust" title="Permalink to this headline">¶</a></h4>
<p>The generics described in this design are similar to generics in
Rust.</p>
<p>One difference is that in Rust the association between a trait bound
and a type must be defined explicitly, either in the crate that
defines the trait bound or the crate that defines the type.
In Go terms, this would mean that we would have to declare somewhere
whether a type satisfied a constraint.
Just as Go types can satisfy Go interfaces without an explicit
declaration, in this design Go type arguments can satisfy a constraint
without an explicit declaration.</p>
<p>Where this design uses type lists, the Rust standard library defines
standard traits for operations like comparison.
These standard traits are automatically implemented by Rust’s
primitive types, and can be implemented by user defined types as
well.
Rust provides a fairly extensive list of traits, at least 34, covering
all of the operators.</p>
<p>Rust supports type parameters on methods, which this design does not.</p>
</div>
</div>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>The following sections are examples of how this design could be used.
This is intended to address specific areas where people have created
user experience reports concerned with Go’s lack of generics.</p>
<div class="section" id="map-reduce-filter">
<h3>Map/Reduce/Filter<a class="headerlink" href="#map-reduce-filter" title="Permalink to this headline">¶</a></h3>
<p>Here is an example of how to write map, reduce, and filter functions
for slices.
These functions are intended to correspond to the similar functions in
Lisp, Python, Java, and so forth.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Package slices implements various slice algorithms.</span>
<span class="kn">package</span> <span class="nx">slices</span>

<span class="c1">// Map turns a []T1 to a []T2 using a mapping function.</span>
<span class="c1">// This function has two type parameters, T1 and T2.</span>
<span class="c1">// There are no constraints on the type parameters,</span>
<span class="c1">// so this works with slices of any type.</span>
<span class="kd">func</span> <span class="nx">Map</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T1</span><span class="p">)</span> <span class="nx">T2</span><span class="p">)</span> <span class="p">[]</span><span class="nx">T2</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">T2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>

<span class="c1">// Reduce reduces a []T1 to a single value using a reduction function.</span>
<span class="kd">func</span> <span class="nx">Reduce</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">initializer</span> <span class="nx">T2</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T2</span><span class="p">,</span> <span class="nx">T1</span><span class="p">)</span> <span class="nx">T2</span><span class="p">)</span> <span class="nx">T2</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">initializer</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">r</span> <span class="p">=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>

<span class="c1">// Filter filters values from a slice using a filter function.</span>
<span class="c1">// It returns a new slice with only the elements of s</span>
<span class="c1">// for which f returned true.</span>
<span class="kd">func</span> <span class="nx">Filter</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">[]</span><span class="nx">T</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">r</span> <span class="p">[]</span><span class="nx">T</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">f</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">r</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here are some example calls of these functions.
Type inference is used to determine the type arguments based on the
types of the non-type arguments.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>

	<span class="nx">floats</span> <span class="o">:=</span> <span class="nx">slices</span><span class="p">.</span><span class="nx">Map</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">})</span>
	<span class="c1">// Now floats is []float64{1.0, 2.0, 3.0}.</span>

	<span class="nx">sum</span> <span class="o">:=</span> <span class="nx">slices</span><span class="p">.</span><span class="nx">Reduce</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">i</span> <span class="o">+</span> <span class="nx">j</span> <span class="p">})</span>
	<span class="c1">// Now sum is 6.</span>

	<span class="nx">evens</span> <span class="o">:=</span> <span class="nx">slices</span><span class="p">.</span><span class="nx">Filter</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">})</span>
	<span class="c1">// Now evens is []int{2}.</span>
</pre></div>
</div>
</div>
<div class="section" id="map-keys">
<h3>Map keys<a class="headerlink" href="#map-keys" title="Permalink to this headline">¶</a></h3>
<p>Here is how to get a slice of the keys of any map.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Package maps provides general functions that work for all map types.</span>
<span class="kn">package</span> <span class="nx">maps</span>

<span class="c1">// Keys returns the keys of the map m in a slice.</span>
<span class="c1">// The keys will be returned in an unpredictable order.</span>
<span class="c1">// This function has two type parameters, K and V.</span>
<span class="c1">// Map keys must be comparable, so key has the predeclared</span>
<span class="c1">// constraint comparable. Map values can be any type;</span>
<span class="c1">// the empty interface type imposes no constraints.</span>
<span class="kd">func</span> <span class="nx">Keys</span><span class="p">(</span><span class="kd">type</span> <span class="nx">K</span> <span class="nx">comparable</span><span class="p">,</span> <span class="nx">V</span> <span class="kd">interface</span><span class="p">{})(</span><span class="nx">m</span> <span class="kd">map</span><span class="p">[</span><span class="nx">K</span><span class="p">]</span><span class="nx">V</span><span class="p">)</span> <span class="p">[]</span><span class="nx">K</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">K</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
		<span class="nx">r</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In typical use the map key and val types will be inferred.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span>	<span class="nx">k</span> <span class="o">:=</span> <span class="nx">maps</span><span class="p">.</span><span class="nx">Keys</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">})</span>
	<span class="c1">// Now k is either []int{1, 2} or []int{2, 1}.</span>
</pre></div>
</div>
</div>
<div class="section" id="sets">
<h3>Sets<a class="headerlink" href="#sets" title="Permalink to this headline">¶</a></h3>
<p>Many people have asked for Go’s builtin map type to be extended, or
rather reduced, to support a set type.
Here is a type-safe implementation of a set type, albeit one that uses
methods rather than operators like <code class="docutils literal notranslate"><span class="pre">[]</span></code>.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Package set implements sets of any comparable type.</span>
<span class="kn">package</span> <span class="nx">set</span>

<span class="c1">// Set is a set of values.</span>
<span class="kd">type</span> <span class="nx">Set</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">comparable</span><span class="p">)</span> <span class="kd">map</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span><span class="kd">struct</span><span class="p">{}</span>

<span class="c1">// Make returns a set of some element type.</span>
<span class="kd">func</span> <span class="nx">Make</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">comparable</span><span class="p">)()</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">make</span><span class="p">(</span><span class="nx">Set</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// Add adds v to the set s.</span>
<span class="c1">// If v is already in s this has no effect.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">s</span><span class="p">[</span><span class="nx">v</span><span class="p">]</span> <span class="p">=</span> <span class="kd">struct</span><span class="p">{}{}</span>
<span class="p">}</span>

<span class="c1">// Delete removes v from the set s.</span>
<span class="c1">// If v is not in s this has no effect.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Delete</span><span class="p">(</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nb">delete</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Contains reports whether v is in s.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Contains</span><span class="p">(</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">v</span><span class="p">]</span>
	<span class="k">return</span> <span class="nx">ok</span>
<span class="p">}</span>

<span class="c1">// Len reports the number of elements in s.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Iterate invokes f on each element of s.</span>
<span class="c1">// It&#39;s OK for f to call the Delete method.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Iterate</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">f</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Example use:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span>	<span class="c1">// Create a set of ints.</span>
	<span class="c1">// We pass (int) as a type argument.</span>
	<span class="c1">// Then we write () because Make does not take any non-type arguments.</span>
	<span class="c1">// We have to pass an explicit type argument to Make.</span>
	<span class="c1">// Type inference doesn&#39;t work because the type argument</span>
	<span class="c1">// to Make is only used for a result parameter type.</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">set</span><span class="p">.</span><span class="nx">Make</span><span class="p">(</span><span class="kt">int</span><span class="p">)()</span>

	<span class="c1">// Add the value 1 to the set s.</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

	<span class="c1">// Check that s does not contain the value 2.</span>
	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Contains</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="nb">panic</span><span class="p">(</span><span class="s">&quot;unexpected 2&quot;</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>This example shows how to use this design to provide a compile-time
type-safe wrapper around an existing API.</p>
</div>
<div class="section" id="sort">
<h3>Sort<a class="headerlink" href="#sort" title="Permalink to this headline">¶</a></h3>
<p>Before the introduction of <code class="docutils literal notranslate"><span class="pre">sort.Slice</span></code>, a common complaint was the
need for boilerplate definitions in order to use <code class="docutils literal notranslate"><span class="pre">sort.Sort</span></code>.
With this design, we can add to the sort package as follows:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Ordered is a type constraint that matches all ordered types.</span>
<span class="c1">// (An ordered type is one that supports the &lt; &lt;= &gt;= &gt; operators.)</span>
<span class="c1">// In practice this type constraint would likely be defined in</span>
<span class="c1">// a standard library package.</span>
<span class="kd">type</span> <span class="nx">Ordered</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="kd">type</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int8</span><span class="p">,</span> <span class="kt">int16</span><span class="p">,</span> <span class="kt">int32</span><span class="p">,</span> <span class="kt">int64</span><span class="p">,</span>
		<span class="kt">uint</span><span class="p">,</span> <span class="kt">uint8</span><span class="p">,</span> <span class="kt">uint16</span><span class="p">,</span> <span class="kt">uint32</span><span class="p">,</span> <span class="kt">uint64</span><span class="p">,</span> <span class="kt">uintptr</span><span class="p">,</span>
		<span class="kt">float32</span><span class="p">,</span> <span class="kt">float64</span><span class="p">,</span>
		<span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// orderedSlice is an internal type that implements sort.Interface.</span>
<span class="c1">// The Less method uses the &lt; operator. The Ordered type constraint</span>
<span class="c1">// ensures that T has a &lt; operator.</span>
<span class="kd">type</span> <span class="nx">orderedSlice</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">Ordered</span><span class="p">)</span> <span class="p">[]</span><span class="nx">T</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">orderedSlice</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span>           <span class="p">{</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">orderedSlice</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">orderedSlice</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span>      <span class="p">{</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">}</span>

<span class="c1">// OrderedSlice sorts the slice s in ascending order.</span>
<span class="c1">// The elements of s must be ordered using the &lt; operator.</span>
<span class="kd">func</span> <span class="nx">OrderedSlice</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">Ordered</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Convert s to the type orderedSlice(T).</span>
	<span class="c1">// As s is []T, and orderedSlice(T) is defined as []T,</span>
	<span class="c1">// this conversion is permitted.</span>
	<span class="c1">// orderedSlice(T) implements sort.Interface,</span>
	<span class="c1">// so can pass the result to sort.Sort.</span>
	<span class="c1">// The elements will be sorted using the &lt; operator.</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">orderedSlice</span><span class="p">(</span><span class="nx">T</span><span class="p">)(</span><span class="nx">s</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now we can write:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span>	<span class="nx">s1</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int32</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nx">OrderedSlice</span><span class="p">(</span><span class="nx">s1</span><span class="p">)</span>
	<span class="c1">// Now s1 is []int32{2, 3, 5}</span>

	<span class="nx">s2</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">})</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nx">OrderedSlice</span><span class="p">(</span><span class="nx">s2</span><span class="p">)</span>
	<span class="c1">// Now s2 is []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}</span>
</pre></div>
</div>
<p>Along the same lines, we can add a function for sorting using a
comparison function, similar to <code class="docutils literal notranslate"><span class="pre">sort.Slice</span></code> but writing the function
to take values rather than slice indexes.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// sliceFn is an internal type that implements sort.Interface.</span>
<span class="c1">// The Less method calls the cmp field.</span>
<span class="kd">type</span> <span class="nx">sliceFn</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">s</span>   <span class="p">[]</span><span class="nx">T</span>
	<span class="nx">cmp</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">sliceFn</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span>           <span class="p">{</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">s</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">sliceFn</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">cmp</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">s</span><span class="p">.</span><span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">sliceFn</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span>      <span class="p">{</span> <span class="nx">s</span><span class="p">.</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">s</span><span class="p">.</span><span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">s</span><span class="p">.</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">}</span>

<span class="c1">// SliceFn sorts the slice s according to the function cmp.</span>
<span class="kd">func</span> <span class="nx">SliceFn</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">cmp</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">Sort</span><span class="p">(</span><span class="nx">sliceFn</span><span class="p">(</span><span class="nx">E</span><span class="p">){</span><span class="nx">s</span><span class="p">,</span> <span class="nx">cmp</span><span class="p">})</span>
<span class="p">}</span>
</pre></div>
</div>
<p>An example of calling this might be:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span>	<span class="kd">var</span> <span class="nx">s</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Person</span>
	<span class="c1">// ...</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nx">SliceFn</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span> <span class="o">*</span><span class="nx">Person</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">p1</span><span class="p">.</span><span class="nx">Name</span> <span class="p">&lt;</span> <span class="nx">p2</span><span class="p">.</span><span class="nx">Name</span> <span class="p">})</span>
</pre></div>
</div>
</div>
<div class="section" id="channels">
<h3>Channels<a class="headerlink" href="#channels" title="Permalink to this headline">¶</a></h3>
<p>Many simple general purpose channel functions are never written,
because they must be written using reflection and the caller must type
assert the results.
With this design they become straightforward to write.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Package chans implements various channel algorithms.</span>
<span class="kn">package</span> <span class="nx">chans</span>

<span class="kn">import</span> <span class="s">&quot;runtime&quot;</span>

<span class="c1">// Ranger provides a convenient way to exit a goroutine sending values</span>
<span class="c1">// when the receiver stops reading them.</span>
<span class="c1">//</span>
<span class="c1">// Ranger returns a Sender and a Receiver. The Receiver provides a</span>
<span class="c1">// Next method to retrieve values. The Sender provides a Send method</span>
<span class="c1">// to send values and a Close method to stop sending values. The Next</span>
<span class="c1">// method indicates when the Sender has been closed, and the Send</span>
<span class="c1">// method indicates when the Receiver has been freed.</span>
<span class="kd">func</span> <span class="nx">Ranger</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)()</span> <span class="p">(</span><span class="o">*</span><span class="nx">Sender</span><span class="p">(</span><span class="nx">T</span><span class="p">),</span> <span class="o">*</span><span class="nx">Receiver</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">T</span><span class="p">)</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Sender</span><span class="p">(</span><span class="nx">T</span><span class="p">){</span><span class="nx">values</span><span class="p">:</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">done</span><span class="p">:</span> <span class="nx">d</span><span class="p">}</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Receiver</span><span class="p">(</span><span class="nx">T</span><span class="p">){</span><span class="nx">values</span><span class="p">:</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">done</span><span class="p">:</span> <span class="nx">d</span><span class="p">}</span>
	<span class="c1">// The finalizer on the receiver will tell the sender</span>
	<span class="c1">// if the receiver stops listening.</span>
	<span class="nx">runtime</span><span class="p">.</span><span class="nx">SetFinalizer</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">finalize</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">r</span>
<span class="p">}</span>

<span class="c1">// A Sender is used to send values to a Receiver.</span>
<span class="kd">type</span> <span class="nx">Sender</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">values</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="nx">T</span>
	<span class="nx">done</span>   <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="c1">// Send sends a value to the receiver. It reports whether any more</span>
<span class="c1">// values may be sent; if it returns false the value was not sent.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Sender</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Send</span><span class="p">(</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">s</span><span class="p">.</span><span class="nx">values</span> <span class="o">&lt;-</span> <span class="nx">v</span><span class="p">:</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">s</span><span class="p">.</span><span class="nx">done</span><span class="p">:</span>
		<span class="c1">// The receiver has stopped listening.</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Close tells the receiver that no more values will arrive.</span>
<span class="c1">// After Close is called, the Sender may no longer be used.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Sender</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Close</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">values</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// A Receiver receives values from a Sender.</span>
<span class="kd">type</span> <span class="nx">Receiver</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">values</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">T</span>
	<span class="nx">done</span>  <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="c1">// Next returns the next value from the channel. The bool result</span>
<span class="c1">// reports whether the value is valid. If the value is not valid, the</span>
<span class="c1">// Sender has been closed and no more values will be received.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Receiver</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Next</span><span class="p">()</span> <span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">r</span><span class="p">.</span><span class="nx">values</span>
	<span class="k">return</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span>
<span class="p">}</span>

<span class="c1">// finalize is a finalizer for the receiver.</span>
<span class="c1">// It tells the sender that the receiver has stopped listening.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Receiver</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">finalize</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is an example of using this function in the next section.</p>
</div>
<div class="section" id="containers">
<h3>Containers<a class="headerlink" href="#containers" title="Permalink to this headline">¶</a></h3>
<p>One of the frequent requests for generics in Go is the ability to
write compile-time type-safe containers.
This design makes it easy to write a compile-time type-safe wrapper
around an existing container; we won’t write out an example for that.
This design also makes it easy to write a compile-time type-safe
container that does not use boxing.</p>
<p>Here is an example of an ordered map implemented as a binary tree.
The details of how it works are not too important.
The important points are:</p>
<ul class="simple">
<li><p>The code is written in a natural Go style, using the key and value
types where needed.</p></li>
<li><p>The keys and values are stored directly in the nodes of the tree,
not using pointers and not boxed as interface values.</p></li>
</ul>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Package orderedmap provides an ordered map, implemented as a binary tree.</span>
<span class="kn">package</span> <span class="nx">orderedmap</span>

<span class="kn">import</span> <span class="s">&quot;chans&quot;</span>

<span class="c1">// Map is an ordered map.</span>
<span class="kd">type</span> <span class="nx">Map</span><span class="p">(</span><span class="kd">type</span> <span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">root</span>    <span class="o">*</span><span class="nx">node</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">)</span>
	<span class="nx">compare</span> <span class="kd">func</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">K</span><span class="p">)</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="c1">// node is the type of a node in the binary tree.</span>
<span class="kd">type</span> <span class="nx">node</span><span class="p">(</span><span class="kd">type</span> <span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">k</span>           <span class="nx">K</span>
	<span class="nx">v</span>           <span class="nx">V</span>
	<span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="o">*</span><span class="nx">node</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// New returns a new map.</span>
<span class="c1">// Since the type parameter V is only used for the result,</span>
<span class="c1">// type inference does not work, and calls to New must always</span>
<span class="c1">// pass explicit type arguments.</span>
<span class="kd">func</span> <span class="nx">New</span><span class="p">(</span><span class="kd">type</span> <span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">)(</span><span class="nx">compare</span> <span class="kd">func</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">K</span><span class="p">)</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Map</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Map</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">){</span><span class="nx">compare</span><span class="p">:</span> <span class="nx">compare</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// find looks up k in the map, and returns either a pointer</span>
<span class="c1">// to the node holding k, or a pointer to the location where</span>
<span class="c1">// such a node would go.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">))</span> <span class="nx">find</span><span class="p">(</span><span class="nx">k</span> <span class="nx">K</span><span class="p">)</span> <span class="o">**</span><span class="nx">node</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">pn</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">m</span><span class="p">.</span><span class="nx">root</span>
	<span class="k">for</span> <span class="o">*</span><span class="nx">pn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="nx">cmp</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">compare</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="nx">pn</span><span class="p">).</span><span class="nx">k</span><span class="p">);</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">cmp</span> <span class="p">&lt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="nx">pn</span> <span class="p">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="nx">pn</span><span class="p">).</span><span class="nx">left</span>
		<span class="k">case</span> <span class="nx">cmp</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="nx">pn</span> <span class="p">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="nx">pn</span><span class="p">).</span><span class="nx">right</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="k">return</span> <span class="nx">pn</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">pn</span>
<span class="p">}</span>

<span class="c1">// Insert inserts a new key/value into the map.</span>
<span class="c1">// If the key is already present, the value is replaced.</span>
<span class="c1">// Reports whether this is a new key.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">))</span> <span class="nx">Insert</span><span class="p">(</span><span class="nx">k</span> <span class="nx">K</span><span class="p">,</span> <span class="nx">v</span> <span class="nx">V</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">pn</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span>
	<span class="k">if</span> <span class="o">*</span><span class="nx">pn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="p">(</span><span class="o">*</span><span class="nx">pn</span><span class="p">).</span><span class="nx">v</span> <span class="p">=</span> <span class="nx">v</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="nx">pn</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">node</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">){</span><span class="nx">k</span><span class="p">:</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">:</span> <span class="nx">v</span><span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="c1">// Find returns the value associated with a key, or zero if not present.</span>
<span class="c1">// The bool result reports whether the key was found.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">))</span> <span class="nx">Find</span><span class="p">(</span><span class="nx">k</span> <span class="nx">K</span><span class="p">)</span> <span class="p">(</span><span class="nx">V</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">pn</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span>
	<span class="k">if</span> <span class="o">*</span><span class="nx">pn</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">zero</span> <span class="nx">val</span> <span class="c1">// see the discussion of zero values, above</span>
		<span class="k">return</span> <span class="nx">zero</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">pn</span><span class="p">).</span><span class="nx">v</span><span class="p">,</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="c1">// keyValue is a pair of key and value used when iterating.</span>
<span class="kd">type</span> <span class="nx">keyValue</span><span class="p">(</span><span class="kd">type</span> <span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">k</span> <span class="nx">K</span>
	<span class="nx">v</span> <span class="nx">V</span>
<span class="p">}</span>

<span class="c1">// InOrder returns an iterator that does an in-order traversal of the map.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">))</span> <span class="nx">InOrder</span><span class="p">()</span> <span class="o">*</span><span class="nx">Iterator</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">type</span> <span class="nx">kv</span> <span class="p">=</span> <span class="nx">keyValue</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">)</span> <span class="c1">// convenient shorthand</span>
	<span class="nx">sender</span><span class="p">,</span> <span class="nx">receiver</span> <span class="o">:=</span> <span class="nx">chans</span><span class="p">.</span><span class="nx">Ranger</span><span class="p">(</span><span class="nx">kv</span><span class="p">)()</span>
	<span class="kd">var</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">node</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">))</span> <span class="kt">bool</span>
	<span class="nx">f</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">))</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
		<span class="c1">// Stop sending values if sender.Send returns false,</span>
		<span class="c1">// meaning that nothing is listening at the receiver end.</span>
		<span class="k">return</span> <span class="nx">f</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="nx">sender</span><span class="p">.</span><span class="nx">Send</span><span class="p">(</span><span class="nx">kv</span><span class="p">{</span><span class="nx">n</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">v</span><span class="p">})</span> <span class="o">&amp;&amp;</span>
			<span class="nx">f</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">f</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">root</span><span class="p">)</span>
		<span class="nx">sender</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
	<span class="p">}()</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Iterator</span><span class="p">{</span><span class="nx">receiver</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Iterator is used to iterate over the map.</span>
<span class="kd">type</span> <span class="nx">Iterator</span><span class="p">(</span><span class="kd">type</span> <span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">*</span><span class="nx">chans</span><span class="p">.</span><span class="nx">Receiver</span><span class="p">(</span><span class="nx">keyValue</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// Next returns the next key and value pair. The bool result reports</span>
<span class="c1">// whether the values are valid. If the values are not valid, we have</span>
<span class="c1">// reached the end.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">it</span> <span class="o">*</span><span class="nx">Iterator</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">))</span> <span class="nx">Next</span><span class="p">()</span> <span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">kv</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nx">Next</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">k</span><span class="p">,</span> <span class="nx">kv</span><span class="p">.</span><span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is what it looks like to use this package:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="s">&quot;container/orderedmap&quot;</span>

<span class="c1">// Set m to an ordered map from string to string,</span>
<span class="c1">// using strings.Compare as the comparison function.</span>
<span class="kd">var</span> <span class="nx">m</span> <span class="p">=</span> <span class="nx">orderedmap</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">)(</span><span class="nx">strings</span><span class="p">.</span><span class="nx">Compare</span><span class="p">)</span>

<span class="c1">// Add adds the pair a, b to m.</span>
<span class="kd">func</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">.</span><span class="nx">Insert</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="append">
<h3>Append<a class="headerlink" href="#append" title="Permalink to this headline">¶</a></h3>
<p>The predeclared <code class="docutils literal notranslate"><span class="pre">append</span></code> function exists to replace the boilerplate
otherwise required to grow a slice.
Before <code class="docutils literal notranslate"><span class="pre">append</span></code> was added to the language, there was a function <code class="docutils literal notranslate"><span class="pre">Add</span></code>
in the bytes package:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Add appends the contents of t to the end of s and returns the result.</span>
<span class="c1">// If s has enough capacity, it is extended in place; otherwise a</span>
<span class="c1">// new array is allocated and returned.</span>
<span class="kd">func</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">t</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Add</span></code> appended two <code class="docutils literal notranslate"><span class="pre">[]byte</span></code> values together, returning a new slice.
That was fine for <code class="docutils literal notranslate"><span class="pre">[]byte</span></code>, but if you had a slice of some other
type, you had to write essentially the same code to append more
values.
If this design were available back then, perhaps we would not have
added <code class="docutils literal notranslate"><span class="pre">append</span></code> to the language.
Instead, we could write something like this:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Package slices implements various slice algorithms.</span>
<span class="kn">package</span> <span class="nx">slices</span>

<span class="c1">// Append appends the contents of t to the end of s and returns the result.</span>
<span class="c1">// If s has enough capacity, it is extended in place; otherwise a</span>
<span class="c1">// new array is allocated and returned.</span>
<span class="kd">func</span> <span class="nx">Append</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">t</span> <span class="o">...</span><span class="nx">T</span><span class="p">)</span> <span class="p">[]</span><span class="nx">T</span> <span class="p">{</span>
	<span class="nx">lens</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="nx">tot</span> <span class="o">:=</span> <span class="nx">lens</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">tot</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&quot;Append: cap out of range&quot;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">tot</span> <span class="p">&gt;</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">news</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">tot</span><span class="p">,</span> <span class="nx">tot</span> <span class="o">+</span> <span class="nx">tot</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
		<span class="nb">copy</span><span class="p">(</span><span class="nx">news</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
		<span class="nx">s</span> <span class="p">=</span> <span class="nx">news</span>
	<span class="p">}</span>
	<span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[:</span><span class="nx">tot</span><span class="p">]</span>
	<span class="nb">copy</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">lens</span><span class="p">:],</span> <span class="nx">t</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</pre></div>
</div>
<p>That example uses the predeclared <code class="docutils literal notranslate"><span class="pre">copy</span></code> function, but that’s OK, we
can write that one too:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Copy copies values from t to s, stopping when either slice is</span>
<span class="c1">// full, returning the number of values copied.</span>
<span class="kd">func</span> <span class="nx">Copy</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">t</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">t</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">i</span>
<span class="p">}</span>
</pre></div>
</div>
<p>These functions can be used as one would expect:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">slices</span><span class="p">.</span><span class="nx">Append</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
	<span class="c1">// Now s is []int{1, 2, 3, 4, 5, 6}.</span>
	<span class="nx">slices</span><span class="p">.</span><span class="nx">Copy</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">3</span><span class="p">:],</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">})</span>
	<span class="c1">// Now s is []int{1, 2, 3, 7, 8, 9}</span>
</pre></div>
</div>
<p>This code doesn’t implement the special case of appending or copying a
<code class="docutils literal notranslate"><span class="pre">string</span></code> to a <code class="docutils literal notranslate"><span class="pre">[]byte</span></code>, and it’s unlikely to be as efficient as the
implementation of the predeclared function.
Still, this example shows that using this design would permit <code class="docutils literal notranslate"><span class="pre">append</span></code>
and <code class="docutils literal notranslate"><span class="pre">copy</span></code> to be written generically, once, without requiring any
additional special language features.</p>
</div>
<div class="section" id="metrics">
<h3>Metrics<a class="headerlink" href="#metrics" title="Permalink to this headline">¶</a></h3>
<p>In a <a class="reference external" href="https://medium.com/&#64;sameer_74231/go-experience-report-for-generics-google-metrics-api-b019d597aaa4">Go experience
report</a>
Sameer Ajmani describes a metrics implementation.
Each metric has a value and one or more fields.
The fields have different types.
Defining a metric requires specifying the types of the fields, and
creating a value with an Add method.
The Add method takes the field types as arguments, and records an
instance of that set of fields.
The C++ implementation uses a variadic template.
The Java implementation includes the number of fields in the name of
the type.
Both the C++ and Java implementations provide compile-time type-safe
Add methods.</p>
<p>Here is how to use this design to provide similar functionality in
Go with a compile-time type-safe Add method.
Because there is no support for a variadic number of type arguments,
we must use different names for a different number of arguments, as in
Java.
This implementation only works for comparable types.
A more complex implementation could accept a comparison function to
work with arbitrary types.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Package metrics provides a general mechanism for accumulating</span>
<span class="c1">// metrics of different values.</span>
<span class="kn">package</span> <span class="nx">metrics</span>

<span class="kn">import</span> <span class="s">&quot;sync&quot;</span>

<span class="c1">// Metric1 accumulates metrics of a single value.</span>
<span class="kd">type</span> <span class="nx">Metric1</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">comparable</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
	<span class="nx">m</span>  <span class="kd">map</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span><span class="kt">int</span>
<span class="p">}</span>

<span class="c1">// Add adds an instance of a value.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Metric1</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">m</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">m</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">v</span><span class="p">]</span><span class="o">++</span>
<span class="p">}</span>

<span class="c1">// key2 is an internal type used by Metric2.</span>
<span class="kd">type</span> <span class="nx">key2</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span> <span class="nx">comparable</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">f1</span> <span class="nx">T1</span>
	<span class="nx">f2</span> <span class="nx">T2</span>
<span class="p">}</span>

<span class="c1">// Metric2 accumulates metrics of pairs of values.</span>
<span class="kd">type</span> <span class="nx">Metric2</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span> <span class="nx">comparable</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
	<span class="nx">m</span>  <span class="kd">map</span><span class="p">[</span><span class="nx">key2</span><span class="p">(</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">)]</span><span class="kt">int</span>
<span class="p">}</span>

<span class="c1">// Add adds an instance of a value pair.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Metric2</span><span class="p">(</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">))</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">v1</span> <span class="nx">T1</span><span class="p">,</span> <span class="nx">v2</span> <span class="nx">T2</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">m</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">key2</span><span class="p">(</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">)]</span><span class="kt">int</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">m</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key2</span><span class="p">(</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">){</span><span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">}]</span><span class="o">++</span>
<span class="p">}</span>

<span class="c1">// key3 is an internal type used by Metric3.</span>
<span class="kd">type</span> <span class="nx">key3</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">,</span> <span class="nx">T3</span> <span class="nx">comparable</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">f1</span> <span class="nx">T1</span>
	<span class="nx">f2</span> <span class="nx">T2</span>
	<span class="nx">f3</span> <span class="nx">T3</span>
<span class="p">}</span>

<span class="c1">// Metric3 accumulates metrics of triples of values.</span>
<span class="kd">type</span> <span class="nx">Metric3</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">,</span> <span class="nx">T3</span> <span class="nx">comparable</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
	<span class="nx">m</span>  <span class="kd">map</span><span class="p">[</span><span class="nx">key3</span><span class="p">(</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">,</span> <span class="nx">T3</span><span class="p">)]</span><span class="kt">int</span>
<span class="p">}</span>

<span class="c1">// Add adds an instance of a value triplet.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Metric3</span><span class="p">(</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">,</span> <span class="nx">T3</span><span class="p">))</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">v1</span> <span class="nx">T1</span><span class="p">,</span> <span class="nx">v2</span> <span class="nx">T2</span><span class="p">,</span> <span class="nx">v3</span> <span class="nx">T3</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">m</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">key3</span><span class="p">(</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">,</span> <span class="nx">T3</span><span class="p">)]</span><span class="kt">int</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">m</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key3</span><span class="p">(</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">,</span> <span class="nx">T3</span><span class="p">){</span><span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">,</span> <span class="nx">v3</span><span class="p">}]</span><span class="o">++</span>
<span class="p">}</span>

<span class="c1">// Repeat for the maximum number of permitted arguments.</span>
</pre></div>
</div>
<p>Using this package looks like this:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="s">&quot;metrics&quot;</span>

<span class="kd">var</span> <span class="nx">m</span> <span class="p">=</span> <span class="nx">metrics</span><span class="p">.</span><span class="nx">Metric2</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">){}</span>

<span class="kd">func</span> <span class="nx">F</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="c1">// this call is type checked at compile time</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This implementation has a certain amount of repetition due to the lack
of support for variadic type parameters.
Using the package, though, is easy and type safe.</p>
</div>
<div class="section" id="list-transform">
<h3>List transform<a class="headerlink" href="#list-transform" title="Permalink to this headline">¶</a></h3>
<p>While slices are efficient and easy to use, there are occasional cases
where a linked list is appropriate.
This example primarily shows transforming a linked list of one type to
another type, as an example of using different instantiations of the
same generic type.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Package list provides a linked list of any type.</span>
<span class="kn">package</span> <span class="nx">list</span>

<span class="c1">// List is a linked list.</span>
<span class="kd">type</span> <span class="nx">List</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">head</span><span class="p">,</span> <span class="nx">tail</span> <span class="o">*</span><span class="nx">element</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// An element is an entry in a linked list.</span>
<span class="kd">type</span> <span class="nx">element</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">next</span> <span class="o">*</span><span class="nx">element</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span>
	<span class="nx">val</span>  <span class="nx">T</span>
<span class="p">}</span>

<span class="c1">// Push pushes an element to the end of the list.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">lst</span> <span class="o">*</span><span class="nx">List</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Push</span><span class="p">(</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">lst</span><span class="p">.</span><span class="nx">tail</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">lst</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">element</span><span class="p">(</span><span class="nx">T</span><span class="p">){</span><span class="nx">val</span><span class="p">:</span> <span class="nx">v</span><span class="p">}</span>
		<span class="nx">lst</span><span class="p">.</span><span class="nx">tail</span> <span class="p">=</span> <span class="nx">lst</span><span class="p">.</span><span class="nx">head</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">lst</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">element</span><span class="p">(</span><span class="nx">T</span><span class="p">){</span><span class="nx">val</span><span class="p">:</span> <span class="nx">v</span> <span class="p">}</span>
		<span class="nx">lst</span><span class="p">.</span><span class="nx">tail</span> <span class="p">=</span> <span class="nx">lst</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nx">next</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Iterator ranges over a list.</span>
<span class="kd">type</span> <span class="nx">Iterator</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">next</span> <span class="o">**</span><span class="nx">element</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Range returns an Iterator starting at the head of the list.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">lst</span> <span class="o">*</span><span class="nx">List</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Range</span><span class="p">()</span> <span class="o">*</span><span class="nx">Iterator</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">Iterator</span><span class="p">(</span><span class="nx">T</span><span class="p">){</span><span class="nx">next</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">lst</span><span class="p">.</span><span class="nx">head</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Next advances the iterator.</span>
<span class="c1">// It reports whether there are more elements.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">it</span> <span class="o">*</span><span class="nx">Iterator</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Next</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="o">*</span><span class="nx">it</span><span class="p">.</span><span class="nx">next</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">it</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">).</span><span class="nx">next</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="c1">// Val returns the value of the current element.</span>
<span class="c1">// The bool result reports whether the value is valid.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">it</span> <span class="o">*</span><span class="nx">Iterator</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Val</span><span class="p">()</span> <span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="o">*</span><span class="nx">it</span><span class="p">.</span><span class="nx">next</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">zero</span> <span class="nx">T</span>
		<span class="k">return</span> <span class="nx">zero</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">it</span><span class="p">.</span><span class="nx">next</span><span class="p">).</span><span class="nx">val</span><span class="p">,</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="c1">// Transform runs a transform function on a list returning a new list.</span>
<span class="kd">func</span> <span class="nx">Transform</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">)(</span><span class="nx">lst</span> <span class="o">*</span><span class="nx">List</span><span class="p">(</span><span class="nx">T1</span><span class="p">),</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T1</span><span class="p">)</span> <span class="nx">T2</span><span class="p">)</span> <span class="o">*</span><span class="nx">List</span><span class="p">(</span><span class="nx">T2</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">List</span><span class="p">(</span><span class="nx">T2</span><span class="p">){}</span>
	<span class="nx">it</span> <span class="o">:=</span> <span class="nx">lst</span><span class="p">.</span><span class="nx">Range</span><span class="p">()</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">it</span><span class="p">.</span><span class="nx">Val</span><span class="p">();</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="nx">ret</span><span class="p">.</span><span class="nx">Push</span><span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">it</span><span class="p">.</span><span class="nx">Next</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="dot-product">
<h3>Dot product<a class="headerlink" href="#dot-product" title="Permalink to this headline">¶</a></h3>
<p>A generic dot product implementation that works for slices of any
numeric type.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Numeric is a constraint that matches any numeric type.</span>
<span class="c1">// It would likely be in a constraints package in the standard library.</span>
<span class="kd">type</span> <span class="nx">Numeric</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="kd">type</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int8</span><span class="p">,</span> <span class="kt">int16</span><span class="p">,</span> <span class="kt">int32</span><span class="p">,</span> <span class="kt">int64</span><span class="p">,</span>
		<span class="kt">uint</span><span class="p">,</span> <span class="kt">uint8</span><span class="p">,</span> <span class="kt">uint16</span><span class="p">,</span> <span class="kt">uint32</span><span class="p">,</span> <span class="kt">uint64</span><span class="p">,</span> <span class="kt">uintptr</span><span class="p">,</span>
		<span class="kt">float32</span><span class="p">,</span> <span class="kt">float64</span><span class="p">,</span>
		<span class="kt">complex64</span><span class="p">,</span> <span class="kt">complex128</span>
<span class="p">}</span>

<span class="c1">// DotProduct returns the dot product of two slices.</span>
<span class="c1">// This panics if the two slices are not the same length.</span>
<span class="kd">func</span> <span class="nx">DotProduct</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">Numeric</span><span class="p">)(</span><span class="nx">s1</span><span class="p">,</span> <span class="nx">s2</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s2</span><span class="p">)</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&quot;DotProduct: slices of unequal length&quot;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">r</span> <span class="nx">T</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s1</span> <span class="p">{</span>
		<span class="nx">r</span> <span class="o">+=</span> <span class="nx">s1</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">*</span> <span class="nx">s2</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</pre></div>
</div>
<p>(Note: the generics implementation approach may affect whether
<code class="docutils literal notranslate"><span class="pre">DotProduct</span></code> uses FMA, and thus what the exact results are when using
floating point types.
It’s not clear how much of a problem this is, or whether there is any
way to fix it.)</p>
</div>
<div class="section" id="absolute-difference">
<h3>Absolute difference<a class="headerlink" href="#absolute-difference" title="Permalink to this headline">¶</a></h3>
<p>Compute the absolute difference between two numeric values, by using
an <code class="docutils literal notranslate"><span class="pre">Abs</span></code> method.
This uses the same <code class="docutils literal notranslate"><span class="pre">Numeric</span></code> constraint defined in the last example.</p>
<p>This example uses more machinery than is appropriate for the simple
case of computing the absolute difference.
It is intended to show how the common part of algorithms can be
factored into code that uses methods, where the exact definition of
the methods can vary based on the kind of type being used.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// NumericAbs matches numeric types with an Abs method.</span>
<span class="kd">type</span> <span class="nx">NumericAbs</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Numeric</span>
	<span class="nx">Abs</span><span class="p">()</span> <span class="nx">T</span>
<span class="p">}</span>

<span class="c1">// AbsDifference computes the absolute value of the difference of</span>
<span class="c1">// a and b, where the absolute value is determined by the Abs method.</span>
<span class="kd">func</span> <span class="nx">AbsDifference</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">NumericAbs</span><span class="p">)(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span>
	<span class="k">return</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Abs</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can define an <code class="docutils literal notranslate"><span class="pre">Abs</span></code> method appropriate for different numeric types.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// OrderedNumeric matches numeric types that support the &lt; operator.</span>
<span class="kd">type</span> <span class="nx">OrderedNumeric</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="kd">type</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int8</span><span class="p">,</span> <span class="kt">int16</span><span class="p">,</span> <span class="kt">int32</span><span class="p">,</span> <span class="kt">int64</span><span class="p">,</span>
		<span class="kt">uint</span><span class="p">,</span> <span class="kt">uint8</span><span class="p">,</span> <span class="kt">uint16</span><span class="p">,</span> <span class="kt">uint32</span><span class="p">,</span> <span class="kt">uint64</span><span class="p">,</span> <span class="kt">uintptr</span><span class="p">,</span>
		<span class="kt">float32</span><span class="p">,</span> <span class="kt">float64</span>
<span class="p">}</span>

<span class="c1">// Complex matches the two complex types, which do not have a &lt; operator.</span>
<span class="kd">type</span> <span class="nx">Complex</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="kd">type</span> <span class="kt">complex64</span><span class="p">,</span> <span class="kt">complex128</span>
<span class="p">}</span>

<span class="c1">// OrderedAbs is a helper type that defines an Abs method for</span>
<span class="c1">// ordered numeric types.</span>
<span class="kd">type</span> <span class="nx">OrderedAbs</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">OrderedNumeric</span><span class="p">)</span> <span class="nx">T</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="nx">OrderedAbs</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Abs</span><span class="p">()</span> <span class="nx">OrderedAbs</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">a</span>
<span class="p">}</span>

<span class="c1">// ComplexAbs is a helper type that defines an Abs method for</span>
<span class="c1">// complex types.</span>
<span class="kd">type</span> <span class="nx">ComplexAbs</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">Complex</span><span class="p">)</span> <span class="nx">T</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="nx">ComplexAbs</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Abs</span><span class="p">()</span> <span class="nx">ComplexAbs</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Hypot</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nb">real</span><span class="p">(</span><span class="nx">a</span><span class="p">)),</span> <span class="nb">float64</span><span class="p">(</span><span class="nb">imag</span><span class="p">(</span><span class="nx">a</span><span class="p">)))</span>
	<span class="k">return</span> <span class="nx">ComplexAbs</span><span class="p">(</span><span class="nx">T</span><span class="p">)(</span><span class="nb">complex</span><span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can then define functions that do the work for the caller by
converting to and from the types we just defined.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// OrderedAbsDifference returns the absolute value of the difference</span>
<span class="c1">// between a and b, where a and b are of an ordered type.</span>
<span class="kd">func</span> <span class="nx">OrderedAbsDifference</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">OrderedNumeric</span><span class="p">)(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">T</span><span class="p">(</span><span class="nx">AbsDifference</span><span class="p">(</span><span class="nx">OrderedAbs</span><span class="p">(</span><span class="nx">T</span><span class="p">)(</span><span class="nx">a</span><span class="p">),</span> <span class="nx">OrderedAbs</span><span class="p">(</span><span class="nx">T</span><span class="p">)(</span><span class="nx">b</span><span class="p">)))</span>
<span class="p">}</span>

<span class="c1">// ComplexAbsDifference returns the absolute value of the difference</span>
<span class="c1">// between a and b, where a and b are of a complex type.</span>
<span class="kd">func</span> <span class="nx">ComplexAbsDifference</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">Complex</span><span class="p">)(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">T</span><span class="p">(</span><span class="nx">AbsDifference</span><span class="p">(</span><span class="nx">ComplexAbs</span><span class="p">(</span><span class="nx">T</span><span class="p">)(</span><span class="nx">a</span><span class="p">),</span> <span class="nx">ComplexAbs</span><span class="p">(</span><span class="nx">T</span><span class="p">)(</span><span class="nx">b</span><span class="p">)))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It’s worth noting that this design is not powerful enough to write
code like the following:</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// This function is INVALID.</span>
<span class="kd">func</span> <span class="nx">GeneralAbsDifference</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="nx">Numeric</span><span class="p">)(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{})(</span><span class="nx">a</span><span class="p">).(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int8</span><span class="p">,</span> <span class="kt">int16</span><span class="p">,</span> <span class="kt">int32</span><span class="p">,</span> <span class="kt">int64</span><span class="p">,</span>
		<span class="kt">uint</span><span class="p">,</span> <span class="kt">uint8</span><span class="p">,</span> <span class="kt">uint16</span><span class="p">,</span> <span class="kt">uint32</span><span class="p">,</span> <span class="kt">uint64</span><span class="p">,</span> <span class="kt">uintptr</span><span class="p">,</span>
		<span class="kt">float32</span><span class="p">,</span> <span class="kt">float64</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">OrderedAbsDifference</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="c1">// INVALID</span>
	<span class="k">case</span> <span class="kt">complex64</span><span class="p">,</span> <span class="kt">complex128</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">ComplexAbsDifference</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="c1">// INVALID</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The calls to <code class="docutils literal notranslate"><span class="pre">OrderedAbsDifference</span></code> and <code class="docutils literal notranslate"><span class="pre">ComplexAbsDifference</span></code> are
invalid, because not all the types that implement the <code class="docutils literal notranslate"><span class="pre">Numeric</span></code>
constraint can implement the <code class="docutils literal notranslate"><span class="pre">OrderedNumeric</span></code> or <code class="docutils literal notranslate"><span class="pre">Complex</span></code>
constraints.
Although the type switch means that this code would conceptually work
at run time, there is no support for writing this code at compile
time.
This is another way of expressing one of the omissions listed above:
this design does not provide for specialization.</p>
</div>
</div>
<div class="section" id="acknowledgements">
<h2>Acknowledgements<a class="headerlink" href="#acknowledgements" title="Permalink to this headline">¶</a></h2>
<p>We’d like to thank many people on the Go team, many contributors to
the Go issue tracker, and all the people who have shared their ideas
and their feedback on earlier design drafts.
We read all of it, and we’re grateful.</p>
<p>For this design draft in particular we received detailed feedback from
Josh Bleecher-Snyder, Jon Bodner, Dave Cheney, Jaana Dogan, Kevin
Gillette, Mitchell Hashimoto, Chris Hines, Bill Kennedy, Ayke van
Laethem, Daniel Martí, Elena Morozova, Roger Peppe, and Ronna
Steinberg.</p>
</div>
<div class="section" id="appendix">
<h2>Appendix<a class="headerlink" href="#appendix" title="Permalink to this headline">¶</a></h2>
<p>This appendix covers various details of the design that don’t seem
significant enough to cover in earlier sections.</p>
<div class="section" id="generic-type-aliases">
<h3>Generic type aliases<a class="headerlink" href="#generic-type-aliases" title="Permalink to this headline">¶</a></h3>
<p>A type alias may refer to a generic type, but the type alias may not
have its own parameters.
This restriction exists because it is unclear how to handle a type
alias with type parameters that have constraints.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">VectorAlias</span> <span class="p">=</span> <span class="nx">Vector</span>
</pre></div>
</div>
<p>In this case uses of the type alias will have to provide type
arguments appropriate for the generic type being aliased.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">v</span> <span class="nx">VectorAlias</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
</pre></div>
</div>
<p>Type aliases may also refer to instantiated types.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">VectorInt</span> <span class="p">=</span> <span class="nx">Vector</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="instantiating-a-function">
<h3>Instantiating a function<a class="headerlink" href="#instantiating-a-function" title="Permalink to this headline">¶</a></h3>
<p>Go normally permits you to refer to a function without passing any
arguments, producing a value of function type.
You may not do this with a function that has type parameters; all type
arguments must be known at compile time.
That said, you can instantiate the function, by passing type
arguments, but you don’t have to call the instantiation.
This will produce a function value with no type parameters.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// PrintInts is type func([]int).</span>
<span class="kd">var</span> <span class="nx">PrintInts</span> <span class="p">=</span> <span class="nx">Print</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="embedded-type-parameter">
<h3>Embedded type parameter<a class="headerlink" href="#embedded-type-parameter" title="Permalink to this headline">¶</a></h3>
<p>When a generic type is a struct, and the type parameter is
embedded as a field in the struct, the name of the field is the name
of the type parameter.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// A Lockable is a value that may be safely simultaneously accessed</span>
<span class="c1">// from multiple goroutines via the Get and Set methods.</span>
<span class="kd">type</span> <span class="nx">Lockable</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">T</span>
	<span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="p">}</span>

<span class="c1">// Get returns the value stored in a Lockable.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Lockable</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Get</span><span class="p">()</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">l</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">l</span><span class="p">.</span><span class="nx">T</span>
<span class="p">}</span>

<span class="c1">// Set sets the value in a Lockable.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Lockable</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">l</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">T</span> <span class="p">=</span> <span class="nx">v</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="inline-constraints">
<h3>Inline constraints<a class="headerlink" href="#inline-constraints" title="Permalink to this headline">¶</a></h3>
<p>As we’ve seen in examples that use <code class="docutils literal notranslate"><span class="pre">interface{}</span></code> as a type constraint,
it’s not necessary for a constraint to use a named interface type.
A type parameter list can use an interface type literal, just as an
ordinary parameter list can use a type literal for a parameter type.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Stringify calls the String method on each element of s,</span>
<span class="c1">// and returns the results.</span>
<span class="kd">func</span> <span class="nx">Stringify</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">})(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">(</span><span class="nx">ret</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">ret</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ret</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">String</span><span class="p">())</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="type-inference-for-composite-literals">
<h3>Type inference for composite literals<a class="headerlink" href="#type-inference-for-composite-literals" title="Permalink to this headline">¶</a></h3>
<p>This is a feature we are not suggesting now, but could consider for
later versions of the language.</p>
<p>We could also consider supporting type inference for composite
literals of generic types.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Pair</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">f1</span><span class="p">,</span> <span class="nx">f2</span> <span class="nx">T</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nx">V</span> <span class="p">=</span> <span class="nx">Pair</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span> <span class="c1">// inferred as Pair(int){1, 2}</span>
</pre></div>
</div>
<p>It’s not clear how often this will arise in real code.</p>
</div>
<div class="section" id="type-inference-for-generic-function-arguments">
<h3>Type inference for generic function arguments<a class="headerlink" href="#type-inference-for-generic-function-arguments" title="Permalink to this headline">¶</a></h3>
<p>This is a feature we are not suggesting now, but could consider for
later versions of the language.</p>
<p>In the following example, consider the call to <code class="docutils literal notranslate"><span class="pre">Find</span></code> in <code class="docutils literal notranslate"><span class="pre">FindClose</span></code>.
Type inference can determine that the type argument to <code class="docutils literal notranslate"><span class="pre">Find</span></code> is <code class="docutils literal notranslate"><span class="pre">T4</span></code>,
and from that we know that the type of the final argument must be
<code class="docutils literal notranslate"><span class="pre">func(T4,</span> <span class="pre">T4)</span> <span class="pre">bool</span></code>, and from that we could deduce that the type
argument to <code class="docutils literal notranslate"><span class="pre">IsClose</span></code> must also be <code class="docutils literal notranslate"><span class="pre">T4</span></code>.
However, the type inference algorithm described earlier cannot do
that, so we must explicitly write <code class="docutils literal notranslate"><span class="pre">IsClose(T4)</span></code>.</p>
<p>This may seem esoteric at first, but it comes up when passing generic
functions to generic <code class="docutils literal notranslate"><span class="pre">Map</span></code> and <code class="docutils literal notranslate"><span class="pre">Filter</span></code> functions.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Differ has a Diff method that returns how different a value is.</span>
<span class="kd">type</span> <span class="nx">Differ</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T1</span><span class="p">)</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Diff</span><span class="p">(</span><span class="nx">T1</span><span class="p">)</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="c1">// IsClose returns whether a and b are close together, based on Diff.</span>
<span class="kd">func</span> <span class="nx">IsClose</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T2</span> <span class="nx">Differ</span><span class="p">)(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T2</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Diff</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">2</span>
<span class="p">}</span>

<span class="c1">// Find returns the index of the first element in s that matches e,</span>
<span class="c1">// based on the cmp function. It returns -1 if no element matches.</span>
<span class="kd">func</span> <span class="nx">Find</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T3</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T3</span><span class="p">,</span> <span class="nx">e</span> <span class="nx">T3</span><span class="p">,</span> <span class="nx">cmp</span> <span class="kd">func</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T3</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">cmp</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">i</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>

<span class="c1">// FindClose returns the index of the first element in s that is</span>
<span class="c1">// close to e, based on IsClose.</span>
<span class="kd">func</span> <span class="nx">FindClose</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T4</span> <span class="nx">Differ</span><span class="p">)(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T4</span><span class="p">,</span> <span class="nx">e</span> <span class="nx">T4</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// With the current type inference algorithm we have to</span>
	<span class="c1">// explicitly write IsClose(T4) here, although it</span>
	<span class="c1">// is the only type argument we could possibly use.</span>
	<span class="k">return</span> <span class="nx">Find</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">IsClose</span><span class="p">(</span><span class="nx">T4</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="reflection-on-type-arguments">
<h3>Reflection on type arguments<a class="headerlink" href="#reflection-on-type-arguments" title="Permalink to this headline">¶</a></h3>
<p>Although we don’t suggest changing the reflect package, one
possibility to consider for the future would be to add two new
methods to <code class="docutils literal notranslate"><span class="pre">reflect.Type</span></code>: <code class="docutils literal notranslate"><span class="pre">NumTypeArgument()</span> <span class="pre">int</span></code> would return the
number of type arguments to a type, and <code class="docutils literal notranslate"><span class="pre">TypeArgument(i)</span> <span class="pre">Type</span></code> would
return the i’th type argument.
<code class="docutils literal notranslate"><span class="pre">NumTypeArgument</span></code> would return non-zero for an instantiated generic
type.
Similar methods could be defined for <code class="docutils literal notranslate"><span class="pre">reflect.Value</span></code>, for which
<code class="docutils literal notranslate"><span class="pre">NumTypeArgument</span></code> would return non-zero for an instantiated generic
function.
There might be some kind of programs that would care about this
information.</p>
</div>
<div class="section" id="instantiating-types-in-type-literals">
<h3>Instantiating types in type literals<a class="headerlink" href="#instantiating-types-in-type-literals" title="Permalink to this headline">¶</a></h3>
<p>When instantiating a type at the end of a type literal, there is a
parsing ambiguity.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="nx">x1</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">T</span><span class="p">(</span><span class="nx">v1</span><span class="p">)</span>
<span class="nx">x2</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">T</span><span class="p">(</span><span class="nx">v2</span><span class="p">){}</span>
</pre></div>
</div>
<p>In this example, the first case is a type conversion of <code class="docutils literal notranslate"><span class="pre">v1</span></code> to the
type <code class="docutils literal notranslate"><span class="pre">[]T</span></code>.
The second case is a composite literal of type <code class="docutils literal notranslate"><span class="pre">[]T(v2)</span></code>, where <code class="docutils literal notranslate"><span class="pre">T</span></code> is
a generic type that we are instantiating with the type argument <code class="docutils literal notranslate"><span class="pre">v2</span></code>.
The ambiguity is at the point where we see the open parenthesis: at
that point the parser doesn’t know whether it is seeing a type
conversion or something like a composite literal.</p>
<p>To avoid this ambiguity, we require that type instantiations at the
end of a type literal be parenthesized.
To write a type literal that is a slice of a type instantiation, you
must write <code class="docutils literal notranslate"><span class="pre">[](T(v1))</span></code>.
Without those parentheses, <code class="docutils literal notranslate"><span class="pre">[]T(x)</span></code> is parsed as <code class="docutils literal notranslate"><span class="pre">([]T)(x)</span></code>, not as
<code class="docutils literal notranslate"><span class="pre">[](T(x))</span></code>.
This only applies to slice, array, map, chan, and func type literals
ending in a type name.
Of course it is always possible to use a separate type declaration to
give a name to the instantiated type, and to use that.</p>
</div>
<div class="section" id="embedding-an-instantiated-interface-type">
<h3>Embedding an instantiated interface type<a class="headerlink" href="#embedding-an-instantiated-interface-type" title="Permalink to this headline">¶</a></h3>
<p>There is a parsing ambiguity when embedding an instantiated interface
type in another interface type.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">I1</span><span class="p">(</span><span class="kd">type</span> <span class="nx">T</span><span class="p">)</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">M</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">I2</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">I1</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example we don’t know whether interface <code class="docutils literal notranslate"><span class="pre">I2</span></code> has a single
method named <code class="docutils literal notranslate"><span class="pre">I1</span></code> that takes an argument of type <code class="docutils literal notranslate"><span class="pre">int</span></code>, or whether we
are trying to embed the instantiated type <code class="docutils literal notranslate"><span class="pre">I1(int)</span></code> into <code class="docutils literal notranslate"><span class="pre">I2</span></code>.</p>
<p>For backward compatibility, we treat this as the former case: <code class="docutils literal notranslate"><span class="pre">I2</span></code> has
a method named <code class="docutils literal notranslate"><span class="pre">I1</span></code>.</p>
<p>In order to embed an instantiated interface type, we require
that extra parentheses be used.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">I2</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="p">(</span><span class="nx">I1</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is currently not permitted by the language, and will be a
relaxation of the existing rules.</p>
<p>The same applies to embedding an instantiated type in a struct.</p>
<div class="highlight-Go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">S1</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">T</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="c1">// field named T of type int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">S2</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="p">(</span><span class="nx">T</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span> <span class="c1">// embedded field of type T(int)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The field name of an embedded field of type <code class="docutils literal notranslate"><span class="pre">T(int)</span></code> is simply <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="go2draft-generics-overview.html" class="btn btn-neutral float-left" title="Generics — Problem Overview" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>