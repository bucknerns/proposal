

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Proposal: Alias declarations for Go &mdash; Go Design Proposal  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Proposal: Go Heap Dump Viewer" href="16410-heap-viewer.html" />
    <link rel="prev" title="Proposal: Ignore tags in struct type conversions" href="16085-conversions-ignore-tags.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Go Design Proposal
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="11502-securitypolicy.html">Proposal: Security Policy for Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="11970-decentralized-gc.html">Proposal: Decentralized GC coordination</a></li>
<li class="toctree-l1"><a class="reference internal" href="12166-subtests.html">Proposal: testing: programmatic sub-test and sub-benchmark support</a></li>
<li class="toctree-l1"><a class="reference internal" href="12302-release-proposal.html">Proposal: A minimal release process for Go repositories</a></li>
<li class="toctree-l1"><a class="reference internal" href="12416-cgo-pointers.html">Proposal: Rules for passing pointers between Go and C</a></li>
<li class="toctree-l1"><a class="reference internal" href="12750-localization.html">Proposal: Localization support in Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="12800-sweep-free-alloc.html">Proposal: Dense mark bits and sweep-free allocation</a></li>
<li class="toctree-l1"><a class="reference internal" href="12914-monotonic.html">Proposal: Monotonic Elapsed Time Measurements in Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="12914-monotonic.html#appendix-time-now-usage">Appendix: time.Now usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="13073-code-of-conduct.html">Proposal: A Code of Conduct for the Go community</a></li>
<li class="toctree-l1"><a class="reference internal" href="13432-mobile-audio.html">Proposal: Audio for Mobile</a></li>
<li class="toctree-l1"><a class="reference internal" href="13504-natural-xml.html">Proposal: Natural XML</a></li>
<li class="toctree-l1"><a class="reference internal" href="14313-benchmark-format.html">Proposal: Go Benchmark Data Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="14386-zip-package-archives.html">Proposal: Zip-based Go package archives</a></li>
<li class="toctree-l1"><a class="reference internal" href="14951-soft-heap-limit.html">Proposal: Separate soft and hard heap size goal</a></li>
<li class="toctree-l1"><a class="reference internal" href="15292-generics.html">Proposal: Go should have generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="16085-conversions-ignore-tags.html">Proposal: Ignore tags in struct type conversions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Proposal: Alias declarations for Go</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#abstract">Abstract</a></li>
<li class="toctree-l2"><a class="reference internal" href="#motivation">1. Motivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#alias-declarations">2. Alias declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#notation">3. Notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#semantics-and-rules">3. Semantics and rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#impact-on-other-libraries-and-tools">4. Impact on other libraries and tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implementation">5. Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#other-use-cases">6. Other use cases</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#appendix">Appendix</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#a1-syntax-changes">A1. Syntax changes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#a2-alternatives-to-this-proposal">A2. Alternatives to this proposal</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="16410-heap-viewer.html">Proposal: Go Heap Dump Viewer</a></li>
<li class="toctree-l1"><a class="reference internal" href="16704-cidr-notation-no-proxy.html">Proposal: Add support for CIDR notation in no_proxy variable</a></li>
<li class="toctree-l1"><a class="reference internal" href="17280-profile-labels.html">Proposal: Support for pprof profiler labels</a></li>
<li class="toctree-l1"><a class="reference internal" href="17503-eliminate-rescan.html">Proposal: Eliminate STW stack re-scanning</a></li>
<li class="toctree-l1"><a class="reference internal" href="17505-concurrent-rescan.html">Proposal: Concurrent stack re-scanning</a></li>
<li class="toctree-l1"><a class="reference internal" href="18130-type-alias.html">Proposal: Type Aliases</a></li>
<li class="toctree-l1"><a class="reference internal" href="18802-percpu-sharded.html">Proposal: percpu.Sharded, an API for reducing cache contention</a></li>
<li class="toctree-l1"><a class="reference internal" href="18802-percpu-sharded.html#discussion">Discussion</a></li>
<li class="toctree-l1"><a class="reference internal" href="18802-percpu-sharded.html#backwards-compatibility">Backwards compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="19113-signed-shift-counts.html">Proposal: Permit Signed Integers as Shift Counts for Go 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="19308-number-literals.html">Proposal: Go 2 Number Literal Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html">Proposal: Mid-stack inlining in the Go compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#abstract">Abstract</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#background">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#proposal">Proposal</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#rationale">Rationale</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#compatibility">Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#implementation">Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#prerequisite-changes">Prerequisite Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#preliminary-results">Preliminary Results</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#open-issues">Open issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="19480-xml-stream.html">Proposal: XML Stream</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html">Proposal: emit DWARF inlining info in the Go compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#abstract">Abstract</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#background">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#example">Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#how-the-generated-dwarf-should-look">How the generated DWARF should look</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#outline-of-proposed-changes">Outline of proposed changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#compatibility">Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#implementation">Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#prerequisite-changes">Prerequisite Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#preliminary-results">Preliminary Results</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#open-issues">Open issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="24301-versioned-go.html">Proposal: Versioned Go Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="24543-non-cooperative-preemption.html">Proposal: Non-cooperative goroutine preemption</a></li>
<li class="toctree-l1"><a class="reference internal" href="25530-sumdb.html">Proposal: Secure the Public Go Module Ecosystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="25719-go15vendor.html">Go 1.5 Vendor Experiment</a></li>
<li class="toctree-l1"><a class="reference internal" href="26160-dns-based-vanity-imports.html">Proposal: DNS Based Vanity Imports</a></li>
<li class="toctree-l1"><a class="reference internal" href="26756-rawxml-token.html">Proposal: Raw XML Token</a></li>
<li class="toctree-l1"><a class="reference internal" href="26903-simplify-mark-termination.html">Proposal: Simplify mark termination and eliminate mark 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="27539-internal-abi.html">Proposal: Create an undefined internal calling convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="2775-binary-only-packages.html">Proposal: Binary-Only Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="27935-unbounded-queue-package.html">Proposal: Built in support for high performance unbounded queue</a></li>
<li class="toctree-l1"><a class="reference internal" href="28221-go2-transitions.html">Proposal: Go 2 transition</a></li>
<li class="toctree-l1"><a class="reference internal" href="2981-go-test-json.html">Proposal: <code class="docutils literal notranslate"><span class="pre">-json</span></code> flag in <code class="docutils literal notranslate"><span class="pre">go</span> <span class="pre">test</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="29934-error-values.html">Proposal: Go 2 Error Inspection</a></li>
<li class="toctree-l1"><a class="reference internal" href="30333-smarter-scavenging.html">Proposal: Smarter Scavenging</a></li>
<li class="toctree-l1"><a class="reference internal" href="30411-env.html">Proposal: <code class="docutils literal notranslate"><span class="pre">go</span></code> command configuration file</a></li>
<li class="toctree-l1"><a class="reference internal" href="32437-try-builtin.html">Proposal: A built-in Go error check function, <code class="docutils literal notranslate"><span class="pre">try</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="33974-add-public-lockedfile-pkg.html">Proposal: make the internal lockedfile package public</a></li>
<li class="toctree-l1"><a class="reference internal" href="34481-opencoded-defers.html">Proposal: Low-cost defers through inline code, and extra funcdata to manage the panic case</a></li>
<li class="toctree-l1"><a class="reference internal" href="35112-scaling-the-page-allocator.html">Proposal: Scaling the Go page allocator</a></li>
<li class="toctree-l1"><a class="reference internal" href="36460-lazy-module-loading.html">Proposal: Lazy Module Loading</a></li>
<li class="toctree-l1"><a class="reference internal" href="36606-64-bit-field-alignment.html">Proposal: Make 64-bit fields be 64-bit aligned on 32-bit systems, add //go:packed, //go:align directives</a></li>
<li class="toctree-l1"><a class="reference internal" href="37112-unstable-runtime-metrics.html">Proposal: API for unstable runtime metrics</a></li>
<li class="toctree-l1"><a class="reference internal" href="37720-gopls-workspaces.html">Proposal: Multi-project gopls workspaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="4899-testing-helper.html">Proposal: testing: better support test helper functions with TB.Helper</a></li>
<li class="toctree-l1"><a class="reference internal" href="6282-table-data.html">Proposal: Multi-dimensional slices</a></li>
<li class="toctree-l1"><a class="reference internal" href="6977-overlapping-interfaces.html">Proposal: Permit embedding of interfaces with overlapping method sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="TEMPLATE.html">Proposal: [Title]</a></li>
<li class="toctree-l1"><a class="reference internal" href="cryptography-principles.html">Cryptography Principles</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft.html">Go 2 Draft Designs</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-contracts.html">Contracts — Draft Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-handling.html">Error Handling — Draft Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-handling-overview.html">Error Handling — Problem Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-inspection.html">Error Inspection — Draft Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-printing.html">Error Printing — Draft Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-values-overview.html">Error Values — Problem Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-generics-overview.html">Generics — Problem Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-type-parameters.html">Type Parameters - Draft Design</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Go Design Proposal</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Proposal: Alias declarations for Go</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/16339-alias-decls.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="proposal-alias-declarations-for-go">
<h1>Proposal: Alias declarations for Go<a class="headerlink" href="#proposal-alias-declarations-for-go" title="Permalink to this headline">¶</a></h1>
<p>Authors: Robert Griesemer &amp; Rob Pike.
Last updated: July 18, 2016</p>
<p>Discussion at https://golang.org/issue/16339.</p>
<div class="section" id="abstract">
<h2>Abstract<a class="headerlink" href="#abstract" title="Permalink to this headline">¶</a></h2>
<p>We propose to add alias declarations to the Go language. An alias declaration
introduces an alternative name for an object (type, function, etc.) declared
elsewhere. Alias declarations simplify splitting up packages because clients
can be updated incrementally, which is crucial for large-scale refactoring.
They also facilitate multi-package “components” where a top-level package
is used to provide a component’s public API with aliases referring to the
componenent’s internal packages. Alias declarations are
important for the Go implementation of the “import public” feature of Google
protocol buffers. They also provide a more fine-grained and explicit
alternative to “dot-imports”.</p>
</div>
<div class="section" id="motivation">
<h2>1. Motivation<a class="headerlink" href="#motivation" title="Permalink to this headline">¶</a></h2>
<p>Suppose we have a library package L and a client package C that depends on L.
During refactoring of code, some functionality of L is moved into a new
package L1, which in turn may require updates to C. If there are multiple
clients C1, C2, …, many of these clients may need to be updated
simultaneously for the system to build. Failing to do so will lead to build
breakages in a continuous build environment.</p>
<p>This is a real issue in large-scale systems such as we find at Google because
the number of dependencies can go into the hundreds if not thousands. Client
packages may be under control of different teams and evolve at different
speeds. Updating a large number of client packages simultaneously may be close
to impossible. This is an effective barrier to system evolution and maintenance.</p>
<p>If client packages can be updated incrementally, one package (or a small batch
of packages) at a time, the problem is avoided. For instance, after moving
functionality from L into L1, if it is possible for clients to continue to
refer to L in order to get the features in L1, clients don’t need to be
updated at once.</p>
<p>Go packages export constants, types (incl. associated methods), variables, and
functions. If a constant X is moved from a package L to L1, L may trivially
depend on L1 and re-export X with the same value as in L1.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">package</span> <span class="n">L</span>
<span class="kn">import</span> <span class="s2">&quot;L1&quot;</span>
<span class="n">const</span> <span class="n">X</span> <span class="o">=</span> <span class="n">L1</span><span class="o">.</span><span class="n">X</span>  <span class="o">//</span> <span class="n">X</span> <span class="ow">is</span> <span class="n">effectively</span> <span class="n">an</span> <span class="n">alias</span> <span class="k">for</span> <span class="n">L1</span><span class="o">.</span><span class="n">X</span>
</pre></div>
</div>
<p>Client packages may use L1.X or continue to refer to L.X and still build
without issues. A similar work-around exists for functions: Package L may
provide wrapper functions that simply invoke the corresponding functions
in L1. Alternatively, L may define variables of function type which are
initialized to the functions which moved from L to L1:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>package L
import &quot;L1&quot;
var F = L1.F  // F is a function variable referring to L1.F
func G(args…) Result { return L1.G(args…) }
</pre></div>
</div>
<p>It gets more complicated for variables: An incremental approach still exists
but it requires multiple steps. Let’s assume we want to move a variable V
from L to L1. In a first step, we declare a pointer variable Vptr in L1
pointing to L.V:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">package</span> <span class="n">L1</span>
<span class="kn">import</span> <span class="s2">&quot;L&quot;</span>
<span class="n">var</span> <span class="n">Vptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">L</span><span class="o">.</span><span class="n">V</span>
</pre></div>
</div>
<p>Now we can incrementally update clients referring to L.V such that they use
(*L1.Vptr) instead. This will give them full access to the same variable.
Once all references to L.V have been changed, L.V can move to L1; this step
doesn’t require any changes to clients of L1 (though it may require additional
internal changes in L and L1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">package</span> <span class="n">L1</span>
<span class="kn">import</span> <span class="s2">&quot;L&quot;</span>
<span class="n">var</span> <span class="n">Vptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">V</span>
<span class="n">var</span> <span class="n">V</span> <span class="n">T</span> <span class="o">=</span> <span class="o">...</span>
</pre></div>
</div>
<p>Finally, clients may be incrementally updated again to use L1.V directly after
which we can get rid of Vptr.</p>
<p>There is no work-around for types, nor is possible to define a named type T in
L1 and re-export it in L and have L.T mean the exact same type as L1.T.</p>
<p>Discussion: The multi-step approach to factor out exported variables requires
careful planning. For instance, if we want to move both a function F and a
variable V from L to L1, we cannot do so at the same time: The forwarder F
left in L requires L to import L1, and the pointer variable Vptr introduced
in L1 requires L1 to import L. The consequence would be a forbidden import
cycle. Furthermore, if a moved function F requires access to a yet unmoved V,
it would also cause a cyclic import. Thus, variables will have to be moved
first in such a scenario, requiring multiple steps to enable incremental
client updates, followed by another round of incremental updates to move
everything else.</p>
</div>
<div class="section" id="alias-declarations">
<h2>2. Alias declarations<a class="headerlink" href="#alias-declarations" title="Permalink to this headline">¶</a></h2>
<p>To address these issues with a single, unified mechanism, we propose a new
form of declaration in Go, called an alias declaration. As the name suggests,
an alias declaration introduces an alternative name for a given object that
has been declared elsewhere, in a different package.</p>
<p>An alias declaration in package L makes it possible to move the original
declaration of an object X (a constant, type, variable, or function) from
package L to L1, while continuing to define and export the name X in L.
Both L.X and L1.X denote the exact same object (L1.X).</p>
<p>Note that the two predeclared types byte and rune are aliases for the
predeclared types uint8 and int32. Alias declarations will enable users
to define their own aliases, similar to byte and rune.</p>
</div>
<div class="section" id="notation">
<h2>3. Notation<a class="headerlink" href="#notation" title="Permalink to this headline">¶</a></h2>
<p>The existing declaration syntax for constants effectively permits
constant aliases:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">C</span> <span class="o">=</span> <span class="n">L1</span><span class="o">.</span><span class="n">C</span>  <span class="o">//</span> <span class="n">C</span> <span class="ow">is</span> <span class="n">effectively</span> <span class="n">an</span> <span class="n">alias</span> <span class="k">for</span> <span class="n">L1</span><span class="o">.</span><span class="n">C</span>
</pre></div>
</div>
<p>Ideally we would like to extend this syntax to other declarations
and give it alias semantics:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">T</span> <span class="o">=</span> <span class="n">L1</span><span class="o">.</span><span class="n">T</span>  <span class="o">//</span> <span class="n">T</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">alias</span> <span class="k">for</span> <span class="n">L1</span><span class="o">.</span><span class="n">T</span>
<span class="n">func</span> <span class="n">F</span> <span class="o">=</span> <span class="n">L1</span><span class="o">.</span><span class="n">F</span>  <span class="o">//</span> <span class="n">F</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">alias</span> <span class="k">for</span> <span class="n">L1</span><span class="o">.</span><span class="n">F</span>
</pre></div>
</div>
<p>Unfortunately, this notation breaks down for variables, because it already
has a given (and different) meaning in variable declarations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">V</span> <span class="o">=</span> <span class="n">L1</span><span class="o">.</span><span class="n">V</span>  <span class="o">//</span> <span class="n">V</span> <span class="ow">is</span> <span class="n">initialized</span> <span class="n">to</span> <span class="n">L1</span><span class="o">.</span><span class="n">V</span>
</pre></div>
</div>
<p>Instead of “=” we propose the new alias operator “=&gt;” to solve the
syntactic issue:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">C</span> <span class="o">=&gt;</span> <span class="n">L1</span><span class="o">.</span><span class="n">C</span>  <span class="o">//</span> <span class="k">for</span> <span class="n">regularity</span> <span class="n">only</span><span class="p">,</span> <span class="n">same</span> <span class="n">effect</span> <span class="k">as</span> <span class="n">const</span> <span class="n">C</span> <span class="o">=</span> <span class="n">L1</span><span class="o">.</span><span class="n">C</span>
<span class="nb">type</span>  <span class="n">T</span> <span class="o">=&gt;</span> <span class="n">L1</span><span class="o">.</span><span class="n">T</span>  <span class="o">//</span> <span class="n">T</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">alias</span> <span class="k">for</span> <span class="nb">type</span> <span class="n">L1</span><span class="o">.</span><span class="n">T</span>
<span class="n">var</span>   <span class="n">V</span> <span class="o">=&gt;</span> <span class="n">L1</span><span class="o">.</span><span class="n">V</span>  <span class="o">//</span> <span class="n">V</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">alias</span> <span class="k">for</span> <span class="n">variable</span> <span class="n">L1</span><span class="o">.</span><span class="n">V</span>
<span class="n">func</span>  <span class="n">F</span> <span class="o">=&gt;</span> <span class="n">L1</span><span class="o">.</span><span class="n">F</span>  <span class="o">//</span> <span class="n">F</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">alias</span> <span class="k">for</span> <span class="n">function</span> <span class="n">L1</span><span class="o">.</span><span class="n">F</span>
</pre></div>
</div>
<p>With that, a general alias specification is of the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">AliasSpec</span> <span class="o">=</span> <span class="n">identifier</span> <span class="s2">&quot;=&gt;&quot;</span> <span class="n">PackageName</span> <span class="s2">&quot;.&quot;</span> <span class="n">identifier</span> <span class="o">.</span>
</pre></div>
</div>
<p>Per the discussion at https://golang.org/issue/16339, and based on feedback
from adonovan&#64;golang, to avoid abuse, alias declarations may refer to imported
and package-qualified objects only (no aliases to local objects or
“dot-imports”).
Furthermore, they are only permitted at the top (package) level,
not inside a function.</p>
<p>These restriction do not hamper the utility of aliases for the intended
use cases. Both restrictions can be trivially lifted later if so desired;
we start with them out of an abundance of caution.</p>
<p>An alias declaration may refer to another alias.</p>
<p>The LHS identifier (C, T, V, and F in the examples above) in an alias
declaration is called the <em>alias name</em> (or <em>alias</em> for short). For each alias
name there is an <em>original name</em> (or <em>original</em> for short), which is the
non-alias name declared for a given object (e.g., L1.T in the example above).</p>
<p>Some more examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="s2">&quot;oldp&quot;</span>

<span class="n">var</span> <span class="n">v</span> <span class="o">=&gt;</span> <span class="n">oldp</span><span class="o">.</span><span class="n">V</span>  <span class="o">//</span> <span class="n">local</span> <span class="n">alias</span><span class="p">,</span> <span class="ow">not</span> <span class="n">exported</span>

<span class="o">//</span> <span class="n">alias</span> <span class="n">declarations</span> <span class="n">may</span> <span class="n">be</span> <span class="n">grouped</span>
<span class="nb">type</span> <span class="p">(</span>
	<span class="n">T1</span> <span class="o">=&gt;</span> <span class="n">oldp</span><span class="o">.</span><span class="n">T1</span>  <span class="o">//</span> <span class="n">original</span> <span class="k">for</span> <span class="n">T1</span> <span class="ow">is</span> <span class="n">oldp</span><span class="o">.</span><span class="n">T1</span>
	<span class="n">T2</span> <span class="o">=&gt;</span> <span class="n">oldp</span><span class="o">.</span><span class="n">T2</span>  <span class="o">//</span> <span class="n">original</span> <span class="k">for</span> <span class="n">T2</span> <span class="ow">is</span> <span class="n">oldp</span><span class="o">.</span><span class="n">T2</span>
	<span class="n">T3</span>    <span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="n">byte</span>  <span class="o">//</span> <span class="n">regular</span> <span class="n">declaration</span> <span class="n">may</span> <span class="n">be</span> <span class="n">grouped</span> <span class="k">with</span> <span class="n">aliases</span>
<span class="p">)</span>

<span class="n">var</span> <span class="n">V2</span> <span class="n">T2</span>  <span class="o">//</span> <span class="n">same</span> <span class="n">effect</span> <span class="k">as</span><span class="p">:</span> <span class="n">var</span> <span class="n">V2</span> <span class="n">oldp</span><span class="o">.</span><span class="n">T2</span>

<span class="n">func</span> <span class="n">myF</span> <span class="o">=&gt;</span> <span class="n">oldp</span><span class="o">.</span><span class="n">F</span>  <span class="o">//</span> <span class="n">local</span> <span class="n">alias</span><span class="p">,</span> <span class="ow">not</span> <span class="n">exported</span>
<span class="n">func</span> <span class="n">G</span>   <span class="o">=&gt;</span> <span class="n">oldp</span><span class="o">.</span><span class="n">G</span>

<span class="nb">type</span> <span class="n">T</span> <span class="o">=&gt;</span> <span class="n">oldp</span><span class="o">.</span><span class="n">MuchTooLongATypeName</span>

<span class="n">func</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">x</span> <span class="o">:=</span> <span class="n">T</span><span class="p">{}</span>  <span class="o">//</span> <span class="n">same</span> <span class="n">effect</span> <span class="k">as</span><span class="p">:</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">oldp</span><span class="o">.</span><span class="n">MuchTooLongATypeName</span><span class="p">{}</span>
	<span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The respective syntactic changes in the language spec are small and
concentrated. Each declaration specification (ConstSpec, TypeSpec, etc.)
gets a new alternative which is an alias specification (AliasSpec).
Grouping is possible as before, except for functions (as before).
See Appendix A1 for details.</p>
<p>The short variable declaration form (using “:=”) cannot be used to
declare an alias.</p>
<p>Discussion: Introducing a new operator (“=&gt;”) has the advantage of not
needing to introduce a new keyword (such as “alias”), which we can’t really
do without violating the Go 1 promise (though r&#64;golang and rsc&#64;golang observe
that it would be possible to recognize “alias” as a keyword at the package-
level only, when in const/type/var/func position, and as an identifier
otherwise, and probably not break existing code).</p>
<p>The token sequence “=” “&gt;” (or “==” “&gt;”) is not a valid sequence in a Go
program since “&gt;” is a binary operator that must be surrounded by operands,
and the left operand cannot end in “=” or “==”. Thus, it is safe to introduce
“=&gt;” as a new token sequence without invalidating existing programs.</p>
<p>As proposed, an alias declaration must specify what kind of object the alias
refers to (const, type, var, or func). We believe this is an advantage:
It makes it clear to a user what the alias denotes (as with existing
declarations). It also makes it possible to report an error at the location
of the alias declaration if the aliased object changes (e.g., from being a
constant to a variable) rather than only at where the alias is used.</p>
<p>On the other hand, mdempsky&#64;golang points out that using a keyword would
permit making changes in a package L1, say change a function F into a type F,
and not require a respective update of any alias declarations referring to
L1.F, which in turn might simplify refactoring. Specifically, one could
generalize import declarations so that they can be used to import and rename
specific objects. For instance:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>	<span class="kn">import</span> <span class="nn">Printf</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>	<span class="kn">import</span> <span class="nn">Printf</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span>
</pre></div>
</div>
<p>One might even permit the form</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>	<span class="kn">import</span> <span class="nn">context.Context</span>
</pre></div>
</div>
<p>as a shorthand for</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>	<span class="kn">import</span> <span class="nn">Context</span> <span class="n">context</span><span class="o">.</span><span class="n">Context</span>
</pre></div>
</div>
<p>analogously to the renaming feature available to imports already. One of the
issues to consider here is that imported packages end up in the file scope and
are only visible in one file. Furthermore, currently they cannot be
re-exported. It is crucial for aliases to be re-exportable. Thus alias imports
would need to end up in package scope. (It would be odd if they ended up in
file scope: the same alias may have to be imported in multiple files of the
same package, possibly with different names.)</p>
<p>The choice of token (“=&gt;”) is somewhat arbitrary, but both “A =&gt; B” and
“A -&gt; B” conjure up the image of a reference or forwarding from A to B.
The token “-&gt;” is also used in Unix directory listings for symbolic links,
where the lhs is another name (an alias) for the file mentioned on the RHS.</p>
<p>dneil&#64;golang and r&#64;golang observe that if “-&gt;” is written “in reverse” by
mistake, a declaration “var X -&gt; p.X” meant to be an alias declaration is
close to a regular variable declaration “var X &lt;-p.X” (with a missing “=”);
though it wouldn’t compile.</p>
<p>Many people expressed a preference for “=&gt;” over “-&gt;” on the tracking issue.
The argument is that “-&gt;” is more easily confused with a channel operation.
A few people would like to use “&#64;” (as in <em>&#64;lias</em>). For now we proceed with
“=&gt;” - the token is trivially changed down the road if there is strong general
sentiment or a convincing argument for any other notation.</p>
</div>
<div class="section" id="semantics-and-rules">
<h2>3. Semantics and rules<a class="headerlink" href="#semantics-and-rules" title="Permalink to this headline">¶</a></h2>
<p>An alias declaration declares an alternative name, the alias, for a constant,
type, variable, or function, referred to by the RHS of the alias declaration.
The RHS must be a package-qualified identifier; it may itself be an alias, or
it may be the original name for the aliased object.</p>
<p>Alias cycles are impossible by construction since aliases must refer to fully
package-qualified (imported) objects and package import cycles are not
permitted.</p>
<p>An alias denotes the aliased object, and the effect of using an alias is
indistinguishable from the effect of using the original; the only visible
difference is the name.</p>
<p>An alias declaration may only appear at the top- (package-) level where it
is valid to have a keyword-based constant, type, variable, or function
declaration. Alias declarations may be grouped.</p>
<p>The same scope and export rules (capitalization for export) apply as for all
other identifiers at the top-level.</p>
<p>The scope of an alias identifier at the top-level is the package block
(as is the case for an identifier denoting a constant, type, variable,
or function).</p>
<p>An alias declaration may refer to unsafe.Pointer, but not to any of the unsafe
functions.</p>
<p>A package is considered “used” if any imported object of a package is used.
Consequently, declaring an alias referring to an object of an package marks
the package as used.</p>
<p>Discussion: The original proposal permitted aliases to any (even local)
objects and also to predeclared types in the Universe scope. Furthermore,
it permitted alias declarations inside functions. See the tracking issue
and earlier versions of this document for a more detailed discussion.</p>
</div>
<div class="section" id="impact-on-other-libraries-and-tools">
<h2>4. Impact on other libraries and tools<a class="headerlink" href="#impact-on-other-libraries-and-tools" title="Permalink to this headline">¶</a></h2>
<p>Alias declarations are a source-level and compile-time feature, with no
observable impact at run time. Thus, libraries and tools operating at the
source level or involved in type checking and compilation are expected to
need adjustments.</p>
<p>reflect package
The reflect package permits access to values and their types at run-time.
There’s no mechanism to make a new reflect.Value from a type name, only from
a reflect.Type. The predeclared aliases byte and rune are mapped to uint8 and
int32 already, and we would expect the same to be true for general aliases.
For instance:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s2">&quot;%T&quot;</span><span class="p">,</span> <span class="n">rune</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<p>prints the original type name int32, not rune. Thus, we expect no API or
semantic changes to package reflect.</p>
<p>go/* std lib packages
The packages under the go/* std library tree which deal with source code will
need to be adjusted. Specifically, the packages go/token, go/scanner, go/ast,
go/parser, go/doc, and go/printer will need the necessary API extensions and
changes to cope with the new syntax. These changes should be straightforward.</p>
<p>Package go/types will need to understand how to type-check alias declarations.
It may also require an extension to its API (to be explored).</p>
<p>We don’t expect any changes to the go/build package.</p>
<p>go doc
The go doc implementation will need to be adjusted: It relies on package go/doc
which now exposes alias declarations. Thus, godoc needs to have a meaningful
way to show those as well. This may be a simple extension of the existing
machinery to include alias declarations.</p>
<p>Other tools operating on source code
A variety of other tools operate or inspect source code such as go vet,
go lint, goimport, and others. What adjustments need to be made needs to be
decided on a case-by-case basis.</p>
</div>
<div class="section" id="implementation">
<h2>5. Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>There are many open questions that need to be answered by an implementation.
To mention a few of them:</p>
<p>Are aliases represented somehow as “first-class” citizens in a compiler and
go/types, or are they immediately “resolved” internally to the original names?
For go/types specifically, adonovan&#64;golang points out that a first-class
representation may have an impact on the go/types API and potentially affect
many tools. For instance, type switches assuming only the kinds of objects now
in existence in go/types would need to be extended to handle aliases, should
they show up in the public API. The go/types’ Info.Uses map, which currently
maps identifiers to objects, will require especial attention: Should it record
the alias to object references, or only the original names?</p>
<p>At first glance, since an alias is simply another name for an object, it would
seem that an implementation should resolve them immediately, making aliases
virtually invisible to the API (we may keep track of them internally only for
better error messages). On the other hand, they need to be exported and might
need to show up in go/types’ Info.Uses map (or some additional variant thereof)
so that tools such as guru have access to the alias names.</p>
<p>To be prototyped.</p>
</div>
<div class="section" id="other-use-cases">
<h2>6. Other use cases<a class="headerlink" href="#other-use-cases" title="Permalink to this headline">¶</a></h2>
<p>Alias declarations facilitate the construction of larger-scale libraries or
“components”. For organizational and size reasons it often makes sense to split
up a large library into several sub-packages. The exported API of a sub-package
is driven by internal requirements of the component and may be only remotely
related to its public API. Alias declarations make it possible to “pull out”
the relevant declarations from the various sub-packages and collect them in
a single top-level package that represents the component’s API.
The other packages can be organized in an “internal” sub-directory,
which makes them virtually inaccessible through the <code class="docutils literal notranslate"><span class="pre">go</span> <span class="pre">build</span></code> command (they
cannot be imported).</p>
<p>TODO(gri): Expand on use of alias declarations for protocol buffer’s
“import public” feature.</p>
<p>TODO(gri): Expand on use of alias declarations instead of “dot-imports”.</p>
</div>
</div>
<div class="section" id="appendix">
<h1>Appendix<a class="headerlink" href="#appendix" title="Permalink to this headline">¶</a></h1>
<div class="section" id="a1-syntax-changes">
<h2>A1. Syntax changes<a class="headerlink" href="#a1-syntax-changes" title="Permalink to this headline">¶</a></h2>
<p>The syntax changes necessary to accommodate alias declarations are limited
and concentrated. There is a new declaration specification called AliasSpec:</p>
<p><strong>AliasSpec = identifier “=&gt;” PackageName “.” identifier .</strong></p>
<p>An AliasSpec binds an identifier, the alias name, to the object (constant,
type, variable, or function) the alias refers to. The object must be specified
via a (possibly qualified) identifier. The aliased object must be a constant,
type, variable, or function, depending on whether the AliasSpec is within a
constant, type, variable, of function declaration.</p>
<p>Alias specifications may be used with any of the existing constant, type,
variable, or function declarations. The respective syntax productions are
extended as follows, with the extensions marked in bold:</p>
<p>ConstDecl = “const” ( ConstSpec | “(“ { ConstSpec “;” } “)” ) .
ConstSpec = IdentifierList [ [ Type ] “=” ExprList ] <strong>| AliasSpec</strong> .</p>
<p>TypeDecl  = “type” ( TypeSpec | “(“ { TypeSpec “;” } “)” ) .
TypeSpec  = identifier Type <strong>| AliasSpec</strong> .</p>
<p>VarDecl   = “var” ( VarSpec | “(“ { VarSpec “;” } “)” ) .
VarSpec   = IdentList ( Type [ “=” ExprList ] | “=” ExprList ) <strong>| AliasSpec</strong> .</p>
<p>FuncDecl  = “func” FunctionName ( Function | Signature ) <strong>| “func” AliasSpec</strong> .</p>
</div>
<div class="section" id="a2-alternatives-to-this-proposal">
<h2>A2. Alternatives to this proposal<a class="headerlink" href="#a2-alternatives-to-this-proposal" title="Permalink to this headline">¶</a></h2>
<p>For completeness, we mention several alternatives.</p>
<ol class="simple">
<li><p>Do nothing (wait for Go 2). The easiest solution, but it does not address
the problem.</p></li>
<li><p>Permit alias declarations for types only, use the existing work-arounds
otherwise. This would be a “minimal” solution for the problem. It would
require the use of work-arounds for all other objects (constants, variables,
and functions). Except for variables, those work-arounds would not be too
onerous. Finally, this would not require the introduction of a new operator
since “=” could be used.</p></li>
<li><p>Permit re-export of imports, or generalize imports. One might come up with
a notation to re-export all objects of an imported package wholesale,
accessible under the importing package name. Such a mechanism would address
the incremental refactoring problem and also permit the easy construction of
some sort of “super-package” (or component), the API of which would be the sum
of all the re-exported package APIs. This would be an “all-or-nothing” approach
that would not permit control over which objects are re-exported or under what
name. Alternatively, a generalized import scheme (discussed earlier in this
document) may provide a more fine-grained solution.</p></li>
</ol>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="16410-heap-viewer.html" class="btn btn-neutral float-right" title="Proposal: Go Heap Dump Viewer" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="16085-conversions-ignore-tags.html" class="btn btn-neutral float-left" title="Proposal: Ignore tags in struct type conversions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>