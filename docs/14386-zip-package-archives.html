

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Proposal: Zip-based Go package archives &mdash; Go Design Proposal  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Proposal: Separate soft and hard heap size goal" href="14951-soft-heap-limit.html" />
    <link rel="prev" title="Proposal: Go Benchmark Data Format" href="14313-benchmark-format.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Go Design Proposal
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="11502-securitypolicy.html">Proposal: Security Policy for Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="11970-decentralized-gc.html">Proposal: Decentralized GC coordination</a></li>
<li class="toctree-l1"><a class="reference internal" href="12166-subtests.html">Proposal: testing: programmatic sub-test and sub-benchmark support</a></li>
<li class="toctree-l1"><a class="reference internal" href="12302-release-proposal.html">Proposal: A minimal release process for Go repositories</a></li>
<li class="toctree-l1"><a class="reference internal" href="12416-cgo-pointers.html">Proposal: Rules for passing pointers between Go and C</a></li>
<li class="toctree-l1"><a class="reference internal" href="12750-localization.html">Proposal: Localization support in Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="12800-sweep-free-alloc.html">Proposal: Dense mark bits and sweep-free allocation</a></li>
<li class="toctree-l1"><a class="reference internal" href="12914-monotonic.html">Proposal: Monotonic Elapsed Time Measurements in Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="12914-monotonic.html#appendix-time-now-usage">Appendix: time.Now usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="13073-code-of-conduct.html">Proposal: A Code of Conduct for the Go community</a></li>
<li class="toctree-l1"><a class="reference internal" href="13432-mobile-audio.html">Proposal: Audio for Mobile</a></li>
<li class="toctree-l1"><a class="reference internal" href="13504-natural-xml.html">Proposal: Natural XML</a></li>
<li class="toctree-l1"><a class="reference internal" href="14313-benchmark-format.html">Proposal: Go Benchmark Data Format</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Proposal: Zip-based Go package archives</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#abstract">Abstract</a></li>
<li class="toctree-l2"><a class="reference internal" href="#background">Background</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#go-object-files-and-package-archives">Go object files and package archives</a></li>
<li class="toctree-l3"><a class="reference internal" href="#archive-file-formats">Archive file formats</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#proposal">Proposal</a></li>
<li class="toctree-l2"><a class="reference internal" href="#rationale">Rationale</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#zip-format">Zip format</a></li>
<li class="toctree-l3"><a class="reference internal" href="#file-names">File names</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compression">Compression</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#compatibility">Compatibility</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implementation">Implementation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="14951-soft-heap-limit.html">Proposal: Separate soft and hard heap size goal</a></li>
<li class="toctree-l1"><a class="reference internal" href="15292-generics.html">Proposal: Go should have generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="16085-conversions-ignore-tags.html">Proposal: Ignore tags in struct type conversions</a></li>
<li class="toctree-l1"><a class="reference internal" href="16339-alias-decls.html">Proposal: Alias declarations for Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="16339-alias-decls.html#appendix">Appendix</a></li>
<li class="toctree-l1"><a class="reference internal" href="16410-heap-viewer.html">Proposal: Go Heap Dump Viewer</a></li>
<li class="toctree-l1"><a class="reference internal" href="16704-cidr-notation-no-proxy.html">Proposal: Add support for CIDR notation in no_proxy variable</a></li>
<li class="toctree-l1"><a class="reference internal" href="17280-profile-labels.html">Proposal: Support for pprof profiler labels</a></li>
<li class="toctree-l1"><a class="reference internal" href="17503-eliminate-rescan.html">Proposal: Eliminate STW stack re-scanning</a></li>
<li class="toctree-l1"><a class="reference internal" href="17505-concurrent-rescan.html">Proposal: Concurrent stack re-scanning</a></li>
<li class="toctree-l1"><a class="reference internal" href="18130-type-alias.html">Proposal: Type Aliases</a></li>
<li class="toctree-l1"><a class="reference internal" href="18802-percpu-sharded.html">Proposal: percpu.Sharded, an API for reducing cache contention</a></li>
<li class="toctree-l1"><a class="reference internal" href="18802-percpu-sharded.html#discussion">Discussion</a></li>
<li class="toctree-l1"><a class="reference internal" href="18802-percpu-sharded.html#backwards-compatibility">Backwards compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="19113-signed-shift-counts.html">Proposal: Permit Signed Integers as Shift Counts for Go 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="19308-number-literals.html">Proposal: Go 2 Number Literal Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html">Proposal: Mid-stack inlining in the Go compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#abstract">Abstract</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#background">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#proposal">Proposal</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#rationale">Rationale</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#compatibility">Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#implementation">Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#prerequisite-changes">Prerequisite Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#preliminary-results">Preliminary Results</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#open-issues">Open issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="19480-xml-stream.html">Proposal: XML Stream</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html">Proposal: emit DWARF inlining info in the Go compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#abstract">Abstract</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#background">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#example">Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#how-the-generated-dwarf-should-look">How the generated DWARF should look</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#outline-of-proposed-changes">Outline of proposed changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#compatibility">Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#implementation">Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#prerequisite-changes">Prerequisite Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#preliminary-results">Preliminary Results</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#open-issues">Open issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="24301-versioned-go.html">Proposal: Versioned Go Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="24543-non-cooperative-preemption.html">Proposal: Non-cooperative goroutine preemption</a></li>
<li class="toctree-l1"><a class="reference internal" href="25530-sumdb.html">Proposal: Secure the Public Go Module Ecosystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="25719-go15vendor.html">Go 1.5 Vendor Experiment</a></li>
<li class="toctree-l1"><a class="reference internal" href="26160-dns-based-vanity-imports.html">Proposal: DNS Based Vanity Imports</a></li>
<li class="toctree-l1"><a class="reference internal" href="26756-rawxml-token.html">Proposal: Raw XML Token</a></li>
<li class="toctree-l1"><a class="reference internal" href="26903-simplify-mark-termination.html">Proposal: Simplify mark termination and eliminate mark 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="27539-internal-abi.html">Proposal: Create an undefined internal calling convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="2775-binary-only-packages.html">Proposal: Binary-Only Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="27935-unbounded-queue-package.html">Proposal: Built in support for high performance unbounded queue</a></li>
<li class="toctree-l1"><a class="reference internal" href="28221-go2-transitions.html">Proposal: Go 2 transition</a></li>
<li class="toctree-l1"><a class="reference internal" href="2981-go-test-json.html">Proposal: <code class="docutils literal notranslate"><span class="pre">-json</span></code> flag in <code class="docutils literal notranslate"><span class="pre">go</span> <span class="pre">test</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="29934-error-values.html">Proposal: Go 2 Error Inspection</a></li>
<li class="toctree-l1"><a class="reference internal" href="30333-smarter-scavenging.html">Proposal: Smarter Scavenging</a></li>
<li class="toctree-l1"><a class="reference internal" href="30411-env.html">Proposal: <code class="docutils literal notranslate"><span class="pre">go</span></code> command configuration file</a></li>
<li class="toctree-l1"><a class="reference internal" href="32437-try-builtin.html">Proposal: A built-in Go error check function, <code class="docutils literal notranslate"><span class="pre">try</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="33974-add-public-lockedfile-pkg.html">Proposal: make the internal lockedfile package public</a></li>
<li class="toctree-l1"><a class="reference internal" href="34481-opencoded-defers.html">Proposal: Low-cost defers through inline code, and extra funcdata to manage the panic case</a></li>
<li class="toctree-l1"><a class="reference internal" href="35112-scaling-the-page-allocator.html">Proposal: Scaling the Go page allocator</a></li>
<li class="toctree-l1"><a class="reference internal" href="36460-lazy-module-loading.html">Proposal: Lazy Module Loading</a></li>
<li class="toctree-l1"><a class="reference internal" href="36606-64-bit-field-alignment.html">Proposal: Make 64-bit fields be 64-bit aligned on 32-bit systems, add //go:packed, //go:align directives</a></li>
<li class="toctree-l1"><a class="reference internal" href="37112-unstable-runtime-metrics.html">Proposal: API for unstable runtime metrics</a></li>
<li class="toctree-l1"><a class="reference internal" href="37720-gopls-workspaces.html">Proposal: Multi-project gopls workspaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="4899-testing-helper.html">Proposal: testing: better support test helper functions with TB.Helper</a></li>
<li class="toctree-l1"><a class="reference internal" href="6282-table-data.html">Proposal: Multi-dimensional slices</a></li>
<li class="toctree-l1"><a class="reference internal" href="6977-overlapping-interfaces.html">Proposal: Permit embedding of interfaces with overlapping method sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="TEMPLATE.html">Proposal: [Title]</a></li>
<li class="toctree-l1"><a class="reference internal" href="cryptography-principles.html">Cryptography Principles</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft.html">Go 2 Draft Designs</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-contracts.html">Contracts — Draft Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-handling.html">Error Handling — Draft Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-handling-overview.html">Error Handling — Problem Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-inspection.html">Error Inspection — Draft Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-printing.html">Error Printing — Draft Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-values-overview.html">Error Values — Problem Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-generics-overview.html">Generics — Problem Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-type-parameters.html">Type Parameters - Draft Design</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Go Design Proposal</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Proposal: Zip-based Go package archives</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/14386-zip-package-archives.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="proposal-zip-based-go-package-archives">
<h1>Proposal: Zip-based Go package archives<a class="headerlink" href="#proposal-zip-based-go-package-archives" title="Permalink to this headline">¶</a></h1>
<p>Author: Russ Cox</p>
<p>Last updated: February 2016</p>
<p>Discussion at https://golang.org/issue/14386.</p>
<div class="section" id="abstract">
<h2>Abstract<a class="headerlink" href="#abstract" title="Permalink to this headline">¶</a></h2>
<p>Go package archives (the <code class="docutils literal notranslate"><span class="pre">*.a</span></code> files manipulated by <code class="docutils literal notranslate"><span class="pre">go</span> <span class="pre">tool</span> <span class="pre">pack</span></code>) use the old Unix ar archive format.</p>
<p>I propose to change both Go package archives and Go object files to use the more standard zip archive format.
In contrast to ar archives, zip archives admit efficient random access to individual files within the archive
and also allow decisions about compression on a per-file basis.
The result for Go will be cleaner access to the parts of a package archive
and the ability later to add compression of individual parts
as appropriate.</p>
</div>
<div class="section" id="background">
<h2>Background<a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h2>
<div class="section" id="go-object-files-and-package-archives">
<h3>Go object files and package archives<a class="headerlink" href="#go-object-files-and-package-archives" title="Permalink to this headline">¶</a></h3>
<p>The Go toolchain stores compiled packages in archives
written in the Unix ar format used by traditional C toolchains.</p>
<p>Before continuing, two notes on terminology:</p>
<ul class="simple">
<li><p>An archive (a <code class="docutils literal notranslate"><span class="pre">*.a</span></code> file), such as an ar or zip file, is a file that contains other files.
To avoid confusion, this design document uses the term <em>archive</em>
for the archive file itself and reserves the term <em>file</em> exclusively
for other kinds of files, including the files inside the archive.</p></li>
<li><p>An <em>object file</em> (a <code class="docutils literal notranslate"><span class="pre">*.o</span></code> file) holds machine code corresponding to a source file;
the linker merges multiple object files into a final executable.
Examples of object files include the ELF, Mach-O, and PE
object files used by Linux, OS X, and Windows systems, respectively.
We refer to these as <em>system object files</em>.
Go uses its own object file format, which we refer to as <em>Go object files</em>;
that format is unchanged by this proposal.</p></li>
</ul>
<p>In a traditional C toolchain, an archive contains a file
named <code class="docutils literal notranslate"><span class="pre">__.SYMDEF</span></code> and then one or more object files (<code class="docutils literal notranslate"><span class="pre">.o</span></code> files)
containing compiled code; each object file corresponds to a different C or assembly source file.
The <code class="docutils literal notranslate"><span class="pre">__.SYMDEF</span></code> file is a symbol index a mapping from symbol name (such as <code class="docutils literal notranslate"><span class="pre">printf</span></code>)
to the specific object file containing that symbol (such as <code class="docutils literal notranslate"><span class="pre">print.o</span></code>).
A traditional C linker reads the symbol index to learn which of the
object files it needs to read from the archive; it can completely ignore
the others.</p>
<p>Go has diverged over time from the C toolchain way of using ar archives.
A Go package archive contains
package metadata in a file named <code class="docutils literal notranslate"><span class="pre">__.PKGDEF</span></code>,
one or more Go object files,
and zero or more system object files.
The Go object files are generated by the compiler
(one for all the Go source code in the package)
and by the assembler
(one for each assembly source file).
The system object files are generated by the system C compiler
(one for each <code class="docutils literal notranslate"><span class="pre">*.c</span></code> file in the package directory, plus a few for
C source files generated by cgo),
or (less commonly) are direct copies of <code class="docutils literal notranslate"><span class="pre">*.syso</span></code> files in the package source directory.
Because the Go linker does dead code elimination at a symbol level rather than
at the object file level, a traditional C symbol index is not useful
and not included in the Go package archive.</p>
<p>Long before Go 1, the Go compiler read a single Go source file
and wrote a single Go object file, much like a C compiler.
Each object file contained a fragment of package metadata
contributed by that file.
After running the compiler separately on each Go source file
in a package, the build system (<code class="docutils literal notranslate"><span class="pre">make</span></code>) invoked the archiver
(<code class="docutils literal notranslate"><span class="pre">6ar</span></code>, even on non-amd64 systems) to create an archive
containing all the object files.
As part of creating the archive, the archiver copied and merged
the metadata fragments from the many Go object files into
the single <code class="docutils literal notranslate"><span class="pre">__.PKGDEF</span></code> file.
This had the effect of storing the package metdata in the archive twice,
although the different copies ended up being read by different tools.
The copy in <code class="docutils literal notranslate"><span class="pre">__.PKGDEF</span></code> was read by later compilations importing
the package, and the fragmented copy spread across the Go object files
was read by the linker (which needed to read the object files anyway)
and used to detect version skew (a common problem due to the
use of per-directory makefiles).</p>
<p>By the time of Go 1, the Go compiler read all the Go source files for a package
together and wrote a single Go object file.
As before, that object file contained (now complete) package metadata,
and the archiver (now <code class="docutils literal notranslate"><span class="pre">go</span> <span class="pre">tool</span> <span class="pre">pack</span></code>) extracted that metadata into the
<code class="docutils literal notranslate"><span class="pre">__.PKGDEF</span></code> file.
The package still contained two copies of the package metadata.
Equally embarassing, most package archives
(those for Go packages with no assembly or C)
contained only a single <code class="docutils literal notranslate"><span class="pre">*.o</span></code> file, making the archiving step
a mostly unnecessary, trivial copy of the data through the file system.</p>
<p>Go 1.3 added a new <code class="docutils literal notranslate"><span class="pre">-pack</span></code> option to the Go compiler, directing it to
write a Go package archive containing <code class="docutils literal notranslate"><span class="pre">__.PKGDEF</span></code> and a <code class="docutils literal notranslate"><span class="pre">_go_.o</span></code> <em>without</em>
package metadata.
The go command used this option to create the initial package archive.
If the package had no assembly or C sources, there was no need for
any more work on the archive.
If the package did have assembly or C sources, those additional objects
needed to be appended to the archive, which could be done without
copying or rewriting the existing data.
Adopting <code class="docutils literal notranslate"><span class="pre">-pack</span></code> eliminated the duplicate copy of the package metadata,
and it also removed from the linker the job of detecting version skew,
since the package metadata was no longer in the object files the linker read.</p>
<p>The package metadata itself contains multiple sections used by different programs:
a unique build ID, needed by the go command;
the package name, needed by the compiler during import, but also needed by the linker;
detailed information about exported API, needed by the compiler during import;
and directives related to cgo, needed by the linker.
The entire metadata format is textual, with sections separated by <code class="docutils literal notranslate"><span class="pre">$$</span></code> lines.</p>
<p>Today, the situation is not much different from that of Go 1.3.
There are two main problems.</p>
<p>First, the individual package metadata sections are difficult to
access independently, because of the use of ad-hoc framing
inside the standard ar-format framing.
The inner framing is necessary in the current system in part
because metadata is still sometimes (when not using <code class="docutils literal notranslate"><span class="pre">-pack</span></code>)
stored in Go object files,
and those object files have no outer framing.</p>
<p>The line-oriented nature of the inner framing is a hurdle
for converting to a more compact binary format for the export data.</p>
<p>In a cleaner design, the different metadata sections would be stored
in different files in the Go package archive, eliminating the inner framing.
Cleaner separation would allow different tools to access only the
data they needed without needing to process unrelated data.
The go command, the compiler, and the linker all read <code class="docutils literal notranslate"><span class="pre">__.PKGDEF</span></code>,
but only the compiler needs all of it.</p>
<p>Distributed build systems can also benefit from splitting a package
archive into two halves, one used by the compiler to satisfy imports
and one used by the linker to generate the final executable.
The build system can then ship just the compiler-relevant
data to machines running the compiler and just the linker-relevant
data to machines running the linker.
In particular, the compiler does not need the Go object files,
and the linker does not need the Go export data;
both savings can be large.</p>
<p>Second, there is no simple way to enable compression for certain
files in the Go package archive.
It could be worthwhile to compress the Go export data
and Go object files, to save disk space as well as I/O time
(not just disk I/O but potentially also network I/O,
when using network file systems or distributed build systems).</p>
</div>
<div class="section" id="archive-file-formats">
<h3>Archive file formats<a class="headerlink" href="#archive-file-formats" title="Permalink to this headline">¶</a></h3>
<p>The ar archive format is simplistic: it begins with a distinguishing 8-byte header (<code class="docutils literal notranslate"><span class="pre">!&lt;arch&gt;\n</span></code>)
and then contains a sequence of files.
Each file has its own 60-byte header giving the file name (up to 16 bytes),
modification time, user and group IDs, permission bits, and size.
That header is followed by size bytes of data.
If size is odd, the data is followed by a single padding byte
so that file headers are always 16-bit aligned within the archive.
There is no table of contents: to find the names of all files in the archive,
one must read the entire archive (perhaps seeking past file content).
There is no compression.
Additional file entries can simply be appended to the end of an existing archive.</p>
<p>The zip archive format is much more capable, but only a little more complex.
A zip archive consists of a sequence of files followed by a table of contents.
Each file is stored as a header giving metadata such as the file name and data encoding,
followed by encoded file data,
followed by a file trailer.
The two standard encodings are “store” (raw, uncompressed)
and “deflate” (compressed using the same algorithm as zlib and gzip).
The table of contents at the end of the zip archive is a contiguous list of file headers
including offsets to the actual file data, making it efficient to access a particular
file in the archive.
As mentioned above, the zip format supports but does not require compression.
Appending to a zip archive is simple, although not as trivial as appending to an ar archive.
The table of contents must be saved, then new file entries are written
starting where the table of contents used to be, and then a new, expanded
table of contents is written.
Importantly, the existing files are left in place during this process,
making it about as efficient as adding to an ar format archive.</p>
</div>
</div>
<div class="section" id="proposal">
<h2>Proposal<a class="headerlink" href="#proposal" title="Permalink to this headline">¶</a></h2>
<p>To address the problems described above,
I propose to change Go package archives
to use the zip format instead of the current ar format,
at the same time separating the current <code class="docutils literal notranslate"><span class="pre">__.PKGDEF</span></code> metadata file
into multiple files according to what tools use process the data.</p>
<p>To avoid the need to preserve the current custom framing in
Go object files, I propose to stop writing Go object files at all,
except inside Go package archives.
The toolchain would still generate <code class="docutils literal notranslate"><span class="pre">*.o</span></code> files at the times it does today,
but the bytes inside those files would be identical to those inside
a Go package archive.</p>
<p>Although the bytes stored in the <code class="docutils literal notranslate"><span class="pre">*.a</span></code> and <code class="docutils literal notranslate"><span class="pre">*.o</span></code> files would be changing,
there would be no visible changes in the rest of the toolchain.
In particular, the file names would stay the same,
as would the commands used to manipulate and inspect archives.
The only differences would be in the encoding used within the file.</p>
<p>A Go package archive would be a zip-format archive containing the following files:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_go_</span><span class="o">/</span><span class="n">header</span>
<span class="n">_go_</span><span class="o">/</span><span class="n">export</span>
<span class="n">_go_</span><span class="o">/</span><span class="n">cgo</span>
<span class="n">_go_</span><span class="o">/*.</span><span class="n">obj</span>
<span class="n">_go_</span><span class="o">/*.</span><span class="n">sysobj</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">_go_/header</span></code> file is required, must be first in the archive, must be uncompressed,
and is of bounded size.</p>
<p>The header content is a sequence of at most four textual metadata lines. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">go</span> <span class="nb">object</span> <span class="n">darwin</span> <span class="n">amd64</span> <span class="n">devel</span> <span class="o">+</span><span class="mi">8</span><span class="n">b5a9bd</span> <span class="n">Tue</span> <span class="n">Feb</span> <span class="mi">2</span> <span class="mi">22</span><span class="p">:</span><span class="mi">46</span><span class="p">:</span><span class="mi">19</span> <span class="mi">2016</span> <span class="o">-</span><span class="mi">0500</span> <span class="n">X</span><span class="p">:</span><span class="n">none</span>
<span class="n">build</span> <span class="nb">id</span> <span class="s2">&quot;4fe8e8c8bc1ea2d7c03bd08cf3025e302ff33742&quot;</span>
<span class="n">main</span>
<span class="n">safe</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">go</span> <span class="pre">object</span></code> line must be first and identifies the operating system, architecture,
and toolchain version (including enabled experiments) of the package archive.
This line is today the first line of <code class="docutils literal notranslate"><span class="pre">__.PKGDEF</span></code>, and its uses remain the same:
the compiler and linker both refuse to use package archives with an unexpected
<code class="docutils literal notranslate"><span class="pre">go</span> <span class="pre">object</span></code> line.</p>
<p>The remaining lines are optional, but whichever ones are present must appear
in the order given here.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">build</span> <span class="pre">id</span></code> line specifies the build ID, an opaque hash used by the build system
(typically the go command) as a version identifier, to help detect when a package
must be rebuilt.
This line is today the second line of <code class="docutils literal notranslate"><span class="pre">__.PKGDEF</span></code>, when present.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">main</span></code> line is present if the package archive is <code class="docutils literal notranslate"><span class="pre">package</span> <span class="pre">main</span></code>, making it a valid
top-level input for the linker. The command <code class="docutils literal notranslate"><span class="pre">go</span> <span class="pre">tool</span> <span class="pre">link</span> <span class="pre">x.a</span></code> will refuse to build
a binary from <code class="docutils literal notranslate"><span class="pre">x.a</span></code> if that package’s header does not have a <code class="docutils literal notranslate"><span class="pre">main</span></code> line.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">safe</span></code> line is present if the code was compiled with <code class="docutils literal notranslate"><span class="pre">-u</span></code>, indicating that it has
been checked for safety. When the linker is invoked with <code class="docutils literal notranslate"><span class="pre">-u</span></code>, it refuses to use
any unsafe package archives during the link.
This mode is experimental and carried forward from earlier versions of Go.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">main</span></code> and <code class="docutils literal notranslate"><span class="pre">safe</span></code> lines are today derived from the first line of the export data,
which echoes the package statement from the Go source code, followed by the
word <code class="docutils literal notranslate"><span class="pre">safe</span></code> for safe packages.
The new header omits the name of non-main packages entirely in order
to ensure that the header size is bounded no matter how long a package name
appears in the package’s source code.</p>
<p>More header lines may be added to the end of this list in the future,
always being careful to keep the overall header size bounded.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">_go_/export</span></code> file is usually required (details below), must be second in the archive,
and holds a description of the package’s exported API
for use by a later compilation importing the package.
The format of the export data is not specified here,
but as mentioned above part of the motivation for this design
is to make it possible to use a binary export data format
and to apply compression to it.
The export data corresponds to the top of the <code class="docutils literal notranslate"><span class="pre">__.PKGDEF</span></code> file,
excluding the initial <code class="docutils literal notranslate"><span class="pre">go</span> <span class="pre">object</span></code> and <code class="docutils literal notranslate"><span class="pre">build</span> <span class="pre">id</span></code> lines and stopping at the first <code class="docutils literal notranslate"><span class="pre">$$</span></code> line.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">_go_/cgo</span></code> file is optional and holds cgo-related directives for the linker.
The format of these directives is not specified here.
This data corresponds to the end of the Go object file metadata,
specifically the lines between the third <code class="docutils literal notranslate"><span class="pre">$$</span></code> line and the terminating <code class="docutils literal notranslate"><span class="pre">!</span></code> line.</p>
<p>Each of the <code class="docutils literal notranslate"><span class="pre">_go_/*.obj</span></code> files is a traditional Go object file,
holding machine code, data, and relocations processed by the linker.</p>
<p>Each of the <code class="docutils literal notranslate"><span class="pre">_go_/*.sysobj</span></code> files is a system object file,
either generated during the build by the system C compiler
or copied verbatim from a <code class="docutils literal notranslate"><span class="pre">*.syso</span></code> file in the package source directory
(see the <a class="reference external" href="https://golang.org/cmd/go/#hdr-File_types">go command documentation</a>
for more about <code class="docutils literal notranslate"><span class="pre">*.syso</span></code> files).</p>
<p>It is valid today and remains valid in this proposal for
multiple files within an archive to have the same name.
This simplifies the generation and combination of package files.</p>
</div>
<div class="section" id="rationale">
<h2>Rationale<a class="headerlink" href="#rationale" title="Permalink to this headline">¶</a></h2>
<div class="section" id="zip-format">
<h3>Zip format<a class="headerlink" href="#zip-format" title="Permalink to this headline">¶</a></h3>
<p>As discussed in the background section, the most fundamental problem
with the current archive format as used by Go is that all package metadata is
combined into the single <code class="docutils literal notranslate"><span class="pre">__.PKGDEF</span></code> file.
This is done for many reasons, all addressed by the use of zip files.</p>
<p>One reason for the single <code class="docutils literal notranslate"><span class="pre">__.PKGDEF</span></code> file is that there is
no efficient random access to files inside ar archives.
The first file in the archive is the only one that can be accessed
with a fixed number of disk I/O operations, and so it is often
given a distinguished role.
The zip format has a contiguous table of contents,
making it possible to access any file in the archive in a
fixed number of disk I/O operations.
This reduces the pressure to keep all important data in the first file.</p>
<p>It is still possible, however, to read a zip file from the beginning of the file,
without first consulting the table of contents.
The requirements that <code class="docutils literal notranslate"><span class="pre">_go_/header</span></code> be first, be uncompressed,
and be bounded in size exist precisely to make it possible to read
the package archive header by reading nothing but a prefix of the file
(say, the first kilobyte).
The requirement that <code class="docutils literal notranslate"><span class="pre">_go_/export</span></code> be second also makes it possible
for a compiler to read the header and export data without using
any disk I/O to read the table of contents.</p>
<p>As mentioned above, another reason for the single <code class="docutils literal notranslate"><span class="pre">__.PKGDEF</span></code> file
is that the metadata is stored not just in Go package archives but also
in Go object files, as written by <code class="docutils literal notranslate"><span class="pre">go</span> <span class="pre">tool</span> <span class="pre">compile</span></code> (without <code class="docutils literal notranslate"><span class="pre">-pack</span></code>) or <code class="docutils literal notranslate"><span class="pre">go</span> <span class="pre">tool</span> <span class="pre">asm</span></code>,
and those object files have no archive framing available.
Changing <code class="docutils literal notranslate"><span class="pre">*.o</span></code> files to reuse the Go package archive format
eliminates the need for a separate framing solution for metadata in <code class="docutils literal notranslate"><span class="pre">*.o</span></code> files.</p>
<p>Zip also makes it possible to make different compression decisions for
different files within an archive. This is important primarily because
we would like the option of compressing the export data and Go object files
but likely cannot compress the system object files, because reading them
requires having random access to the data.
It is also useful to be able to arrange that the header can be read
without the overhead of decompression.</p>
<p>We could take the current archive format and add a table of contents
and support for per-file compression methods, but why reinvent the wheel?
Zip is a standard format, and the Go standard library already supports it well.</p>
<p>The only other standard archive format in the Go standard library is the Unix tar format.
Tar is a marvel: it adds significant complexity to the ar format
without addressing any of the architectural problems that make ar unsuitable for our purposes.</p>
<p>In some circles, zip has a bad reputation.
I speculate that this is due to zip’s historically strong association with MS-DOS
and historically weak support on Unix systems.
Reputation aside, the zip format is clearly documented,
is well designed, and avoids the architectural problems of ar and tar.</p>
<p>It is perhaps worth noting that Java .jar files also use the zip format internally,
and that seems to be working well for them.</p>
</div>
<div class="section" id="file-names">
<h3>File names<a class="headerlink" href="#file-names" title="Permalink to this headline">¶</a></h3>
<p>The names of files within the package archives all begin with <code class="docutils literal notranslate"><span class="pre">_go_/</span></code>.
This is done so that Go packages are easier to distinguish from other zip files
and also so that an accidental <code class="docutils literal notranslate"><span class="pre">unzip</span> <span class="pre">x.a</span></code> is easier to clean up.</p>
<p>Distinguishing Go object files from system object files by name is new in this proposal.
Today, tools assume that <code class="docutils literal notranslate"><span class="pre">__.PKGDEF</span></code> is the only non-object file in the
package archive, and each file must be inspected to find out what kind
of object file it is (Go object or system object).
The suffixes make it possible to know both that a particular file
is an object file and what kind it is, without reading the file data.
The suffixes also isolate tools from each other, making it easier
to extend the archive with new data in new files.
For example, if some other part of the toolchain needs to add a
new file to the archive, the linker will automatically ignore it
(assuming the file name does not end in <code class="docutils literal notranslate"><span class="pre">.obj</span></code> or <code class="docutils literal notranslate"><span class="pre">.sysobj</span></code>).</p>
</div>
<div class="section" id="compression">
<h3>Compression<a class="headerlink" href="#compression" title="Permalink to this headline">¶</a></h3>
<p>Go export data and Go object files can both be quite large.</p>
<p>I ran experiment on a large program at Google, built with Go 1.5.
I gathered all the package archives linked into that program
corresponding to Go source code generated from protocol buffer definitions
(which can be quite large), and I ran the standard <code class="docutils literal notranslate"><span class="pre">gzip</span> <span class="pre">-1</span></code>
(fastest, least compression) on those files.
That resulted in a 7.5x space savings for the packages.</p>
<p>Clearly there are significant space improvements available
with only modest attempts at compression.</p>
<p>I ran another experiment on the main repo toward the end of the Go 1.6 cycle.
I changed the existing package archive format to force
compression of <code class="docutils literal notranslate"><span class="pre">__.PKGDEF</span></code> and all Go object files,
using Go’s compress/gzip at compression level 1,
when writing them to the package archive,
and I changed all readers to know to decompress them when
reading them back out of the archive.
This resulted in a 4X space savings for packages on disk:
the $GOROOT/pkg tree after make.bash shrunk from about 64 MB to about 16 MB.
The cost was an approximately 10% slowdown in make.bash time:
the roughly two minutes make.bash normally took on my laptop
was extended by about 10 seconds.</p>
<p>My experiment was not as efficient in its use of compression as it could be.
For example, the linker went to the trouble to open and decompress
the beginning of <code class="docutils literal notranslate"><span class="pre">__.PKGDEF</span></code> just to read the few bits it actually needed.</p>
<p>Independently, Klaus Post has been working on improving the
speed of Go’s compress/flate package (used by archive/zip,
compress/gzip, and compress/zlib) at all compression levels,
as well as the efficiency of the decompressor.
He has also replaced compression level 1 by a port of
the logic from Google’s Snappy (formerly Zippy) algorithm,
which was designed specifically for compression speed.
Unlike Snappy, though, his port produces DEFLATE-compatible
output, so it can be used by a compressor without requiring
a non-standard decompressor on the other side.</p>
<p>From the combination of a more careful separation of data within
the package archive and Klaus’s work on compression speed,
I expect the slowdown in make.bash due to
compression can be reduced to under 5% (for a 4X space savings!).</p>
<p>Of course, if the cost of compression is determined to be not paid for
by the space savings it brings, it is possible to use zip with no
compression at all.
The other benefits of the zip format still make this a worthwhile cleanup.</p>
</div>
</div>
<div class="section" id="compatibility">
<h2>Compatibility<a class="headerlink" href="#compatibility" title="Permalink to this headline">¶</a></h2>
<p>The toolchain is not subject to the <a class="reference external" href="https://golang.org/doc/go1compat">compatibility guidelines</a>.</p>
<p>Even so, this change is intended to be invisible to any use case that does not actually open a
package archive or object files and read the raw bytes contained within.</p>
</div>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>The implementation proceeds in these steps:</p>
<ol class="simple">
<li><p>Implementation of a new package <code class="docutils literal notranslate"><span class="pre">cmd/internal/pkg</span></code>
for manipulating zip-format package archives.</p></li>
<li><p>Replacement of the ar-format archives with zip-format archives,
but still containing the old files (<code class="docutils literal notranslate"><span class="pre">__.PKGDEF</span></code> followed by any number
of object files of unspecified type).</p></li>
<li><p>Implementation of the new file structure within the archives:
the separate metadata files and the forced suffixes for Go object files
and system object files.</p></li>
<li><p>Addition of compression.</p></li>
</ol>
<p>Steps 1, 2, and 3 should have no performance impact on build times.
We will measure the speed of make.bash to confirm this.</p>
<p>These steps depend on some extensions to the archive/zip package suggested by Roger Peppe.
He has implemented these and intends to send them early in the Go 1.7 cycle.</p>
<p>Step 4 will have a performance impact on build times.
It must be measured to make a proper engineering decision
about whether and how much to compress.</p>
<p>This step depends on the compress/flate performance improvements by Klaus Post described above.
He has implemented these and intends to send them early in the Go 1.7 cycle.</p>
<p>I will do this work early in the Go 1.7 cycle, immediately following Roger’s and Klaus’s work.
I have a rough but working prototype of steps 1, 2, and 3 already.
Enabling compression in the zip writer is a few lines of code beyond that.</p>
<p>Part of the motivation for doing this early in Go 1.7 is to make it possible
for Robert Griesemer to gather performance data for his new binary
export data format and enable that for Go 1.7 as well.
The binary export code is currently bottlenecked by the need to escape
and unescape the data to avoid generating a terminating <code class="docutils literal notranslate"><span class="pre">\n$$</span></code> sequence.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="14951-soft-heap-limit.html" class="btn btn-neutral float-right" title="Proposal: Separate soft and hard heap size goal" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="14313-benchmark-format.html" class="btn btn-neutral float-left" title="Proposal: Go Benchmark Data Format" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>