

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Proposal: Versioned Go Modules &mdash; Go Design Proposal  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Proposal: Non-cooperative goroutine preemption" href="24543-non-cooperative-preemption.html" />
    <link rel="prev" title="Proposal: emit DWARF inlining info in the Go compiler" href="22080-dwarf-inlining.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Go Design Proposal
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="11502-securitypolicy.html">Proposal: Security Policy for Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="11970-decentralized-gc.html">Proposal: Decentralized GC coordination</a></li>
<li class="toctree-l1"><a class="reference internal" href="12166-subtests.html">Proposal: testing: programmatic sub-test and sub-benchmark support</a></li>
<li class="toctree-l1"><a class="reference internal" href="12302-release-proposal.html">Proposal: A minimal release process for Go repositories</a></li>
<li class="toctree-l1"><a class="reference internal" href="12416-cgo-pointers.html">Proposal: Rules for passing pointers between Go and C</a></li>
<li class="toctree-l1"><a class="reference internal" href="12750-localization.html">Proposal: Localization support in Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="12800-sweep-free-alloc.html">Proposal: Dense mark bits and sweep-free allocation</a></li>
<li class="toctree-l1"><a class="reference internal" href="12914-monotonic.html">Proposal: Monotonic Elapsed Time Measurements in Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="12914-monotonic.html#appendix-time-now-usage">Appendix: time.Now usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="13073-code-of-conduct.html">Proposal: A Code of Conduct for the Go community</a></li>
<li class="toctree-l1"><a class="reference internal" href="13432-mobile-audio.html">Proposal: Audio for Mobile</a></li>
<li class="toctree-l1"><a class="reference internal" href="13504-natural-xml.html">Proposal: Natural XML</a></li>
<li class="toctree-l1"><a class="reference internal" href="14313-benchmark-format.html">Proposal: Go Benchmark Data Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="14386-zip-package-archives.html">Proposal: Zip-based Go package archives</a></li>
<li class="toctree-l1"><a class="reference internal" href="14951-soft-heap-limit.html">Proposal: Separate soft and hard heap size goal</a></li>
<li class="toctree-l1"><a class="reference internal" href="15292-generics.html">Proposal: Go should have generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="16085-conversions-ignore-tags.html">Proposal: Ignore tags in struct type conversions</a></li>
<li class="toctree-l1"><a class="reference internal" href="16339-alias-decls.html">Proposal: Alias declarations for Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="16339-alias-decls.html#appendix">Appendix</a></li>
<li class="toctree-l1"><a class="reference internal" href="16410-heap-viewer.html">Proposal: Go Heap Dump Viewer</a></li>
<li class="toctree-l1"><a class="reference internal" href="16704-cidr-notation-no-proxy.html">Proposal: Add support for CIDR notation in no_proxy variable</a></li>
<li class="toctree-l1"><a class="reference internal" href="17280-profile-labels.html">Proposal: Support for pprof profiler labels</a></li>
<li class="toctree-l1"><a class="reference internal" href="17503-eliminate-rescan.html">Proposal: Eliminate STW stack re-scanning</a></li>
<li class="toctree-l1"><a class="reference internal" href="17505-concurrent-rescan.html">Proposal: Concurrent stack re-scanning</a></li>
<li class="toctree-l1"><a class="reference internal" href="18130-type-alias.html">Proposal: Type Aliases</a></li>
<li class="toctree-l1"><a class="reference internal" href="18802-percpu-sharded.html">Proposal: percpu.Sharded, an API for reducing cache contention</a></li>
<li class="toctree-l1"><a class="reference internal" href="18802-percpu-sharded.html#discussion">Discussion</a></li>
<li class="toctree-l1"><a class="reference internal" href="18802-percpu-sharded.html#backwards-compatibility">Backwards compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="19113-signed-shift-counts.html">Proposal: Permit Signed Integers as Shift Counts for Go 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="19308-number-literals.html">Proposal: Go 2 Number Literal Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html">Proposal: Mid-stack inlining in the Go compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#abstract">Abstract</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#background">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#proposal">Proposal</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#rationale">Rationale</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#compatibility">Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#implementation">Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#prerequisite-changes">Prerequisite Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#preliminary-results">Preliminary Results</a></li>
<li class="toctree-l1"><a class="reference internal" href="19348-midstack-inlining.html#open-issues">Open issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="19480-xml-stream.html">Proposal: XML Stream</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html">Proposal: emit DWARF inlining info in the Go compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#abstract">Abstract</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#background">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#example">Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#how-the-generated-dwarf-should-look">How the generated DWARF should look</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#outline-of-proposed-changes">Outline of proposed changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#compatibility">Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#implementation">Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#prerequisite-changes">Prerequisite Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#preliminary-results">Preliminary Results</a></li>
<li class="toctree-l1"><a class="reference internal" href="22080-dwarf-inlining.html#open-issues">Open issues</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Proposal: Versioned Go Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#abstract">Abstract</a></li>
<li class="toctree-l2"><a class="reference internal" href="#background">Background</a></li>
<li class="toctree-l2"><a class="reference internal" href="#proposal">Proposal</a></li>
<li class="toctree-l2"><a class="reference internal" href="#rationale">Rationale</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#semantic-versions-constraints-and-solvers">Semantic versions, constraints, and solvers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#build-control">Build Control</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ecosystem-fragmentation">Ecosystem Fragmentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#semantic-import-versions">Semantic Import Versions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#update-timing-high-fidelity-builds">Update Timing &amp; High-Fidelity Builds</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#compatibility">Compatibility</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implementation">Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#open-issues-if-applicable">Open issues (if applicable)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="24543-non-cooperative-preemption.html">Proposal: Non-cooperative goroutine preemption</a></li>
<li class="toctree-l1"><a class="reference internal" href="25530-sumdb.html">Proposal: Secure the Public Go Module Ecosystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="25719-go15vendor.html">Go 1.5 Vendor Experiment</a></li>
<li class="toctree-l1"><a class="reference internal" href="26160-dns-based-vanity-imports.html">Proposal: DNS Based Vanity Imports</a></li>
<li class="toctree-l1"><a class="reference internal" href="26756-rawxml-token.html">Proposal: Raw XML Token</a></li>
<li class="toctree-l1"><a class="reference internal" href="26903-simplify-mark-termination.html">Proposal: Simplify mark termination and eliminate mark 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="27539-internal-abi.html">Proposal: Create an undefined internal calling convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="2775-binary-only-packages.html">Proposal: Binary-Only Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="27935-unbounded-queue-package.html">Proposal: Built in support for high performance unbounded queue</a></li>
<li class="toctree-l1"><a class="reference internal" href="28221-go2-transitions.html">Proposal: Go 2 transition</a></li>
<li class="toctree-l1"><a class="reference internal" href="2981-go-test-json.html">Proposal: <code class="docutils literal notranslate"><span class="pre">-json</span></code> flag in <code class="docutils literal notranslate"><span class="pre">go</span> <span class="pre">test</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="29934-error-values.html">Proposal: Go 2 Error Inspection</a></li>
<li class="toctree-l1"><a class="reference internal" href="30333-smarter-scavenging.html">Proposal: Smarter Scavenging</a></li>
<li class="toctree-l1"><a class="reference internal" href="30411-env.html">Proposal: <code class="docutils literal notranslate"><span class="pre">go</span></code> command configuration file</a></li>
<li class="toctree-l1"><a class="reference internal" href="32437-try-builtin.html">Proposal: A built-in Go error check function, <code class="docutils literal notranslate"><span class="pre">try</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="33974-add-public-lockedfile-pkg.html">Proposal: make the internal lockedfile package public</a></li>
<li class="toctree-l1"><a class="reference internal" href="34481-opencoded-defers.html">Proposal: Low-cost defers through inline code, and extra funcdata to manage the panic case</a></li>
<li class="toctree-l1"><a class="reference internal" href="35112-scaling-the-page-allocator.html">Proposal: Scaling the Go page allocator</a></li>
<li class="toctree-l1"><a class="reference internal" href="36460-lazy-module-loading.html">Proposal: Lazy Module Loading</a></li>
<li class="toctree-l1"><a class="reference internal" href="36606-64-bit-field-alignment.html">Proposal: Make 64-bit fields be 64-bit aligned on 32-bit systems, add //go:packed, //go:align directives</a></li>
<li class="toctree-l1"><a class="reference internal" href="37112-unstable-runtime-metrics.html">Proposal: API for unstable runtime metrics</a></li>
<li class="toctree-l1"><a class="reference internal" href="37720-gopls-workspaces.html">Proposal: Multi-project gopls workspaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="4899-testing-helper.html">Proposal: testing: better support test helper functions with TB.Helper</a></li>
<li class="toctree-l1"><a class="reference internal" href="6282-table-data.html">Proposal: Multi-dimensional slices</a></li>
<li class="toctree-l1"><a class="reference internal" href="6977-overlapping-interfaces.html">Proposal: Permit embedding of interfaces with overlapping method sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="TEMPLATE.html">Proposal: [Title]</a></li>
<li class="toctree-l1"><a class="reference internal" href="cryptography-principles.html">Cryptography Principles</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft.html">Go 2 Draft Designs</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-contracts.html">Contracts — Draft Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-handling.html">Error Handling — Draft Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-handling-overview.html">Error Handling — Problem Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-inspection.html">Error Inspection — Draft Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-printing.html">Error Printing — Draft Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-error-values-overview.html">Error Values — Problem Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-generics-overview.html">Generics — Problem Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="go2draft-type-parameters.html">Type Parameters - Draft Design</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Go Design Proposal</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Proposal: Versioned Go Modules</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/24301-versioned-go.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="proposal-versioned-go-modules">
<h1>Proposal: Versioned Go Modules<a class="headerlink" href="#proposal-versioned-go-modules" title="Permalink to this headline">¶</a></h1>
<p>Author: Russ Cox<br />Last Updated: March 20, 2018<br />Discussion: https://golang.org/issue/24301</p>
<div class="section" id="abstract">
<h2>Abstract<a class="headerlink" href="#abstract" title="Permalink to this headline">¶</a></h2>
<p>We propose to add awareness of package versions to the Go toolchain, especially the <code class="docutils literal notranslate"><span class="pre">go</span></code> command.</p>
</div>
<div class="section" id="background">
<h2>Background<a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h2>
<p>The first half of the blog post <a class="reference external" href="https://research.swtch.com/vgo-intro">Go += Package Versioning</a> presents detailed background for this change.
In short, it is long past time to add versions to the working vocabulary of both Go developers and our tools,
and this proposal describes a way to do that.</p>
<p><a class="reference external" href="https://semver.org">Semantic versioning</a> is the name given to an established convention for assigning version numbers
to projects.
In its simplest form, a version number is MAJOR.MINOR.PATCH, where MAJOR, MINOR, and PATCH
are decimal numbers.
The syntax used in this proposal follows the widespread convention of
adding a “v” prefix: vMAJOR.MINOR.PATCH.
Incrementing MAJOR indicates an expected breaking change.
Otherwise, a later version is expected to be backwards compatible
with earlier versions within the same MAJOR version sequence.
Incrementing MINOR indicates a significant change or new features.
Incrementing PATCH is meant to be reserved for very small, very safe changes,
such as small bug fixes or critical security patches.</p>
<p>The sequence of <a class="reference external" href="https://research.swtch.com/vgo">vgo-related blog posts</a> presents more detail
about the proposal.</p>
</div>
<div class="section" id="proposal">
<h2>Proposal<a class="headerlink" href="#proposal" title="Permalink to this headline">¶</a></h2>
<p>I propose to add versioning to Go using the following approach.</p>
<ol>
<li><p>Introduce the concept of a <em>Go module</em>, which is a group of
packages that share a common prefix, the <em>module path</em>, and are versioned together as a single unit.
Most projects will adopt a workflow in which a version-control repository
corresponds exactly to a single module.
Larger projects may wish to adopt a workflow in which a
version-control repository can hold multiple modules.
Both workflows will be supported.</p></li>
<li><p>Assign version numbers to modules by tagging specific commits
with <a class="reference external" href="https://semver.org">semantic versions</a> such as <code class="docutils literal notranslate"><span class="pre">v1.2.0</span></code>.
(See
the <a class="reference external" href="https://research.swtch.com/vgo-module">Defining Go Modules</a> post
for details, including how to tag multi-module repositories.)</p></li>
<li><p>Adopt <a class="reference external" href="https://research.swtch.com/vgo-import">semantic import versioning</a>,
in which each major version has a distinct import path.
Specifically, an import path contains a module path, a version number,
and the the path to a specific package inside the module.
If the major version is v0 or v1, then the version number element
must be omitted; otherwise it must be included.</p>
<p style="text-align:center">
<img width=343 height=167 src="24301/impver.png" srcset="24301/impver.png 1x, 24301/impver@1.5x.png 1.5x, 24301/impver@2x.png 2x, 24301/impver@3x.png 3x, 24301/impver@4x.png 4x">
</p><p>The packages imported as <code class="docutils literal notranslate"><span class="pre">my/thing/sub/pkg</span></code>, <code class="docutils literal notranslate"><span class="pre">my/thing/v2/sub/pkg</span></code>, and <code class="docutils literal notranslate"><span class="pre">my/thing/v3/sub/pkg</span></code>
come from major versions v1, v2, and v3 of the module <code class="docutils literal notranslate"><span class="pre">my/thing</span></code>,
but the build treats them simply as three different packages.
A program that imports all three will have all three linked into the final binary,
just as if they were <code class="docutils literal notranslate"><span class="pre">my/red/pkg</span></code>, <code class="docutils literal notranslate"><span class="pre">my/green/pkg</span></code>, and <code class="docutils literal notranslate"><span class="pre">my/blue/pkg</span></code>
or any other set of three different import paths.</p>
<p>Note that only the major version appears in the import path: <code class="docutils literal notranslate"><span class="pre">my/thing/v1.2/sub/pkg</span></code> is not allowed.</p>
</li>
<li><p>Explicitly adopt the “import compatibility rule”:</p>
<blockquote>
<div><p><em>If an old package and a new package have the same import path,</em><br /><em>the new package must be backwards compatible with the old package.</em></p>
</div></blockquote>
<p>The Go project has encouraged this convention from the start
of the project, but this proposal gives it more teeth:
upgrades by package users will succeed or fail
only to the extent that package authors follow the import
compatibility rule.</p>
<p>The import compatibility rule only applies to tagged
releases starting at v1.0.0.
Prerelease (vX.Y.Z-anything) and v0.Y.Z versions
need not follow compatibility with earlier versions,
nor do they impose requirements on future versions.
In contrast, tagging a commit vX.Y.Z for X ≥ 1 explicitly
indicates “users can expect this module to be stable.”</p>
<p>In general, users should expect a module to follow
the <a class="reference external" href="https://golang.org/doc/go1compat#expectations">Go 1 compatibility rules</a>
once it reaches v1.0.0,
unless the module’s documentation clearly states exceptions.</p>
</li>
<li><p>Record each module’s path and dependency requirements in a
<a class="reference external" href="XXX"><code class="docutils literal notranslate"><span class="pre">go.mod</span></code> file</a> stored in the root of the module’s file tree.</p></li>
<li><p>To decide which module versions to use in a given build,
apply <a class="reference external" href="https://research.swtch.com/vgo-mvs">minimal version selection</a>:
gather the transitive closure of all the listed requirements
and then remove duplicates of a given major version of a module
by keeping the maximum requested version,
which is also the minimum version satisfying all listed requirements.</p>
<p>Minimal version selection has two critical properties.
First, it is trivial to implement and understand.
Second, it never chooses a module version not listed in some <code class="docutils literal notranslate"><span class="pre">go.mod</span></code> file
involved in the build: new versions are not incorporated
simply because they have been published.
The second property produces <a class="reference external" href="XXX">high-fidelity builds</a>
and makes sure that upgrades only happen when
developers request them, never unexpectedly.</p>
</li>
<li><p>Define a specific zip file structure as the
“interchange format” for Go modules.
The vast majority of developers will work directly with
version control and never think much about these zip files,
if at all, but having a single representation
enables proxies, simplifies analysis sites like godoc.org
or continuous integration, and likely enables more
interesting tooling not yet envisioned.</p></li>
<li><p>Define a URL schema for fetching Go modules from proxies,
used both for installing modules using custom domain names
and also when the <code class="docutils literal notranslate"><span class="pre">$GOPROXY</span></code> environment variable is set.
The latter allows companies and individuals to send all
module download requests through a proxy for security,
availability, or other reasons.</p></li>
<li><p>Allow running the <code class="docutils literal notranslate"><span class="pre">go</span></code> command in file trees outside GOPATH,
provided there is a <code class="docutils literal notranslate"><span class="pre">go.mod</span></code> in the current directory or a
parent directory.
That <code class="docutils literal notranslate"><span class="pre">go.mod</span></code> file defines the mapping from file system to import path
as well as the specific module versions used in the build.
See the <a class="reference external" href="https://research.swtch.com/vgo-cmd">Versioned Go Commands</a> post for details.</p></li>
<li><p>Disallow use of <code class="docutils literal notranslate"><span class="pre">vendor</span></code> directories, except in one limited use:
a <code class="docutils literal notranslate"><span class="pre">vendor</span></code> directory at the top of the file tree of the top-level module
being built is still applied to the build,
to continue to allow self-contained application repositories.
(Ignoring other <code class="docutils literal notranslate"><span class="pre">vendor</span></code> directories ensures that
Go returns to builds in which each import path has the same
meaning throughout the build
and establishes that only one copy of a package with a given import
path is used in a given build.)</p></li>
</ol>
<p>The “<a class="reference external" href="https://research.swtch.com/vgo-tour">Tour of Versioned Go</a>”
blog post demonstrates how most of this fits together to create a smooth user experience.</p>
</div>
<div class="section" id="rationale">
<h2>Rationale<a class="headerlink" href="#rationale" title="Permalink to this headline">¶</a></h2>
<p>Go has struggled with how to incorporate package versions since <code class="docutils literal notranslate"><span class="pre">goinstall</span></code>,
the predecessor to <code class="docutils literal notranslate"><span class="pre">go</span> <span class="pre">get</span></code>, was released eight years ago.
This proposal is the result of eight years of experience with <code class="docutils literal notranslate"><span class="pre">goinstall</span></code> and <code class="docutils literal notranslate"><span class="pre">go</span> <span class="pre">get</span></code>,
careful examination of how other languages approach the versioning problem,
and lessons learned from Dep, the experimental Go package management tool released in January 2017.</p>
<p>A few people have asked why we should add the concept of versions to our tools at all.
Packages do have versions, whether the tools understand them or not.
Adding explicit support for versions
lets tools and developers communicate more clearly when
specifying a program to be built, run, or analyzed.</p>
<p>At the start of the process that led to this proposal, almost two years ago,
we all believed the answer would be to follow the package versioning approach
exemplified by Ruby’s Bundler and then Rust’s Cargo:
tagged semantic versions,
a hand-edited dependency constraint file known as a manifest,
a machine-generated transitive dependency description known as a lock file,
a version solver to compute a lock file satisfying the manifest,
and repositories as the unit of versioning.
Dep, the community effort led by Sam Boyer, follows this plan almost exactly
and was originally intended to serve as the model for <code class="docutils literal notranslate"><span class="pre">go</span></code> command
integration.
Dep has been a significant help for Go developers
and a positive step for the Go ecosystem.</p>
<p>Early on, we talked about Dep simply becoming <code class="docutils literal notranslate"><span class="pre">go</span> <span class="pre">dep</span></code>,
serving as the prototype of <code class="docutils literal notranslate"><span class="pre">go</span></code> command integration.
However, the more I examined the details of the Bundler/Cargo/Dep
approach and what they would mean for Go, especially built into the <code class="docutils literal notranslate"><span class="pre">go</span></code> command,
a few of the details seemed less and less a good fit.
This proposal adjusts those details in the hope of
shipping a system that is easier for developers to understand
and to use.</p>
<div class="section" id="semantic-versions-constraints-and-solvers">
<h3>Semantic versions, constraints, and solvers<a class="headerlink" href="#semantic-versions-constraints-and-solvers" title="Permalink to this headline">¶</a></h3>
<p>Semantic versions are a reasonable convention for
specifying software versions,
and version control tags written as semantic versions
have a clear meaning,
but the <a class="reference external" href="https://semver.org/">semver spec</a> critically does not
prescribe how to build a system using them.
What tools should do with the version information?
Dave Cheney’s 2015 <a class="reference external" href="https://golang.org/issue/12302">proposal to adopt semantic versioning</a>
was eventually closed exactly because, even though everyone
agreed semantic versions seemed like a good idea,
we didn’t know the answer to the question of what to do with them.</p>
<p>The Bundler/Cargo/Dep approach is one answer.
Allow authors to specify arbitrary constraints on their dependencies.
Build a given target by collecting all its dependencies
recursively and finding a configuration satisfying all those
constraints.</p>
<p>Unfortunately, the arbitrary constraints make finding a
satisfying configuration very difficult.
There may be many satisfying configurations, with no clear way to choose just one.
For example, if the only two ways to build A are by using B 1 and C 2
or by using B 2 and C 1, which should be preferred, and how should developers remember?
Or there may be no satisfying configuration.
Also, it can be very difficult to tell whether there are many, one, or no
satisfying configurations:
allowing arbitrary constraints makes
version solving problem an NP-complete problem,
<a class="reference external" href="https://research.swtch.com/version-sat">equivalent to solving SAT</a>.
In fact, most package managers now rely on SAT solvers
to decide which packages to install.
But the general problem remains:
there may be many equally good configurations,
with no clear way to choose between them,
there may be a single best configuration,
or there may be no good configurations,
and it can be very expensive to determine
which is the case in a given build.</p>
<p>This proposal’s approach is a new answer, in which authors can specify
only limited constraints on dependencies: only the minimum required versions.
Like in Bundler/Cargo/Dep, this proposal builds a given target by
collecting all dependencies recursively and then finding
a configuration satisfying all constraints.
However, unlike in Bundler/Cargo/Dep, the process of finding a
satisfying configuration is trivial.
As explained in the <a class="reference external" href="https://research.swtch.com/vgo-mvs">minimal version selection</a> post,
a satisfying configuration always exists,
and the set of satisfying configurations forms a lattice with
a unique minimum.
That unique minimum is the configuration that uses exactly the
specified version of each module, resolving multiple constraints
for a given module by selecting the maximum constraint,
or equivalently the minimum version that satisfies all constraints.
That configuration is trivial to compute and easy for developers
to understand and predict.</p>
</div>
<div class="section" id="build-control">
<h3>Build Control<a class="headerlink" href="#build-control" title="Permalink to this headline">¶</a></h3>
<p>A module’s dependencies must clearly be given some control over that module’s build.
For example, if A uses dependency B, which uses a feature of dependency C introduced in C 1.5,
B must be able to ensure that A’s build uses C 1.5 or later.</p>
<p>At the same time, for builds to remain predictable and understandable,
a build system cannot give dependencies arbitrary, fine-grained control
over the top-level build.
That leads to conflicts and surprises.
For example, suppose B declares that it requires an even version of D, while C declares that it requires a prime version of D.
D is frequently updated and is up to D 1.99.
Using B or C in isolation, it’s always possible to use a relatively recent version of D (D 1.98 or D 1.97, respectively).
But when A uses both B and C,
a SAT solver-based build silently selects the much older (and buggier) D 1.2 instead.
To the extent that SAT solver-based build systems actually work,
it is because dependencies don’t choose to exercise this level of control.
But then why allow them that control in the first place?</p>
<p>Although the hypothetical about prime and even versions is clearly unlikely,
real problems do arise.
For example, issue <a class="reference external" href="https://github.com/kubernetes/client-go/issues/325">kubernetes/client-go#325</a> was filed in November 2017,
complaining that the Kubernetes Go client pinned builds to a specific version of <code class="docutils literal notranslate"><span class="pre">gopkg.in/yaml.v2</span></code> from
September 2015, two years earlier.
When a developer tried to use
a new feature of that YAML library in a program that already
used the Kubernetes Go client,
even after attempting to upgrade to the latest possible version,
code using the new feature failed to compile,
because “latest” had been constrained by the Kubernetes requirement.
In this case, the use of a two-year-old YAML library version may be entirely reasonable within the context of the Kubernetes code base,
and clearly the Kubernetes authors should have complete
control over their own builds,
but that level of control does not make sense to extend to other developers’ builds.
The issue was closed after a change in February 2018
to update the specific YAML version pinned to one from July 2017.
But the issue is not really “fixed”:
Kubernetes still pins a specific, increasingly old version of the YAML library.
The fundamental problem is that the build system
allows the Kubernetes Go client to do this at all,
at least when used as a dependency in a larger build.</p>
<p>This proposal aims to balance
allowing dependencies enough control to ensure a successful
build with not allowing them so much control that they break the build.
Minimum requirements combine without conflict,
so it is feasible (even easy) to gather them from all dependencies,
and they make it impossible to pin older versions,
as Kubernetes does.
Minimal version selection gives
the top-level module in the build additional control,
allowing it to exclude specific module versions
or replace others with different code,
but those exclusions and replacements only apply
when found in the top-level module, not when the module
is a dependency in a larger build.</p>
<p>A module author is therefore in complete control of
that module’s build when it is the main program being built,
but not in complete control of other users’ builds that depend on the module.
I believe this distinction will make this proposal
scale to much larger, more distributed code bases than
the Bundler/Cargo/Dep approach.</p>
</div>
<div class="section" id="ecosystem-fragmentation">
<h3>Ecosystem Fragmentation<a class="headerlink" href="#ecosystem-fragmentation" title="Permalink to this headline">¶</a></h3>
<p>Allowing all modules involved in a build to impose arbitrary
constraints on the surrounding build harms not just that build
but the entire language ecosystem.
If the author of popular package P finds that
dependency D 1.5 has introduced a change that
makes P no longer work,
other systems encourage the author of P to issue
a new version that explicitly declares it needs D &lt; 1.5.
Suppose also that popular package Q is eager to take
advantage of a new feature in D 1.5
and issues a new version that explicitly declares it needs D ≥ 1.6.
Now the ecosystem is divided, and programs must choose sides:
are they P-using or Q-using? They cannot be both.</p>
<p>In contrast, being allowed to specify only a minimum required version
for a dependency makes clear that P’s author must either
(1) release a new, fixed version of P;
(2) contact D’s author to issue a fixed D 1.6 and then release a new P declaring a requirement on D 1.6 or later;
or else (3) start using a fork of D 1.4 with a different import path.
Note the difference between a new P that requires “D before 1.5”
compared to “D 1.6 or later.”
Both avoid D 1.5, but “D before 1.5” explains only which builds fail,
while “D 1.6 or later” explains how to make a build succeed.</p>
</div>
<div class="section" id="semantic-import-versions">
<h3>Semantic Import Versions<a class="headerlink" href="#semantic-import-versions" title="Permalink to this headline">¶</a></h3>
<p>The example of ecosystem fragmentation in the previous section
is worse when it involves major versions.
Suppose the author of popular package P has used D 1.X as a dependency,
and then popular package Q decides to update to D 2.X because it
is a nicer API.
If we adopt Dep’s semantics,
now the ecosystem is again divided, and programs must again choose sides:
are they P-using (D 1.X-using) or Q-using (D 2.X-using)?
They cannot be both.
Worse,
in this case, because D 1.X and D 2.X are different major versions
with different APIs, it is completely reasonable for the author of P
to continue to use D 1.X, which might even continue to be updated with
features and bug fixes.
That continued usage only prolongs the divide.
The end result is that
a widely-used package like D would in practice either
be practically prohibited from issue version 2 or
else split the ecosystem in half by doing so.
Neither outcome is desirable.</p>
<p>Rust’s Cargo makes a different choice from Dep.
Cargo allows each package to specify whether
a reference to D means D 1.X or D 2.X.
Then, if needed, Cargo links both a D 1.X and a D 2.X into the final binary.
This approach works better than Dep’s,
but users can still get stuck.
If P exposes D 1.X in its own API and Q exposes D 2.X in its own API,
then a single client package C cannot use both P and Q,
because it will not be able to refer to both D 1.X (when using P)
and D 2.X (when using Q).
The <a class="reference external" href="https://research.swtch.com/vgo-import">dependency story</a> in the semantic import versioning post
presents an equivalent scenario in more detail.
In that story, the base package manager starts out being like Dep,
and the <code class="docutils literal notranslate"><span class="pre">-fmultiverse</span></code> flag makes it more like Cargo.</p>
<p>If Cargo is one step away from Dep, semantic import versioning is two steps away.
In addition to allowing different major versions to be used
in a single build,
semantic import versioning gives the different major versions different names,
so that there’s never any ambiguity
about which is meant in a given program file.
Making the import paths precise about the expected
semantics of the thing being imported (is it v1 or v2?)
eliminates the possibility of problems like those client C experienced
in the previous example.</p>
<p>More generally, in semantic import versioning,
an import of <code class="docutils literal notranslate"><span class="pre">my/thing</span></code> asks for the semantics of v1.X of <code class="docutils literal notranslate"><span class="pre">my/thing</span></code>.
As long as <code class="docutils literal notranslate"><span class="pre">my/thing</span></code> is following the import compatibility rule,
that’s a well-defined set of functionality,
satisfied by the latest v1.X and possibly earlier ones
(as constrained by <code class="docutils literal notranslate"><span class="pre">go.mod</span></code>).
Similarly, an import of <code class="docutils literal notranslate"><span class="pre">my/thing/v2</span></code> asks for the semantics of v2.X of <code class="docutils literal notranslate"><span class="pre">my/thing</span></code>,
satisfied by the latest v2.X and possibly earlier ones
(again constrained by <code class="docutils literal notranslate"><span class="pre">go.mod</span></code>).
The meaning of the imports is clear, to both people and tools,
from reading only the Go source code,
without reference to <code class="docutils literal notranslate"><span class="pre">go.mod</span></code>.
If instead we followed the Cargo approach, both imports would be <code class="docutils literal notranslate"><span class="pre">my/thing</span></code>, and the
meaning of that import would be ambiguous from the source code alone,
resolved only by reading <code class="docutils literal notranslate"><span class="pre">go.mod</span></code>.</p>
<p>Our article “<a class="reference external" href="https://golang.org/doc/articles/go_command.html">About the go command</a>” explains:</p>
<blockquote>
<div><p>An explicit goal for Go from the beginning was to be able to build Go code
using only the information found in the source itself, not needing to write
a makefile or one of the many modern replacements for makefiles.
If Go needed a configuration file to explain how to build your program,
then Go would have failed.</p>
</div></blockquote>
<p>It is an explicit goal of this proposal’s design to preserve this property,
to avoid making the general semantics of a Go source file change depending on
the contents of <code class="docutils literal notranslate"><span class="pre">go.mod</span></code>.
With semantic import versioning, if <code class="docutils literal notranslate"><span class="pre">go.mod</span></code> is deleted and
recreated from scratch, the effect is only to possibly update
to newer versions of imported packages, but still ones that are
still expected to work, thanks to import compatibility.
In contrast, if we take the Cargo approach, in which the <code class="docutils literal notranslate"><span class="pre">go.mod</span></code> file
must disambiguate between the arbitrarily different semantics of
v1 and v2 of <code class="docutils literal notranslate"><span class="pre">my/thing</span></code>, then <code class="docutils literal notranslate"><span class="pre">go.mod</span></code> becomes a required configuration file,
violating the original goal.</p>
<p>More generally, the main objection to adding <code class="docutils literal notranslate"><span class="pre">/v2/</span></code> to import paths is that
it’s a bit longer, a bit ugly, and it makes explicit a semantically important
detail that other systems abstract away, which in turn induces more work for authors,
compared to other systems, when they change that detail.
But all of these were true when we introduced <code class="docutils literal notranslate"><span class="pre">goinstall</span></code>’s URL-like import paths,
and they’ve been a clear success.
Before <code class="docutils literal notranslate"><span class="pre">goinstall</span></code>, programmers wrote things like <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">&quot;igo/set&quot;</span></code>.
To make that import work, you had to know to first check out <code class="docutils literal notranslate"><span class="pre">github.com/jacobsa/igo</span></code> into <code class="docutils literal notranslate"><span class="pre">$GOPATH/src/igo</span></code>.
The abbreviated paths had the benefit that if you preferred
a different version of <code class="docutils literal notranslate"><span class="pre">igo</span></code>, you could check your variant into
<code class="docutils literal notranslate"><span class="pre">$GOPATH/src/igo</span></code> instead, without updating any imports.
But the abbreviated imports also had the very real drawbacks that a build trying to use
both <code class="docutils literal notranslate"><span class="pre">igo/set</span></code> variants could not, and also that the Go source code did not record
anywhere exactly which <code class="docutils literal notranslate"><span class="pre">igo/set</span></code> it meant.
When <code class="docutils literal notranslate"><span class="pre">goinstall</span></code> introduced <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">&quot;github.com/jacobsa/igo/set&quot;</span></code> instead,
that made the imports a bit longer and a bit ugly,
but it also made explicit a semantically important detail:
exactly which <code class="docutils literal notranslate"><span class="pre">igo/set</span></code> was meant.
The longer paths created a little more work for authors compared
to systems that stashed that information in a single configuration file.
But eight years later, no one notices the longer import paths,
we’ve stopped seeing them as ugly,
and we now rely on the benefits of being explicit about
exactly which package is meant by a given import.
I expect that once <code class="docutils literal notranslate"><span class="pre">/v2/</span></code> elements in import paths are
common in Go source files, the same will happen:
we will no longer notice the longer paths,
we will stop seeing them as ugly, and we will rely on the benefits of
being explicit about exactly which semantics are meant by a given import.</p>
</div>
<div class="section" id="update-timing-high-fidelity-builds">
<h3>Update Timing &amp; High-Fidelity Builds<a class="headerlink" href="#update-timing-high-fidelity-builds" title="Permalink to this headline">¶</a></h3>
<p>In the Bundler/Cargo/Dep approach, the package manager always prefers
to use the latest version of any dependency.
These systems use the lock file to override that behavior,
holding the updates back.
But lock files only apply to whole-program builds,
not to newly imported libraries.
If you are working on module A, and you add a new requirement on module B, which in turn requires module C,
these systems will fetch the latest of B and then also the latest of C.
In contrast, this proposal still fetches the latest of B (because it is
what you are adding to the project explicitly, and the default is to
take the latest of explicit additions) but then prefers to use the
exact version of C that B requires.
Although newer versions of C should work, it is safest to
use the one that B did.
Of course, if the build has a different reason to use a newer version of C, it can do that.
For example, if A also imports D, which requires a newer C, then the build should and will use that newer version.
But in the absence of such an overriding requirement,
minimal version selection will build A using the exact version of C requested by B.
If, later, a new version of B is released requesting a newer version of C,
then when A updates to that newer B,
C will be updated only to the version that the new B requires, not farther.
The <a class="reference external" href="https://research.swtch.com/vgo-mvs">minimal version selection</a> blog post
refers to this kind of build as a “high-fidelity build.”</p>
<p>Minimal version selection has the key property that a recently-published version of C
is never used automatically.
It is only used when a developer asks for it explicitly.
For example, the developer of A could ask for all dependencies, including transitive dependencies, to be updated.
Or, less directly, the developer of B could update C and release a new B,
and then the developer of A could update B.
But either way, some developer working on some package in the build must
take an explicit action asking for C to be updated,
and then the update does not take effect in A’s build until
a developer working on A updates some dependency leading to C.
Waiting until an update is requested ensures that updates only happen
when developers are ready to test them and deal with the possibility
of breakage.</p>
<p>Many developers recoil at the idea that adding the latest B would not
automatically also add the latest C,
but if C was just released, there’s no guarantee it works in this build.
The more conservative position is to avoid using it until the user asks.
For comparison, the Go 1.9 go command does not automatically start using Go 1.10
the day Go 1.10 is released.
Instead, users are expected to update on their own
schedule,
so that they can control when they take on the risk of things breaking.
The reasons not to update automatically to the latest Go release
applies even more to individual packages:
there are more of them,
and most are not tested for backwards compatibility
as extensively as Go releases are.</p>
<p>If a developer does want to update all dependencies to the latest version,
that’s easy: <code class="docutils literal notranslate"><span class="pre">go</span> <span class="pre">get</span> <span class="pre">-u</span></code>.
We may also add a <code class="docutils literal notranslate"><span class="pre">go</span> <span class="pre">get</span> <span class="pre">-p</span></code> that updates all dependencies to their
latest patch versions, so that C 1.2.3 might be updated to C 1.2.5 but not to C 1.3.0.
If the Go community as a whole reserved patch versions only for very safe
or security-critical changes, then that <code class="docutils literal notranslate"><span class="pre">-p</span></code> behavior might be useful.</p>
</div>
</div>
<div class="section" id="compatibility">
<h2>Compatibility<a class="headerlink" href="#compatibility" title="Permalink to this headline">¶</a></h2>
<p>The work in this proposal is not constrained by
the <a class="reference external" href="https://golang.org/doc/go1compat">compatibility guidelines</a> at all.
Those guidelines apply to the language and standard library APIs, not tooling.
Even so, compatibility more generally is a critical concern.
It would be a serious mistake to deploy changes to the <code class="docutils literal notranslate"><span class="pre">go</span></code> command
in a way that breaks all existing Go code or splits the ecosystem into
module-aware and non-module-aware packages.
On the contrary, we must make the transition as smooth and seamless as possible.</p>
<p>Module-aware builds can import non-module-aware packages
(those outside a tree with a <code class="docutils literal notranslate"><span class="pre">go.mod</span></code> file)
provided they are tagged with a v0 or v1 semantic version.
They can also refer to any specific commit using a “pseudo-version”
of the form v0.0.0-<em>yyyymmddhhmmss</em>-<em>commit</em>.
The pseudo-version form allows referring to untagged commits
as well as commits that are tagged with semantic versions at v2 or above
but that do not follow the semantic import versioning convention.</p>
<p>Module-aware builds can also consume requirement information
not just from <code class="docutils literal notranslate"><span class="pre">go.mod</span></code> files but also from all known pre-existing
version metadata files in the Go ecosystem:
<code class="docutils literal notranslate"><span class="pre">GLOCKFILE</span></code>, <code class="docutils literal notranslate"><span class="pre">Godeps/Godeps.json</span></code>, <code class="docutils literal notranslate"><span class="pre">Gopkg.lock</span></code>, <code class="docutils literal notranslate"><span class="pre">dependencies.tsv</span></code>,
<code class="docutils literal notranslate"><span class="pre">glide.lock</span></code>, <code class="docutils literal notranslate"><span class="pre">vendor.conf</span></code>, <code class="docutils literal notranslate"><span class="pre">vendor.yml</span></code>, <code class="docutils literal notranslate"><span class="pre">vendor/manifest</span></code>,
and <code class="docutils literal notranslate"><span class="pre">vendor/vendor.json</span></code>.</p>
<p>Existing tools like <code class="docutils literal notranslate"><span class="pre">dep</span></code> should have no trouble consuming
Go modules, simply ignoring the <code class="docutils literal notranslate"><span class="pre">go.mod</span></code> file.
It may also be helpful to add support to <code class="docutils literal notranslate"><span class="pre">dep</span></code> to read <code class="docutils literal notranslate"><span class="pre">go.mod</span></code> files in
dependencies, so that <code class="docutils literal notranslate"><span class="pre">dep</span></code> users are unaffected as their
dependencies move from <code class="docutils literal notranslate"><span class="pre">dep</span></code> to the new module support.</p>
</div>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>A prototype of the proposal is implemented in a fork of the <code class="docutils literal notranslate"><span class="pre">go</span></code> command called <code class="docutils literal notranslate"><span class="pre">vgo</span></code>,
available using <code class="docutils literal notranslate"><span class="pre">go</span> <span class="pre">get</span> <span class="pre">-u</span> <span class="pre">golang.org/x/vgo</span></code>.
We will refine this implementation during the Go 1.11 cycle and
merge it back into <code class="docutils literal notranslate"><span class="pre">cmd/go</span></code> in the main repository.</p>
<p>The plan, subject to proposal approval,
is to release module support in Go 1.11
as an optional feature that may still change.
The Go 1.11 release will give users a chance to use modules “for real”
and provide critical feedback.
Even though the details may change, future releases will
be able to consume Go 1.11-compatible source trees.
For example, Go 1.12 will understand how to consume
the Go 1.11 <code class="docutils literal notranslate"><span class="pre">go.mod</span></code> file syntax, even if by then the
file syntax or even the file name has changed.
In a later release (say, Go 1.12), we will declare the module support completed.
In a later release (say, Go 1.13), we will end support for <code class="docutils literal notranslate"><span class="pre">go</span></code> <code class="docutils literal notranslate"><span class="pre">get</span></code> of non-modules.
Support for working in GOPATH will continue indefinitely.</p>
</div>
<div class="section" id="open-issues-if-applicable">
<h2>Open issues (if applicable)<a class="headerlink" href="#open-issues-if-applicable" title="Permalink to this headline">¶</a></h2>
<p>We have not yet converted large, complex repositories to use modules.
We intend to work with the Kubernetes team and others (perhaps CoreOS, Docker)
to convert their use cases.
It is possible those conversions will turn up reasons for adjustments
to the proposal as described here.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="24543-non-cooperative-preemption.html" class="btn btn-neutral float-right" title="Proposal: Non-cooperative goroutine preemption" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="22080-dwarf-inlining.html" class="btn btn-neutral float-left" title="Proposal: emit DWARF inlining info in the Go compiler" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>